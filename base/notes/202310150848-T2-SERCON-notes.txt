{214}  -*-  mode: text; fill-column: 50;  -*-
[0:

Sun Oct 15 08:48:55 2023 OK, starting this file,
202310150848-T2-SERCON-notes.txt, in
(T2-SERCON/)T2-12/base/notes, for work on the
SERIAL CONCENTRATOR portion of the T2 MATRIX BRAIN
CHALLENGE.

[1:

Sun Oct 15 08:54:04 2023 First point to notice is
that we expect that ultimately the BBG SERCON
board software will be incompatible with the T2
tile because (at the very least) of differing pin
assignments.

So we don't expect this to be a 'pure install'
whatever that might mean.

:1]

:0]
[2:

Sun Oct 15 09:06:28 2023 So okay; starting into
stuff. First up,

base/doc/T2-12-BBG-Pinout-225-10.pdf

where (we believe) we have the current pin
assignments for a T2 tile. All full of ITC pins
that we won't use for SERCON and some of which
will conflict with UART pins for sure..[3:

Sun Oct 15 09:10:51 2023 (Not sure where to find
the source for that PDF, though.. that's
aggravating.)

:3]


:2]
[4:

Sun Oct 15 16:05:22 2023

P9_24 UART1_TXD
P9_26 UART1_RXD

P9_21 UART2_TXD
P9_22 UART2_RXD

P9_11 UART4_RXD
P9_13 UART4_TXD

P8_37 UART5_TXD
P8_38 UART5_RXD

:4]
[5:

Sun Oct 15 23:14:31 2023 HEY WAIT A MINUTE.

What about doing daisy chain loops through
multiple tile UARTs? If we're really claiming low
speed is fine due to timelapse, what about:

(1) Packetize everything, and
(2) Include a hop count in every packet, and
(3) Link a bunch of tiles in a TX->RX loop, 
(4) With a single 'terminal' node in each loop

Could have the controller poll the loop in fact,
since it will be both upstream and downstream of
the loop. Inject a sequence 'HOP-n SPEAK NOW'
packets for cyclic n, and enumerate the loop
that way.

Can be 'full duplex' by making SPEAK NOW actually
be 'RECEIVE AND SEND NOW'.

GAH then we could even maybe have the western edge
T2 tiles be the 'terminals', routing traffic from
ethernet to the serial loop it controls. And then
- aside from some extra load on the west tiles -
we don't even need any more BeagleBones. Just a 10
or 16 port ethernet switch, or whatever.

Or we could add a few 'loose' T2 tiles anywhere
around the periphery, and have them be just the
loop terminals, and connect to ethernet, so the
main load is shifted off the matrix entirely.

And then we only need a single UTP pair to run
around the loop? And we could make a little PCB
that would plug into the T2 serial port and accept
the passing pair. GND for everybody, plus an
upstream RX that becomes the downstream TX.

We could also have the loop provide an FTDI style
header so we could go straight to USB and byass
ethernet as well. If we trust say even a
half-dozen FTDI cables to coexist through a USB
hub.
[6:

Mon Oct 16 01:43:46 2023 Apparently the BBG
default baud rate is 115,200. So we imagine that's
about 10KB/s. If we said like 250 byte packet max,
and one packet per tile per poll, that's 4 packets
per KB so 40 packets per 10KB so we could in
principle update 40 tiles per second with a single
loop. Two loops could cover the whole existing
matrix.

We might be able to standardize the wire length
between the tiles - with some slack built in - and
then just daisy-chain a single pair soldered down
onto an incredibly simple PCB.

Or even, I suppose, crimped directly into 6
position 0.1" female headers.

[7:

Mon Oct 16 01:55:59 2023 FTDI USB-serial cable
pinout is:

  PIN 1 GND (black)
  PIN 2 CTS (brown)
  PIN 3 VCC (red)
  PIN 4 TXD (orange)
  PIN 5 RXD (yellow)
  PIN 6 RTS (green)

and with our single pair (say blue and white)
we'd do

 WHITE to PIN 1
 BLUE UPSTREAM to PIN 5
 BLUE DOWNSTREAM to PIN 4

and that's freaking it.

[8:

Mon Oct 16 02:10:56 2023 And if we wanted to go
with two pairs we could have a return line so it
didn't actually have to loop.

We could also just have a little jumper so if we
needed more cable on a particular hop we could
jumper PIN 5 to PIN 4 and then leave that PCB
unplugged-in.

:8]

:7]

:6]
:5]
[9:

Tue Oct 17 01:46:14 2023 (From 202310150204-fresh,
also now in sched11:TODO10

TODO:
 - Test circuit with 2 tiles + FTDI
[85: Sat Oct 28 11:30:01 2023
DONE  :85] - Find out how to take over /dev/ttyO0 from getty
[86:
DONE :86] - Get some right angle 6-pos 0.1" sockets
[87:
DONE :87] - Make three drops out of perfboard
[88:
DONE :88] - wire up
[99: Thu Jan  4 12:09:09 2024
DONE :99] - connect two to tiles and one to ftdi
 - write router script for tiles
 - write controller script for laptop
[89:
DONE :89] - demo packet communication


:9]
[10:

Tue Oct 17 01:47:21 2023 So we see this:

    I found the answer here;
    http://stackoverflow.com/questions/21596384/cannot-disable-systemd-serial-getty-service

    My port is at ttyO0. so in my case I entered
    "systemctl mask serial-getty@ttyO0.service"

    I was able to confirm the device name by
    typing “systemctl --full”. My device was in
    the list.

    Once I typed the command above and rebooted, I
    could use the serial port in my program.


:10]
[11:

Tue Oct 17 09:05:16 2023 But there's that whole
business with 'somebody' renaming /dev/ttyO0 to
/dev/ttyS0 during boot so now I'm trying both

    systemctl mask serial-getty@ttyO0.service
    systemctl mask serial-getty@ttyS0.service

..rebooting..

[12:

Tue Oct 17 09:40:32 2023 OK so that kinda seems to
work. I guess maybe could start an actual little
script? 

Can we claim any to-dos in sched11 first?
[13:

Tue Oct 17 09:52:51 2023 Well took a couple, and
reorged the sheet a bit. There's a lot that we
don't think we're going to do now; have to ditch
them at some point.[14:

Tue Oct 17 09:54:09 2023 Making
T2-12/base/apps/sercon/spike10.pl
[15:

Tue Oct 17 10:19:18 2023 Geez. Trying python.
Perl's Device::Serial seems an awful mess.

# apt install python-serial

[16:

Tue Oct 17 10:27:52 2023 aaand a first serial
non-blocking read / write demo in python is now
working. Bad show perl; I'm sad.

(In python 2.7.16.. to be exact. [17:

Tue Oct 17 10:36:02 2023 OK now with

    # apt install python3-serial

we're in python 3.7.3 and that'll have to do. Say
I.

[18:

Tue Oct 17 10:36:57 2023 OK. So how are we going
to delimit our packets this time?

(1) \n delimited and escape \n and escape
(2) null delimited and escape null and escape
(3) p255 counted with no escaping

[19:

Tue Oct 17 10:48:58 2023 Just as a reminder, the
ITC packet protocol uses 0x7e == 0b01111110 as the
packet delimiter and bit-stuffs a 0 after a 5th
consecutive 1 bit otherwise. 

There is no length encoded on the wire, but
packets are limited to 255 bytes and are mostly
queued and transferred in p255 format internally.

The ITC protocol self-synchronizes to byte
boundaries, but the UARTs will do that for us so
we don't need that here.

[20:

Tue Oct 17 10:56:35 2023 Suppose we go with option
(1) as simple and ample? (Plus p255.)

What do we use for escape? NUL? Actual ESC (033)?

Let's go with ESC for now.

So. Packet reading and writing in python?

Now, let's think about this just a minute. We're
ultimately going to need the content of these
packets to affect mfmt2 processing. How are we
going to do that? Via the filesystem? Pipe? Shmem?

Or do we want to byte (hoho) the bullet and switch
to C/C++ now?

[21:

Tue Oct 17 13:07:10 2023 Well, now I'm thinking
about making a little RAM disk for python and
mfmt2 to communicate through. I looked at unix
pipes but I don't really want to screw around with
streams and draining pipes and so on. For this
application I just want python to be able to
update 'sensor' readings asynchronously, and mfmt2
be able to update 'motor' commands asynchronously,
and each just takes the latest available at the
time they want them.
[22:

Tue Oct 17 15:33:43 2023 I really like that idea.
Fuck shared memory, use a ramdisk.[23:

Tue Oct 17 15:37:04 2023 Or, hmm, maybe 'ramfs' -
which is not the same thing - is better.[24:

Tue Oct 17 15:38:53 2023 And, hmm, maybe 'tmpfs'
is better still.. So how do we create [25:

Tue Oct 17 15:42:06 2023 Hmm, it's just

    $ mkdir /dev/shm/MYTMPFS
    $ echo foo >/dev/shm/MYTMPFS/file.txt
    $ ls -al /dev/shm/MYTMPFS
    total 4
    drwxrwxr-x 2 ackley ackley 60 Oct 17 15:43 .
    drwxrwxrwt 3 root   root   60 Oct 17 15:42 ..
    -rw-rw-r-- 1 ackley ackley  4 Oct 17 15:43 file.txt
    $

But how do we impose a size limit on that? I
thought the advantage of tmpfs was it supported
like a quota somehow?
[26:

Tue Oct 17 16:06:48 2023 Well, if we make our own
tmpfs we can enforce a quota, anyway. This works:

    # mkdir /mnt/T2TMP
    # mount -t tmpfs -o size=1M tmpfs /mnt/T2TMP/
    # yes >/mnt/T2TMP/yes.dat
    yes: standard output: No space left on device
    # df /mnt/T2TMP/
    Filesystem     1K-blocks  Used Available Use% Mounted on
    tmpfs               1024  1024         0 100% /mnt/T2TMP
    # rm /mnt/T2TMP/yes.dat 
    # df /mnt/T2TMP/
    Filesystem     1K-blocks  Used Available Use% Mounted on
    tmpfs               1024     0      1024   0% /mnt/T2TMP
    # 
[27:

Tue Oct 17 16:31:09 2023 And sticking

    none /mnt/T2TMP tmpfs size=1M,mode=1777 0 0

at the end of /etc/fstab seemed to work fine
across a reboot. But I guess somebody has to 

    # mkdir /mnt/T2TMP

once first..

[28:

Tue Oct 17 16:35:39 2023 So, anyway: I really like
this! We should move /cdm/log/status.txt there,
for one thing.

And if we had, sey

  /mnt/T2TMP/SERCON/sense.dat  # inbound sense data

that was written just by say python, and

  /mnt/T2TMP/SERCON/motor.dat  # outbound motor commands
  
that was written just by mfmt2, then all that
should happen lickety-split and without touching
eMMC except in the dire situation of swapping.

And we could write sense.new and then rename it
onto sense.dat, to ensure mfmt2 will never read
half-old half-new data?[29:

Wed Oct 18 10:04:28 2023 Actually I wonder if we
could just do that much, as a helpful step for
later and now, and actually push it to production?
[30:

Wed Oct 18 11:32:46 2023 TODO
[35: Thu Oct 19 08:58:07 2023 in base/files/etc
DONE :35] - Figure out where to set up /etc/fstab in cdm
[36: Thu Oct 19 13:23:53 2023 cdmss-05 -> /etc/fstab, so
DONE :36] - Create /mnt/T2TMP on boot if needed
[37: Thu Oct 19 13:25:18 2023 /mnt/T2TMP/cdmStatus.txt
DONE :37] - Move /cdm/log/status.txt to like
           /mnt/T2TMP/cdm/log/status.txt
[38:
DONE :38] - Test it
[39:
DONE :39] - Make cdmds
[40:
DONE :40] - Deploy
[41: Thu Oct 19 13:31:02 2023
DONE :41] - Commit

[31:

Wed Oct 18 11:46:31 2023 OK it appears that
systemd is supposed to create missing mount points
at boot, for stuff that's in /etc/fstab. I wonder
what the owner and permissions are?[32:

Wed Oct 18 11:55:54 2023 Looks like

(1) That works, and
(2) It's owned by root, and
(3) It has the permissions specified in
    /etc/fstab..


:32]

:31]
:30]
:29]


:28]

:27]


:26]
:25]

:24]

:23]

:22]
:21]

:20]

:19]

:18]

:17]

:16]

:15]

:14]

:13]

:12]

:11]
[33:

Thu Oct 19 07:46:57 2023 Evaluating header samples
I got in from Mouser:

SERLOOP J1 T FA (CES10602TSRA) ->
 Pretty short sockets
 But tight

SERLOOP J1 F RA (SSW10602FSRA) ->
 Longer sockets, seem plausible
 Gold flash on contact
 Tin tails
 Maybe

SERLOOP J1 G RA (SSW10602GSRA) ->
 Same plausible socket length
 Square tails
 Gold 0.51um on contact
 Gold flash on tail
 $$

[34:

Thu Oct 19 08:27:30 2023 So I think if we can find
a way to cut this bakelite at all cleanly, and
find or make a couple pieces of UTP to string up,
we could make like a three tab loop connecting two
tiles and an FTDI.

[42:

Thu Oct 19 13:50:47 2023 So, scoring and snapping
the bakelite works pretty well, so I now have
several pieces of a vaguely suitable size. What do
we do for UTP around here?

[43:

Thu Oct 19 14:15:28 2023 OK, cutting into an old
Cat5e cable. 24AWG; got to be vast overkill for my
purposes.. [44:

Thu Oct 19 14:17:48 2023 The blue/white pair seems
to have the tightest twist.

[45:

Thu Oct 19 14:21:38 2023 Aand how much length do
we want between tabs?
[46:

Thu Oct 19 14:30:39 2023 So like 4.5" would be
about the minimum for horizontal tile-to-tile, and
about the same for a NE<->SW diagonal shot.

Except: Both those horizontal and diago shots
would obscure the screen.

I think we'd be talking more like 8" for a safe
horizontal shot, considering termination and
routing costs.[47:

Thu Oct 19 15:16:08 2023 OK let's say 8". And what
exactly is our schematic here?

UG - upstream ground (WHITE)
US - upstream signal (COLOR)
DG - downstream ground (WHITE)
DS - downstream signal (COLOR)

J1

PIN1  GND
PIN2  NC
PIN3  NC
PIN4  TX
PIN5  RX
PIN6  NC

NETS

UG - PIN1 - DG
US - PIN5
DS - PIN4

and that's it, right?

[48:

Thu Oct 19 15:55:17 2023 And PIN1 is on the bottom
pin of the T2 tile serial port.

:48]

:47]

:46]

:45]

:44]

:43]
:42]

:34]
:33]
[49:

Fri Oct 20 12:25:07 2023 OK so how do we get going
here? Need more

TODO
[90: Sat Oct 28 11:27:43 2023 Long ago, but notes file reverted :(
 :90] - Document status
 - Make spike that handles two packets like S, M
[91: Sat Oct 28 11:29:14 2023
DONE :91] - Make a second serial loop tab
[94: Thu Jan  4 12:07:36 2024
DONE :94] - Make a serial controller tab
[95:
DONE :95] - Make a controller spike that enumerates the
   loop using S&M packets
[96:
DONE :96] - Demo two tile + controller
[97: Thu Jan  4 12:07:56 2024 
DONE :97] - Commit
 - Make more to-do

:49]
[50:

Fri Oct 20 12:32:31 2023 Current status:

 - Have /mnt/T2TMP tmps and loving it
 - Have one 'serial loop tab', untested.
 - Noting for the record: We installed
   python3-serial and that will need to get to all
   the tiles somehow. Probably need to figure out
   how to do a local installation maybe?
 - We have 'spike11.py' on the 'naked BBG' and
   currently nowhere else

:50]
[69: (Sun Dec 17 10:31:05 2023 There's a bunch of
notes in a different copy of this files that got
lost starting here. Sticking them all into the
next entry (:70:), while deleting their original 
numbering..) :69] 
[70:

Sat Oct 28 01:21:50 2023

p'ing'

p + 0xff

our received
cpu + ram
architecture
is a symphony
of premature
optimisation
and the
consequences of
not dealing with
that all too common
bug

the computational universe

'-' + TTL

tile configuration files
 expected loopsize
 represented as list
 of unified coordinates

packet to send
assigned coordinate
 and perhaps some
 kind of type
to a tile

Sat Oct 28 11:27:04 2023 OK, so now we're adding
and checking a two-byte checksum based on
binascii.crc_hqx.

Sat Oct 28 11:47:07 2023 So OK. Claimed some
to-dos. Let's load a tomli(key) file on the world
side and see about sending configurations.

Or just structured lines?

LOOPPOS XPOS YPOS RESERVEDIGNORED..

Let's try that. Thinking of including the LOOPPOS
rather than enumerating the lines; we'll see.

Sun Oct 29 00:22:41 2023 Let's think a bit about
the ways we're going to use space in this thing.
In particular, we think there's going to be
separate 'brain space' and 'body space', with a
mapping between them - that we want to represent,
at least in part, by this configuration file.

Do tiles really need to 'know where they are'?
Beyond whatever information we call 'the senses'?

Let's riff about how this might really all go.
Braitenberg on up.

Mon Oct 30 02:14:11 2023 Notes from yesterday:

    PROMPT: BRAIN-BODY INTERFACES

     - brightness signals as atoms
       carried from sim to sensory tile base layer
     - desired motor signals as atoms
       carried from motor tile base layer to sim

     - programmable matrix transforms and connects
       signals to motors

     - router gradients/clouds float

     - what if it was event counts rather
       than distance that got propagated?
       = then the decision about how to
         update is the focus.

     -> and event count isn't a time
        proxy anyway.

    several overlay networks intertwined
    various reductions offered while routing
    add/sub/max/min
    max/min/sample incr/decr/copy

      nw  ne
        ct
      sw  se


    when something goes wrong
    what happens
    what does it look like


    self-evidencing
    also data
    running the code

Mon Oct 30 02:19:03 2023 and the main takeaway
from that is the idea that we'll spread the
'Braitenberg API' out in space, and put a
programmable router between the components.

So rather than 'decide what to do then do it', it
will be more like 'decide what to do, then program
the lower-level (e.g., closer, better-connected,
more central) hardware to do it, then let that
programmed machine do its thing.

                   cont
                   roll
                   er

                nw     ne
        cont       rou       cont
        roll       ter       roll
        er      sw     se    er

                 here be
                 dragons

Mon Oct 30 09:36:32 2023 We want to be aware of

(1) Inhibition as well as excitation
(2) Which may be canceling or non-canceling in the
    fabric (?)

Mon Oct 30 11:02:37 2023 So how might we go?

Mon Oct 30 11:12:39 2023 I see
https://github.com/ankiitgupta7/Simulations-of-Braitenberg-Vehicles
has apparently a Processing-based simulator. That
might be a good start.

Mon Oct 30 14:10:39 2023 Well, after running into
this:

    java.lang.UnsatisfiedLinkError: Can't load library: /data/ackley/PART4/code/processing-4.3/natives/linux-amd64/libgluegen_rt.so
            at java.base/java.lang.ClassLoader.loadLibrary(ClassLoader.java:2398)
            at java.base/java.lang.Runtime.load0(Runtime.java:755)

despite the existence of this

    /data/ackley/PART4/code/processing-4.3/core/library/linux-amd64/libgluegen_rt.so

plus the non-existence of this

    /data/ackley/PART4/code/processing-4.3/natives

makes me think maybe I don't want to be screwing
around with processing, let alone java, let alone
python somehow laid on top of processing on top of
java, to be using that repo code directly.

If I'm going to go that low-level - e.g.,
implementating all the physics myself - I might as
well start with some cleaner base.

Could I conceivably want to deliver via WASM? So
other 'agents' could use the framework? But still
that's low-level

Mon Oct 30 16:15:38 2023 Well I cloned and built
'box2d' and ran ./build/bin/testbed successfully.

Sun Nov  5 00:30:48 2023 Well, have now also
explored - to varying degrees - blender, pybullet,
and mujoco. So far mujoco has the inside
track. I've modified the included car.xml demo to
add a light that casts shadows, and demonstrated a
touch sensor, but have not as yet figured out how
to do a light sensor successfully. A challenge is
much documentation is for mujoco-py, which is now
apparently not being maintained, and the official
replacement python package 'mujoco', is
lower-level and has fewer tutorials and so forth.

But that's going to have to be it for the T2 brain
challenge for a while. It's November and time to
produce the collected works of Vaughn Joy Mannon.

[71: (Sun Dec 17 10:34:21 2023 End of inserted
  stuff) :71]
  :70]
[51:

Tue Dec 12 01:00:22 2023 OK I guess we're back,
here. I'm wondering if we should get these notes
and such pushed off the keymaster somewhere just
on general safety grounds, before developing too
much further.[52:

Tue Dec 12 01:05:00 2023 OK, pushed.

:52]

:51]
[53:

Tue Dec 12 01:05:13 2023

TODO

[55: Fri Dec 15 09:12:43 2023
DONE :55] - review ../base/apps/sercon stuff
[65: Sun Dec 17 01:44:52 2023
DONE :65] - brainstorm on packet designs
[66: DONE  :66] - identify something close to minimal minimal
 - make to-do leading to packet demo

[54:

Tue Dec 12 12:18:57 2023 And let's put a foggen
clock on this: PACKET DEMO RUNNING ACROSS AT LEAST
TWO TILES BY FRIDAY DEC 15.

:54]

:53]
[56:

Fri Dec 15 09:12:51 2023 So, current status
includes:

 - base/apps/sercon committed and pushed on branch
   SERCON
 - sercon/worldserloop.py runs on workstation
 - sercon/t2serloop.py runs on keymaster
 - they exchange packets
 - the packets are currently content-free

[57:

Fri Dec 15 09:29:15 2023 So I guess we're super
overdue to brainstorm packet designs.

BRAAAAINSTOOOOORMM PACKET DESIGNS

 - first byte always 'relative loop hops'
 - treat as signed byte?
   = 0x00 -> you are the recipient of this command (no hops)
   = 0x01..0x3f -> recipient of command is this many hops downstream
     1..127
   = 0x10..0xfe -> reply has returned -this many hops
     -1..-127
   = ==0xff -> all tiles are recipient of this command

 - or maybe like +-1..125 for few more special codes
   = -126 -> return underflow, discard
   = +126 -> broadcast
   = +127 -> reserved, discard
   = -127 -> reserved, discard
   = -128 -> reserved, discard

[58:

Fri Dec 15 10:02:13 2023 Well suppose we believe
the '125' format for now.

[59:

Fri Dec 15 10:14:10 2023 How about some little
specific spikies to go for?

Actually, let's saber first.

:59]

:58]
:57]
:56]
[60:

Fri Dec 15 15:24:47 2023 Tasks for the loop:

 - Count the loop (not counting host)
   METHOD:
   1. host sends Ho=-1 packet with random data
   2. wait for matching random data return with Hi
   3. loop length is -Hi-1 or None if timeout

 - 'Synchronous' loop update
   METHOD:
   1. Buffer sensory data from world for all tiles
      on the current world tick
   2. Send out sensory data for each tile in 'downstream
      first' order: Ho==LEN-1, LEN-2, .., 0
   3. Tiles accept delivery of sense data and
      replace it with motor data
   4. Buffer motor data from all tiles as it
      arrives    
   5. Deliver all motor data to world on the
      current world tick
   6. Tick the world
   7. Sleep until time to do it again.

[61:

Fri Dec 15 16:48:19 2023 spikeHost:

1. Count the loop
2. Do 'synchronous loop update'
3. Bomb out on any problem

and wrap that in a spikeHostRunner.

And what do we do for a spike 'world'?

???

:61]

:60]
[62:

Sat Dec 16 09:07:56 2023 OK, so trying to get
worldserloop.py to do its two 'loop tasks'.
Wondering how we want to do state machine-ish
stuff and timeout stuff in this context.

I guess minimal minimal says just brute force it
for the next spike. Which I guess means just
straight line blocking code and we'll see what we
see. 

:62]
[63:

Sat Dec 16 23:50:55 2023 OK, so worldserloop.py
successfully counted the loop and got 1:

    root@lcf5820://data/ackley/PART4/code/D/T2-12/base/apps/sercon# ./worldserloop.py spikeconfig11.dat 
    3 CONFIG
     (0, '1', '2', ['more stuff bing bang'])
     (1, '2', '3', ['# bong'])
     (2, '33', '8', [])
    ACCBYTFOUND bytearray(b'\xfeCOUNT')
>>  LOOP LENGTH IS 1
    SENDDDD
    ACCBYTFOUND bytearray(b',\xff')
    WHANDLED bytearray(b',\xff')


[64:

Sun Dec 17 01:03:31 2023 But to go beyond that I'm
really feeling the pressure of needing a
functional world to ground this code.

How close are we to what we wanted for this past
Friday? 
[67:

Sun Dec 17 01:45:11 2023 OK we were supposed to
have a demo running on two tiles but at the moment
it's only on one tile plus the host. I'm actually
okay with leaving it that way for now, because the
main bits of getting onto two tiles are cdm stuff
and getting the t2serlooprunner installed and
started on boot.

:67]
:64]

:63]
[68:

Sun Dec 17 10:06:54 2023 Well, I feel like we have
to subgoal to fish or cut bait on mujoco. I'm
feeling anxious about python version hell, though,
and wondering if I should try to do this
exploration in a VM. Like perhaps in the ubuntu
22.04 VM I already have running for latex..

Let's try to find whatever notes we had from the
first attempt..

:68]
[72:

Sun Dec 17 16:21:25 2023 OK resurrected some notes
(into this file, :70: above) that had gotten lost
in version skews. There's more mujuco mentions,
but nothing terribly specific.[73:

Sun Dec 17 16:35:02 2023 Let's try taking a fresh
start at mujuco in a VM and see where we choke.

:73]

:72]
[74:

Mon Dec 18 04:59:34 2023

GAH FOGGEN VM NOTES:

 - 'minimal installation' takes longer than
   'normal'
 - give maybe 2-4GB RAM
 - give maybe 50GM disk (10GB not enough)
 - give maybe two cores (on Settings -> System -> Processor)
 - Settings -> Power -> Screen Blank -> never
# apt install virtualbox-guest-additions-iso virtualbox-guest-utils virtualbox-dkms
# apt install virtualbox-ext-pack
# apt install emacs-nox openssh-server
# poweroff
 - VB -> [machine] -> Settings
    -> System
       -> Processor(2) -> 2
          Enable PAE/NX
          Enable Nested VT-x/AMD-V
    -> Display
       -> Video memory 64 MB
       -> Graphics controller: VMSVGA
       -> Enable 3D acceleration
    -> Network -> Adapter 1 -> Enable network adapter
       -> Port Forwarding
          -> Name: SSH, proto: TCP, host port 2214 (etc), guest port 22
    -> Shared Folders
       -> Add
          -> Name, Path, Auto Mount, At

:74]
[75:

Mon Dec 18 13:42:17 2023 OK, finally thinking VM
UB2204Mujoco14 is working enough to try to
proceed. GAAAAAAH I hate VMs.

:75]
[76:

Mon Dec 18 13:56:33 2023 OK, trying to follow

https://colab.research.google.com/github/deepmind/mujoco/blob/main/python/tutorial.ipynb

even though I don't have or understand 'Colab'
[77:

Mon Dec 18 13:58:19 2023 No I'm not. Second step
involves python code including
'from google.colab import files'

Need to find another way.

:77]


:76]
[78:

Mon Dec 18 14:02:56 2023 Well, trying
https://pypi.org/project/mujoco/
even though pretty quickly it points at the google
colab thing.[79:

Mon Dec 18 14:08:09 2023

    ackley@ubmujoco14:~/PART4$ pip install mujoco
    Defaulting to user installation because normal site-packages is not writeable
    Collecting mujoco
      Downloading mujoco-3.1.0-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (5.4 MB)
         ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 5.4/5.4 MB 5.1 MB/s eta 0:00:00

    Collecting glfw
      Downloading glfw-2.6.4-py2.py27.py3.py30.py31.py32.py33.py34.py35.py36.py37.py38-none-manylinux2014_x86_64.w\
    hl (211 kB)
         ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 211.8/211.8 KB 1.6 MB/s eta 0:00:00
 ..

    Collecting typing_extensions
      Downloading typing_extensions-4.9.0-py3-none-any.whl (32 kB)
    Installing collected packages: pyopengl, glfw, typing_extensions, numpy, importlib_resources, fsspec, etils, a\
    bsl-py, mujoco
      WARNING: The script f2py is installed in '/home/ackley/.local/bin' which is not on PATH.
      Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-loca\
    tion.
    Successfully installed absl-py-2.0.0 etils-1.6.0 fsspec-2023.12.2 glfw-2.6.4 importlib_resources-6.1.1 mujoco-\
    3.1.0 numpy-1.26.2 pyopengl-3.1.7 typing_extensions-4.9.0
    ackley@ubmujoco14:~/PART4$ 

[80:

Mon Dec 18 14:23:49 2023 OK, so, inside the VM display..




:80]
:79]

:78]
[81:

Tue Dec 19 13:08:15 2023 OK, so working towards
getting a second tile running t2serloop.py.
Current issue is second tile still had getty
running on tty0 and that fucked things up.

Trying a reboot on the second tile to see if that
fixes it ho ho so pro.

:81]
[82:

Tue Dec 19 13:12:29 2023 OK so it fixed it and now

    root@lcf5820://data/ackley/PART4/code/D/T2-12/base/apps/sercon# ./worldserloop.py spikeconfig11.dat 
    3 CONFIG
     (0, '1', '2', ['more stuff bing bang'])
     (1, '2', '3', ['# bong'])
     (2, '33', '8', [])
    ACCBYTFOUND bytearray(b'\xfdLOOPCOUNT/9dHvBNQJ')
>>  LOOP LENGTH IS 2
    SENDDDD
    ACCBYTFOUND bytearray(b'+\xff')
    WHANDLED bytearray(b'+\xff')
 ..

Wahoo.

:82]
[83:

Wed Dec 20 13:12:36 2023 OK, an order for 100
revised T2 SerLoop 13 tabs is now underway at
OSHPark. It'll be 2024 before they show up, I
expect; we'll see.

:83]
[84:

Thu Jan  4 09:08:19 2024 OK, merging more changes
from skewed versions of this file, using new note
numbers but anachronistically old dats, gah..
[92:

Thu Jan  4 09:11:52 2024 OK, end, I think of new
note numbers with old dates.

Ugh. What I get for initially pulling a separate
work repo for the sercon stuff, instead of just
branching as god intended.

:92]
:84]
[93:

Thu Jan  4 12:07:02 2024 So okay.[98:

Thu Jan  4 12:08:32 2024 Claimed some to-do. Are
we at making up more?
[100:

Thu Jan  4 12:09:57 2024 Looks like maybe.[101:

Thu Jan  4 12:45:00 2024 I really thought we
already had some text leading to serloop talking
to a sim.. but I can't find it?[102:

Thu Jan  4 12:58:41 2024 OK, I think I was
thinking about this note (24) from
/data/ackley/PART4/code/D/PyBulletTime/notes/202312251028-notes.txt:

    So if we imagine a simulated reaction time of
    perhaps 100ms through the T2 brain. That's pretty
    damn fast in human terms but let's say.

    Now, apparently bullet physics is based on 60fps
    or 16.6ms / step, so we'd be talking 6 steps per
    sensorimotor loop. Something like:

    WORLD
     forever
       wait til 0%5 seconds o'clock
       recv current forces from spine
       read current senses from sim
       send current senses to spine
       write current forces to sim
       for six times
         capture frame for 60fps movie
         step sim

    SPINE
     forever
       wait til 1%5 seconds o'clock
       recv senses from world
       send forces to world
       send senses to brainstem while
       recv forces from brainstem

    BRAINSTEM
     forever
       wait for spinal packet
       recv senses from packet
       read forces from brain
       send forces to brainstem
       write senses to brain

[103:

Thu Jan  4 13:16:12 2024 So can we turn that into
some items? Maybe do some minutes first.[104:

Thu Jan  4 14:47:39 2024 OK

TODO
[105: Fri Jan  5 10:43:02 2024 
DONE :105] - Checkpoint commit. Sub branch possibly
[150: Thu Jan 18 14:01:32 2024 I guess we did this
DONE :150] - Spike out World.py from scratch
[151: Thu Jan 18 14:01:57 2024 PacketSpine repo
DONE :151] - Spike out Spine.py from scratch
 - Settle on to-be-RAM-disk naming scheme
 - Draft some kind of representation (lines with
   space separated float?) for World<->Spine comm
 - Demo World and Spine communicating
 - Come make more to-do

:104]

:103]
:102]

:101]

:100]
:98]

:93]
[106:

Fri Jan  5 10:49:55 2024 OK trying to spike out
World.py from scratch. Do we do a state machine or
blocking threads or coroutines or what?

We'd like to be able to say things like "Go
reenumerate the loop" and

 - be able to time out if we don't get our
   response
 - be able to ignore packets not meant for us
   while allowing other states to consider them?

I'm imagining some kind of dispatch loop where
processes can post a regex of packets they're
waiting for, and inbound traffic is automatically
dished to the first matching receiver.

And we'd want to post a timeout too.. So, like..
an event queue? Which we kind of just recently
implemented for StreamDack.py ??

:106]
[107:

Sat Jan  6 16:07:07 2024 OK so we lifted the event
stuff from StreamDack and got it initted in
World.py. Now we're wondering how to unite this
stuff (here in T2-12/base) with the PyBulletTime
repo. Issues

 - T2-12 shouldn't know about PyBulletTime
 - t2serloop will likely want to know about the
   Event stuff
 - The PyBulletTime stuff will likely want to know
   about the Event stuff

All of which points at putting the event stuff in
its own separate repo and sucking that from both
T2-12 and PyBulletTime?

[108:

Sat Jan  6 16:33:47 2024 Well let's give it a try. 
[109:

Mon Jan  8 09:29:56 2024 So we now have a MrState
repo. A MrState is a base class for some kind of
wallclock-time-based engine based on a priority
queue.

And PyBulletTime/WorldRunner.py now inherits from
MrState and has Josh's SIMULATION as a data
member.

Let's try to get them stepping together, not just
sitting together..

:109]
:108]
:107]
[110:

Mon Jan  8 11:16:51 2024 OK, we have pybullet
plausibly stepping under the control of MrState.
Now we need to get serious about exchanging
sensorimotor data with the spine.

Kind of wondering why we couldn't just do that in
this codebase rather than thinking of another RAM
disk or whatever?

We tried to add ourselves to group 'dialout' so we
don't have to be root to get to /dev/ttyUSB0.. Why
not just do it all here?[111:

Mon Jan  8 12:51:25 2024 Well, because we were
saying we wanted to keep the spine in the T2-12
repo? But how about importing a module from there
say, or, again, splitting one out?

:111]

(We also want to go to scheduled, ongoing movie
generations, rather than waiting until the 'end'
of a simulation.)

:110]
[112:

Tue Jan  9 12:01:44 2024 OK come on come on we're
blocked on this 'stupid' code organization
question.. Let's try to split out the packet stuff
plus the tty stuff, and just leave the t2|world
Runner stuff in T2-12|PyBullet.
[113:

Tue Jan  9 15:07:44 2024 OK we have minimal viable
PacketSpine repo now and we're thinking about
redoing its config file format to be tomlikey
instead of space-delimited lines. For starters, we
want to move the serial device name into the
configfile. [114:

Wed Jan 10 12:01:23 2024 And what else goes in
that file? PacketSpine should maybe not have a
configfile at all, and just get told the device?
Seems like configuration should be a higher level
task.

Let's go that way. MrState already has Config.py
[115:

Wed Jan 10 12:17:24 2024 OK we tore configfile
notions out of PacketSpine.

But PacketSpine is going to want to know about
MrState, right?, so it can schedule events at its
level? Like perhaps to reenumerate the loop every
so often?[116:

Wed Jan 10 14:26:46 2024 So how often are we going
to poll the serdev? Does python serial have any
option for interrupts or select?[117:

Wed Jan 10 14:42:07 2024 Well, it appears to have
some kind of usable select, but I think I'm not
going to use it, for now. We'll just go ahead and
schedule the PacketSpine for frequent updates,
like 10Hz or something, and see how it all plays
out.. [118:

Wed Jan 10 15:05:32 2024 So okay. Now we have
WorldRunner.py that runs a pybullet simulation at
0.2 Hz while polling for packets at 10Hz. We need
to get PacketSpine having some kind of mechanisms
for dispatching on packet types, or regexes, or
something.

And our first use case is enumerating the loop.
And our second use case is sensorimotor update.
And all of that packet traffic is, I think, meant
to be arbitrarily interleavable.

So let's imagine regexes to dispatch.
At the moment enumerate is just a single packet
containing a count, b'LOOPCOUNT/', and a 8 byte
nonce. So if we had a 'PacketProcess' abstraction
that EnumerateLoop would inherit from, it could
catch that packet (or whatever we change it to)
and check the nonce afterward.

For the sensorimotor update, we'll send like
b'SENSE/' and whatever data we have for the
destination, and expect back a b'MOTOR/' from each
destination. Maybe we could send a final b'DONE'
afterwards? (Which could reenumerate the loop if
we wanted..)

Or maybe we enumerate the loop at the beginning of
each SM transaction? Chicken and egg I guess.

And we have no clue what we're going to do about
timeouts and error handling generally.

If we redundantly encoded the destination in each
packet, we could enumerate the loop as part of
every SM exchange. Hmm.

So an SM transaction could be like:
 - based on the current loop enumeration,
   send an S packet to each tile, starting with
   the highest index (==farthest from host)
 - handle incoming M packets from each tile,
   applying M data wherever it's supposed to go
   based on the tile returning it.
 - if we get an S packet coming back it means the
   loop count is too high

[119:

Wed Jan 10 16:59:23 2024 Maybe we could just keep
growing the count until an S comes back, and then
keep it there to confirm loop count each SM
transaction. We start out thinking the loop is
empty, so we send one S packet.

Then there's no separate enumeration step at all.
If we get two or more S packets back, the loop
count has shrunk.
[120:

Wed Jan 10 23:20:14 2024 OK come on let's take a
crack at this. Let's make one of those
'PacketProcess' things to provide a location for
this. In PyBullet/ itself, now, I'd think.
[121:

Wed Jan 10 23:21:42 2024 But where does the packet
dispatcher go? PacketSpine, you'd kind of think..
We want to register callbacks into PacketSpine?
[122:

Wed Jan 10 23:23:13 2024 OK, SerLoop.py:36 in,
update(), is where we're 'handling' packets,
currently meaning:

            print("WHANDLED",inpacket)

So we'll make a PacketProcessor abstraction in
PacketSpine

[123:

Wed Jan 10 23:56:00 2024 OK so SerLoop now has a
self.dispatcher that's a PacketDispatcher, and it
dishes incoming packets to it. At the moment we
have no processors though..[124:

Thu Jan 11 13:03:31 2024 OK now we have a
WorldPacketProc getting dispatched to in
WorldRunner.py. 

:124]

:123]

:122]
:121]
:120]
:119]

:118]

:117]

:116]

:115]
:114]

:113]

:112]
[125:

Fri Jan 12 03:29:28 2024 Next up is the combined
sensory/motor/enumeration packet, which will
require a functioning state machine in the
WorldPacketProc object, I'd think..[126:

Fri Jan 12 08:26:10 2024 OK come on. Packet
design.

 <hops>W<dest><nonce>[S<data>|M<data>]

maybe?
 - 'W'orld packet
 - redundant dest a la :118: above
 - one byte random init spinner nonce
 - four byte 'W' header overall
 - 'S'ense and 'M'otor payloads

or maybe 'WP' or whatever if hanging the whole
type off one byte feels too thin.
 
[127:

Fri Jan 12 15:16:58 2024 OK after each simulation
step, so we're sending around a(n empty) W/S packet,
and it's getting forwarded and 'handled' by my
two-t2 tile loop, returning a(n empty) W/M packet
back.

We're getting awfully close to needing a data
format for sensorimotor stuff..

About the only way I can think of to delay it now
is to get a whole train of W packets shipping, one
for each tile we believe exists. And then to
perhaps update our notion of how many tiles we
believe exist based on responses.
[128:

Sat Jan 13 02:40:24 2024 OK we're at the old same
thing: How do we want to integrate time-based
events with handling input packets?
[129:

Sat Jan 13 13:54:36 2024 Let's just try to do most
stuff while handling packets, and see how it
shakes out. We're currently polling on the EQ to
do that, so we don't have to worry about literal
races between an event running and packet handling
- the former are serialized, and the latter will
always happen during the former..

So right now we're starting an SM update - and
sending the first outbound packet - during
WorldEvents.SecondsStep.

Since we'll want to send a bunch of packets in
general, maybe we should just do a state change
there? And start sending the packets during
WorldEvents.PacketSpineStep maybe?

[130:

Sat Jan 13 14:01:21 2024 Right now
PacketSpineStep.run(..) is just handling input
packets. Would it be gross to also check for PS
state changes there?

[131:

Sat Jan 13 14:03:29 2024 As I think about this, we
could cowardishly avoid the sequencing on output
packets, and just buffer them all up atomically,
since that's what PacketIO.writePacket(..) does
anyway. Then they'll ship automatically during 

PacketSpineStep.run(..) ->
 PacketSpine.update() ->
  SerLoop.update() ->
   PacketIO.update() ->
    PacketIO.updateWrite()

with the existing code.

Let's try that urgh.

[132:

Sun Jan 14 02:19:44 2024 OK we did that, and we
got it to automatically grow the loop based on
return packets. It never shrinks the loop yet, but
that "shouldn't" matter if things are stable.
buuut checking in now it appears to think the loop
is like 33 tiles or something.

Let's get that squared away..[133:

Sun Jan 14 02:33:22 2024 Not clear what's going
wrong, actually.. A lost S packet could do it, but
that should get rarer and rarer as the imagined
loop len grows beyond the actual loop size. A
giant time delay could do it too - something that
lets the host burn up all of five seconds without
seeing the S packet it is expecting..

(All this is because our various 'planned'
robustification remain unimplemented so far..)
[134:

Sun Jan 14 02:45:56 2024 Argh it's because the
regex won't match when the nonce value is b'\n'? I
bet that's what it is. Argh.[135:

Sun Jan 14 02:47:23 2024 I see there's a re.M
'multiline mode'? Will that save us?[136:

Sun Jan 14 03:19:19 2024 It didn't.. but it looks
like re.DOTALL ought to.. Running now.. [137:

Sun Jan 14 03:23:42 2024 Yeah looks like that did
it. Past nonce= 10 with no loop len increase.

:137]

:136]

:135]

:134]
:133]

:132]

:131]

:130]

:129]

:128]
:127]
:126]

:125]
[138:

Sun Jan 14 03:39:54 2024 So okay. Here we are: We
need new

TODO
 - Make up a sensorimotor data format
 - Extend t2serloop.py to route it via RAM disk
 - Make a new ulam library with native code to
   access and update the RAM disk data
   = Including deciding how we present it at the
     ulam level.
 - Make a test element of some kind that does
   something with the data.
 - Make the modifications performed by that test
   element somehow visible in the world

[139:

Sun Jan 14 03:44:25 2024 Hmm, some of those items
overlap with unclaimed stuff in :104: above, so be
it. But first, checkpoint commit, all around..

:139]
:138]
[140:

Mon Jan 15 02:30:00 2024

SENSORIMOTOR FORMAT

 compact key + value format
 like maybe three byte key and one byte value?
 one and one would be obvious.
 is ~200 signals enough for the experiments we
 want?
 two and two would be obvious. but it's hard to
 imagine really needing 16 bits of value.

I want to do 3+1. Room to even do 3D indexing for
keys if we wanted.

So okay. We'll need a config file that defines
these tags into a dict presumably. Then SIMULATION
will push and pull values from that dict, and
SPINE will push and pull values from that dict as
well.

We'd like to be loading that config file on the
tiles too, I'd think.

Maybe we('ll) even want a little directory of
config files and some kind of 'world setup'
command that selects which config to use.

We could just include an appropriate file in the
physics, though, right?

But we could be imagining changing the world
and/or the sensorimotor interface without changing
the physics, also right?

But maybe we could just have a special K-V that
represents which world we're talking about, and
arrange to distribute that to all the brainstem
tiles somehow.

:140]
[141:

Wed Jan 17 01:32:54 2024 OK format for
sensorimotor.toml (and tiles.toml? separately?)

Have a combined name for sensors and motors? Since
they act pretty symmetrically modulo which end of
the spine?

Nodes? Terminals? Channels? IOs?

Could we even want to think of a bidirectional
such thing?? (snap out of it! minimal minimal)

[142:

Wed Jan 17 14:53:48 2024 Well I confess I'm not
too excited to head down the road of specific link
and joint names while we're still based on the
car/racecar.urdf file.[143:

Wed Jan 17 15:15:06 2024 Well, found some
tutorials for simple braitenbergish vehicles, and
suspect I might be able to glom onto some usable
code, so going into them for a bit.

Let's start the minute shooter in case we need
some such material..[144:

Wed Jan 17 15:16:55 2024 OK, it's running, I think..

:144]

:143]

:142]

:141]
[145:

Wed Jan 17 15:36:19 2024 So, gag, xacro is part of
the robot operating system 'ROS', which is
actually 'ROS2' now (I think) which is a giant
system of packages and ductwork that I really
don't want to get all into if I can possibly avoid
it. 
[146:

Wed Jan 17 15:52:36 2024 OK, tried to build xacro
from github source - without drinking a full ros
koolaid - but the dependencies just start
spreading.. cmake, okay. But then 'catkin'?

gag. gaaaaaaag.

[147:

Wed Jan 17 15:58:58 2024 Now I don't know which
way to go.

[148:

Wed Jan 17 16:07:35 2024 I don't think getting
xacro is worth installing ros. Josh did his own
generate.py stuff and we used that and it was
close to all we needed 'except' for foggen
cylinders.

Let's go back and try to make a 'generate
cylinder' pyrosim thing, using what little
additional bits of stuff we've learned along the
way..
[149:

Thu Jan 18 13:55:03 2024 OK, so everything takes
forever but we've got some progress:

 - Have a 'Braitenbergish' two-wheel differential
   drive 'vehicle' moving

 - Well, that's mostly it, really. We have that.

It's far enough along that I'm now, finally,
increasingly thinking about ulamish stuff and how
we might implement some 'Braitenberg connections'
in a coolish way.

Main thing now on the 3D side is we need the
'light sensors' that we hope to do with little
in-scene camera renderings and
histogram/reductions.

[167:

Sun Jan 28 02:15:44 2024 argh

[BEGIN VERSION SKEW INSERTIONS]
[:

Sun Jan 28 00:11:40 2024 Well we have that now too
- although I just randomly sample instead of
histogramming.

And now I want to send some actual signals around
the serloop. Even if the T2 doesn't do anything
with it yet.

But I had some thoughts over the last several
days, about how the interface to the matrix could
go. The idea is to make elements 'pull' the
signals from the underlying tile whenever they
want to.

The native code collects the signals that arrive
at the tile and just holds them in private state,
overwriting with newer signals as they arrive.

Ulam atoms can then use the native code to query
the tile in which they reside, to find out what SM
terminals are available, query S vals, and set M
vals. The native code might mark S vals as 'read'
and M vals as 'set' when an atom accesses them,
and clear those flags when a spinal SM transaction
happens, so atoms can 'consume' the input-output
capabilities if they want to, by respecting the
corresponding flags.

[:

Sun Jan 28 00:33:19 2024 So, one good thing about
this is the native code doesn't have to worry
about where or how to deliver sensory data. It
doesn't have to decide to send it to the middle of
the tile, or how to pick up motor commands from
the event layer, or any of that.

Ulam atoms just pull and push on the brain stem as
they want, from anywhere they want within the
given tile. This 'ought' to allow signal paths to
optimize themselves like straightening ant trails
as useful routings are established.

[:

Sun Jan 28 00:36:45 2024 For now I'm thinking that
the spine will still control which terminals are
assigned to which tiles, but down the road we
could think of extended protocol messages allowing
tiles to alter that configuration.

[:

Sun Jan 28 01:07:55 2024 So okay. We have actual
signals with numbers and stuff that we are using
right now in the python code. Could we literally
lift those variables into terminal names?
[:

Sun Jan 28 01:09:53 2024 So okay, we have a
tomlikey configuration file 'sm1.toml' that is
supposed to be relevant here. We're loading that
but we're not yet using it.

It has stuff in it like:

    [term.SRFL]
      type=sensor
      name='Right Front Light'
      tile=2

    [term.MRR]
      type=motor
      joint=base_to_rwheel
      name='Right Rear Motor'
      tile=1

and we'd like to make the hash produced by that
somehow be canonical for terminal definitions and
values.

Could we specify a .py file in the .toml, whose
job it is to do whatever sim-specific stuff is
needed to produce and consume terminal values?

[:

Sun Jan 28 01:15:14 2024 Now when I wrote sm1.toml
I didn't yet have the yellow sensors implemented;
now I do. But they're really just unstructured
python code - there's no official joint or link
that represents the sensors. There ought to be,
for visual legibility at least.. but even if there
was, it'll still be raw python creating the sensor
values.

[:

Sun Jan 28 01:24:47 2024 Right now we're computing
the 'yellow' values in simulation -> Step() ->
ComputeCarView(..), and storing them in
simulation.self.lastLeftYellow and .lastRightYellow

Then motor.py reads those values and 'conditions
them' to set the motor values.

So. TODO:
[174: Mon Jan 29 03:39:56 2024
DONE :174] - Have ComputeCarView calls stash results in the
   hash produced by (eg) sm1.toml. Like, in
    WorldRunner.Config.hash['term']['SLFL'].value
   or something along those lines.
 - Have WorldEvent.py -> SecondsStep -> run(..) ->
   PacketSpine -> initSM() do work like:
[170: Sun Jan 28 10:17:53 2024
DONE :170]    = determine from WR.Config.hash what SM
      terminals go to what tiles
    = populate the tile-bound I packets with the
      specified terminals ..in some format.
      maybe 4 bytes tag (eg 'SLFL', 'MRR ') and
      one byte value?[161: Sun Jan 28 01:57:06
      2024  Maybe just 1 byte sm index and 1 byte
      value. Come on. Maybe sort the SMs by name
[169: Sun Jan 28 03:34:48 2024 numbering from 0..
DONE :169]      and number them from say 1 that way. :161]
 - Have WorldEvents.py -> WorldPacketProc.handle(..) 
   process spine-bound O packets and set joint
   targets as specified using the joint names from
   the toml, like
   
    [term.MRR]
      type=motor
      joint=base_to_rwheel
      name='Right Rear Motor'
      tile=1
 - Hardcode the existing SM routing into
   T2-12/base/apps/sercon/t2serloop.py
 - See yellow ball joy happening via the
   keymaster.
 - Take big payoff for that.

:]

    [term.SRFL]
      type=sensor
      name='Right Front Light'
      tile=2

:] :] :] :] :] :]
[END VERSION SKEW INSERTIONS]

:167]
:149]

:148]

:147]

:146]
:145]
[152:

Thu Jan 18 14:02:27 2024 Well, better checkpoint
commit everything, I think.
[153:

Thu Jan 18 14:12:24 2024 Committed T2-12,
PyBulletTime, MrState, and PacketSpine.. That's
it, right? Sheesh.

:153]

:152]
[154:

Sat Jan 20 01:37:17 2024 OK, I just got nubiga set
up with a python venv to get all this going and
I'm wondering if we should think about that for
the t2s actually as well.[155:

Sat Jan 20 11:35:26 2024 So OK. Let's figure out a
way to get the tiles booting all the way up to
handling serial loop packets. Do we want to screw
with a systemd unit for that or can we drive
around that? How do cdm and mfmt2 get booted?[156:

Sat Jan 20 11:39:33 2024 Well, I see

T2-12/base/files/opt/cdm-run.service and
T2-12/base/files/opt/mfm-run.service

:156]

:155]

:154]
[157:

Sat Jan 20 16:31:22 2024 Well then: I just
rebooted the keymaster, and then saw essentially
the entire boot output get discarded by
WorldRunner.py on the host, and then, eventually
finally, the loop started operating again, once
the boot-time serloop-run.service kicked in.

Could be worse![158:

Sat Jan 20 17:23:29 2024 OK now, well now we're
seeing 

  LOOPLENGTH UPDATE: 0 -> 4

and that's kind of the length we were aiming for
as a first step. Long enough for each Braitenberg
signal to go do a different tile.

:158]

:157]
[159:

Sun Jan 21 00:13:35 2024 OK so now it really
really seems like it's time to connect sim to
spine and get real about wire formats and
spine<->brain formats, if they differ.

So we have sm1.toml getting loaded, and it's
(intended to be) defining names and tiles and
formats for sensorimotor interfaces.

I've been thinking in the back of my mind that
maybe we should just use indices of some sort to
identify signals on the wire, and expect the same
config file will be available on both ends to
interpret the indices.

But hmm them we need tomlikey on the tiles, which
we currently don't.. and we'd been hoping to
minimize custom python dependencies on the
tiles.. 
[160:

Sun Jan 21 00:52:03 2024 Well, tomlikey or not
tomlikey?

I guess one intermediate position would be to have
an outbound packet (or packets) to define the
key-value mapping. I'd also been thinking about
some kind of simulation id packet; that could
carry the KV stuff.

With the idea, I guess, that all those keys and
key info (e.g., S|M) will get passed to ulam via
the native interface somehow.

Hell why don't we implement something? We've got
/mnt/T2TMP available; let's stick something in
there.

[161:

Sun Jan 21 01:15:02 2024 I guess we really don't
want or need the brain interface serloop stuff to
be in ulam/stdlib though, right? We just need to
put it in the physics library. What say we get a
fucking physics library set up for the t2 matrix
brain challenge how about that now?
[162:

Sun Jan 21 01:18:35 2024 Are we really sure we can
include .cpp/.so or whatever in a physics file?
Maybe we should confirm that up front.
[163:

Sun Jan 21 01:44:36 2024 Well, we've initted
MatrixBrain10, and so far it appears that adding
_native.tcc files to an ulam physics is no
problem. Question is what does cdmd think of it?

Let's get our stub pushed to T2Demos and maybe see
what the keymaster thinks of it..[164:

Sun Jan 21 02:10:08 2024 Well now I'm wishing
MatrixBrain was a separate repo instead of under
T2Demos. Want to be able to clone it separately on
keymaster and so on. Let's move it before we go
farther. [165:

Sun Jan 21 02:24:05 2024 OK, created T2MatrixBrain
repo. Continuing notes (hopefully all or mostly)
there, in

    T2MatrixBrain/notes/202401210220-notes.txt

:165]

:164]

:163]
:162]
:161]

:160]
:159]
[166:

Sun Jan 28 02:12:02 2024 ARGH we have collisions
in this NOTES file again argh. Argh. So,
streamlining a bunch of notes from the other
version in here, with crippled notes numbers
again.

Argh. See :167: above

:166]
[168:

Sun Jan 28 02:34:13 2024 So okay. LET'S GOOOOOOO

First up: sort and index SMs..

:168]
[171:

Sun Jan 28 23:40:46 2024 OK, so we were a little
sidetracked by sim 20240127-042228, which ended up
performing a fun little story so we kept letting
it run longer.. but that's done and stashed in
T2sday/episodes/3147-20240206/sources/braiten now.

So where we are next is needing to map from (the
internal equivalent of)

    [term.SRFL]
      type=sensor
      name='Right Front Light'
      tile=2

to some code like

   self.EvaluateSensor(term)

somewhere. And in there, I guess, we'll just do
the moral equivalent of a switch on 'SRFL' and so
on..

Could we have ComputeCarView stash it in the
'right place'? At least for
nearly-everything-hardcoded now?

[172:

Sun Jan 28 23:58:28 2024 Couple items there:
 - We're already passing in 'viewl' and 'viewr'
   which are used for .png file names in the
   simdir. We were unhappy with the image
   directory layout so this would be an
   opportunity to fix that if we wanted:
   = Capture real dates in filenames
   = Put different image streams in different dirs?
   = Stash values in the config hash

[173:


Mon Jan 29 00:26:29 2024

data/SIMTAG/imgs/view/202401290027123.png
                /SRFL/202401290027123.png
                /SLFL/202401290027123.png

:173]


:172]

:171]
[175:

Mon Jan 29 10:25:28 2024 We are now very very
close to seeing a braitenberg type 2b vehicle
operating with the signal routing being performed
on the keymaster.

All that's left is to propagate the motor signals
which are now incoming to their working positions.
[176:

Mon Jan 29 10:51:51 2024 OK so right now
WorldRunner.IndexTerminals() stores in _tiles_ a
hash of tilenums -> [terminalindices].

But when we're processing a O packet at the spine,
we are given a tilenum and some terminalindices,
and we'd like to know (just for local sanity) if
that tile is entitled to talk about that terminal.
Which would normally mean we'd expect something
like stuff[tilenum]->{terminalindices:True} or
whatever.

Is anybody using _tiles_ ?[177:

Mon Jan 29 11:13:57 2024 Yes,
WorldRunner.GetPayloadForTile is iterating over
the appropriate terminindices, as one might have
expected were one to have had a clue. So
officially we'd want a list and a hash?
[178:

Mon Jan 29 11:36:58 2024 (Just used 'in list' fog
it.)

So now I think we're pushing the returned moto
values into the term hash. And we need to dig them
out of there in the motor stuff "and then we're
done".

:178]

:177]


:176]
:175]
[179:

Tue Jan 30 01:00:18 2024 Aaaaaand, we're "done".
Sim tag 20240129-164557 is the first good looking
run (with a 'full story') where code running on
the keymaster was doing all the signal routing.

So yay there.

[180:

Tue Jan 30 01:15:08 2024 Now I'd like to add state
to the keymaster so it could switch from type 2b
to type 2a (and back, presumably) under some kind
of circumstances.

Jeez what about if I had it switch when I pressed
the user button on the keymaster?

Let's make a few more terminals.. in sm1.toml,
say. [181:

Tue Jan 30 01:20:46 2024 Actually, can we bring
the T2 code up enough to parse the toml file and
figure out the signal indices on its own? Don't
want to be rehacking the hardcode that's doing 2b
at the moment.

[182:

Tue Jan 30 07:46:01 2024 Well I pushed tomlikey
into the base/files/misc zone and got it
importable on the KM, although I haven't actually
tried to parse anything with it yet.

Now I'm wondering if I c/should deliver the host
config file over the serloop, in one packet or
many, on demand or intermittently, or figure out
some other delivery method..

We could do a hash of the tomli file and
distribute that as a broadcast every few minutes
or whatever, and let any tiles with a miss request
a rebroadcast of the entire file.

Could we do it in a single packet? Is that too
gross? It'll eat memory and wire latency, but so
rarely..

[183:

Tue Jan 30 07:52:48 2024 Our debug tests still
show sending a 600+ byte packet...

Let's look at making a new packet (or two) for
config distribution..

[184:

Tue Jan 30 07:56:20 2024 We're using the 'W'
command for 'world I/O'.. Should we use something
else for config? 'C'? 'P'hysics? 'B'iology?
[185:

Tue Jan 30 09:02:09 2024 Let's just say 'C'. So a
packet might look like:

\x7eC[PAYLOAD]

with subtypes like:

\x7eCf[FULL CONFIG FILE]
\x7eCs[CONFIG FILE CHECKSUM]

or maybe we'd like to get some return info on
broadcasts as well
0   12          34..
\x7eC[BCHOPS:1b]f[FULL CONFIG FILE]
\x7eC[BCHOPS:1b]s[NEEDFULL:1b][CONFIG FILE CHECKSUM]

where we increment BCHOPS ('broadcast hops', which
is not packet hops) on forwarding, and increment
NEEDFULL if we have a checksum miss
[188:

Tue Jan 30 13:14:09 2024 Hmm should we put the
current nonce in there? Probably should but don't
want to push t2serloop.py again right now..

:188]
Since all broadcasts (at least so far) are going
to return to the host eventually..
[186:

Tue Jan 30 09:19:49 2024 Well, seems like
hashlib.sha256() is included out of the box? That
ought to be fiiiiine for our purposes..

..and the KM already has too. OK.

:186]

:185]
:184]

:183]

:182]

:181]

:180]

:179]
[187:

Tue Jan 30 10:36:15 2024 OK so theoretically
t2serloop.py can detect and handle Cf and Cs
packets a la :184: above.

Now we need to generate them.. maybe after
brunch.. 
[189:

Tue Jan 30 15:23:17 2024 OK, now we have the
keymaster successfully creating
/mnt/T2TMP/world.toml using broadcast data from
the loop, and successfully checking the checksum
and requesting the data when necessary.

But we need to get as far as indexing the
terminals from that file before t2serloop.py can
make any productive use of it.

How much will that take?[190:

Tue Jan 30 15:30:26 2024 OK at the moment
IndexTerminals() is in WorldRunner.py, which
t2serloop.py currently has no access to.

That WorldRunner code depends on
MrState.getRequiredSection(..), which t2serloop
also has no access to.

Now, the guts of IndexTerminals just needs the
'term' hash from the configfile, and it modifies
it in place. So we could push the mechanics lower
somewhere, so it wouldn't drag so much into t2
land? Where might that be?

This is something about robot bodies? That and t2
brains both, actually - it mentions joints and
tiles. So it's spinal stuff, since that's our
model for the link.

And a main job of the toml file is indeed defining
the stuff that flows through the spine. There's
other stuff in there at the moment - like a
MrState section that we're not really using hrm.

We have the PacketSpine package, which has 'spine'
right in the name.. [191:

Tue Jan 30 15:38:34 2024 There's a
getOptionalSection in the Config.py that we have
in base/apps/sercon.. [192:

Tue Jan 30 15:40:11 2024 And that Config.py has
fallen behind MrState/src/Config.py hrrm.

We could add a hook for MrState to call down to
from Config, and get to Spine.py:IndexTerminals()
or whatever that way, and then distribute just
MrState/Config.py and PyBulletTime/Spine.py for
t2serloop to use.

Still pretty gross; still working around not
having/wanting a python venv on the tiles..
[193:

Tue Jan 30 22:57:23 2024 Well, refreshed sercon's
Config.py against MrState's. Let's see if we can
get t2serloop to use it..
[194:

Wed Jan 31 02:06:14 2024 OK it looks like
t2serloop is using Config and Spine to get as far
as indexing terminals. We should be able to get
rid of the hardcoded stuff in the next go. Tired
now.[195:

Wed Jan 31 05:53:12 2024 So okay thinking instead
of just writing out the hardcoded routing we might
as well head for some kind of /mnt/T2TMP format to
use for IO between t2serloop and mfmt2 native
code. The latter initially represented by some
little spike, that does the disgusting hardcode
routing.
[196:

Wed Jan 31 06:05:51 2024 And we're imagining that
'disk' format will be like

(1) A file of like 1KB arranged as like 8 x 128,
    giving the up-to-8 byte term name for each of
    up-to-128 indicies.

(2) A file of 128 bytes giving the current values?

..no we want to separate S and M so we can avoid
write-write races on the same file.
[197:

Wed Jan 31 06:13:06 2024 So, maybe an
'indices.dat' file containing names and types and
indexes of the terms of this world. Maybe 4KB as
16 x 256 with entries like

   [IDX:1B][TYPE:1B][NAME:14B]

and sensors.dat.. if we have sensor and motor
files separately that could indicate the types,
and we're back to just names in the other file.

tags.dat: \n delimited name list with indices
implied: 

    MLR
    MRR
    SFLL
    SFRL

sensors.dat, motors.dat:
    [INDEX:1B][VALUE:1B] x count

gah no how does mfmt2 know the motors unless
t2serloop populates motors.dat to begin with? So
then both sides are writing motors.dat. So it
might as well be

tags.dat
   MLR,M
   MRR,M
   SFLL,S
   SFLR,S

sm.dat:
    [INDEX:1B][VALUE:1B] x count for s and m

and we live with both sides writing sm.dat?
Or it's
sensors.dat:[INDEX:1B][VALUE:1B] x sensor count
motors.idx[INDEX:1B] x motor count
motors.dat:[VALUE:1B] x motor count
?

Or it's
sensors.dat:[VALUE:1B] x 256
motors.dat:[VALUE:1B] x 256

Or fuck it it's just
input.dat: [LATEST SM I PACKET PAYLOAD]
output.dat: [NEXT SM O PACKET PAYLOAD, 'S' FIELDS IGNORED]

plus tags.dat with I/O marked

and we just write the latest packet payload
blindly into input.dat whenever we see it,
and brain writes output.dat whenever it wants to,
using its last-read input.dat to determine the
template.

Because we do want to remember there's no strong
synchronization between brain stem and brain.

What is the accuracy of a file modified time? ..if
we wanted to provide a 'new since you last looked'
functionality.

Does the modified time change if you overwrite
with the same data? It should right?[198:

Wed Jan 31 07:00:49 2024 Looks like it does:

    root@beaglebone:/home/t2/T2-12/base# echo foo >/mnt/T2TMP/foo.dat;stat /mnt/T2TMP/foo.dat
      File: /mnt/T2TMP/foo.dat
      Size: 4               Blocks: 8          IO Block: 4096   regular file
    Device: 25h/37d Inode: 1279157     Links: 1
    Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
    Access: 2024-01-31 07:00:17.029485139 -0700
    Modify: 2024-01-31 07:00:38.636089076 -0700
    Change: 2024-01-31 07:00:38.636089076 -0700
     Birth: -
    root@beaglebone:/home/t2/T2-12/base# echo foo >/mnt/T2TMP/foo.dat;stat /mnt/T2TMP/foo.dat
      File: /mnt/T2TMP/foo.dat
      Size: 4               Blocks: 8          IO Block: 4096   regular file
    Device: 25h/37d Inode: 1279157     Links: 1
    Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
    Access: 2024-01-31 07:00:17.029485139 -0700
    Modify: 2024-01-31 07:00:40.015999927 -0700
    Change: 2024-01-31 07:00:40.015999927 -0700
     Birth: -
    root@beaglebone:/home/t2/T2-12/base# 

[199:

Wed Jan 31 07:29:29 2024 OK so now we're writing
/mnt/T2TMP/tags.dat with like:

    <MLR
    <MRR
    >SLFL
    >SRFL

whenever we get a config file delivery. Problem is
if we get a config checksum that matches our
existing /mnt/T2TMP/world.toml, then we don't
request a full config even if tags.dat is outdated
or doesn't exist.

Could we go ahead and request a config file in
those cases, using modification times to determine
'outdated'?

How does python do stat stuff?

    >>> import pathlib
    >>> f = pathlib.Path('Makefile')
    >>> print(f.stat())
    os.stat_result(st_mode=33204, st_ino=20713104, st_dev=2431, st_nlink=1, st_uid=1001, st_gid=1001, st_size=145, st_atime=1706627387, st_mtime=1706522074, st_ctime=1706522074)
    >>> print(f.stat().st_mtime)
    1706522074.5588603
[200:

Wed Jan 31 07:44:23 2024 So stat result seems to
offer int seconds but st_mtime gives a float.
(There's also apparently st_mtime_ns)

    >>> print(f.stat().st_mtime,f.stat().st_mtime_ns)
    1706712239.7234056 1706712239723405674

which might be more precise?

So anyway it seems like we could write a thing to
check if tags.dat is non-existent or older that
world.toml, and request a full config in that
case, even if the world.toml checksum matches?

A little lame, since we could generate tags.dat
from world.toml anyway?

:200]
:199]

:198]


:197]

:196]
:195]

:194]
:193]
:192]

:191]

:190]

:189]
:187]
[201:

Wed Jan 31 08:05:38 2024 OK so I guess now we're
at writing input.dat, and then we'll need maybe a
.cpp spike to start reading input.dat and writing
output.dat?
[202:

Wed Jan 31 08:28:31 2024 OK, it seems like we are
writing /mnt/T2TMP/input.dat with the guts of the
WI packets. Shall we take a crack at some cpp for
a change?

We want to continually:
 - stat tags.dat and reload if it's newer
 - stat input.dat and reload if it's newer
 - dispatch to some stub routing algorithm
 - rewrite output.dat with the results

:202]
:201]
[203:

Wed Jan 31 10:56:59 2024 OK so theoretically
BrainStem.cpp is doing 'everything' except the
actual routing. But that's okay because
t2serloop.py is still doing the disgusto routing
all by itself.[204:

Wed Jan 31 15:59:45 2024 Except it wasn't loading
the tags.dat file at all.. now it is..

So now theoretically we could write routing code..
[205:

Thu Feb  1 01:55:27 2024 Looks like maybe finally
we are now routing sensorimotor data all the way
between pybullet on the workstation, and C++ code
on the keymaster, and back, for the first time.

Hello February.

:205]

:204]

:203]
[206:

Thu Feb  1 11:17:01 2024 So here's a little
thinko, right: .. well maybe not. was worrying
that BVCODE values might not be making it all the
way to BrainStem..[207:

Thu Feb  1 11:35:13 2024 Ah no the thinko is that
BrainStem.cpp is routing based on the index of
BVCODE instead of its value doh.
[208:

Thu Feb  1 11:44:08 2024 OK so we're thinking that
Sim tag 20240201-110850 is going to be the first
in history where the bv changes strategy during
the run. We're thinking it's a 2B for the first
about 1100 steps, at which point it's going to
change to a 3A. We'll see if that's blatant.. we
kind of suspect it will be?[209:

Thu Feb  1 11:53:54 2024 Yeah it's pretty
blatant:) .. in this run the balls splattered off
far away and BV had basically given up, and then
all of a sudden both wheels started turning madly.
BV's looking for love!
[210:

Thu Feb  1 12:27:59 2024 Buuuut, it appears the
last ball fell out of frame, leaving Beevee racing
towards the edge of the universe. Would rather
have some little bias there to curve..

Going again..

:210]
:209]

:208]
:207]

:206]
[211:

Thu Feb  1 14:15:56 2024 Hmm, bv 3b is kind of
messed up the way I've implemented it. It wasn't 
obvious to me but 3b will only work the way
Braitenberg describes it if the sensors are
omnidirectional, rather than mostly
forward-facing (as I implemented them).

I have no idea what we'd actually get if we tried
a 360 FOV or near that in getCameraImage. Super
fish-eye? Would things even work then? It would
only be the (slightish, it seems) parallax shift
between the sensors that would determine
everything? 

:211]
[212:

Sat Feb  3 02:15:10 2024 OK well, committing
everything I can find ahead of rebooting lcf to
pick up latest kernel image etc before t2sday gets
too close.

So we implemented an upward-facing 179 degree FOV
fisheye camera called SUPL, and threaded it into
everything. Modified BrainStem.cpp
inhibition/excitation to include some SUPL
influence on both sides, so ATM all Brainstem
routers use a combination of L or R, plus UP to
drive the motors.

It does help with BV3B; seems not to
destroy BV2B dynamics.. We shall see.

:212]
[213:

Thu Feb  8 16:14:14 2024 OK, past Feb T2sday and
just today finally found (mostly friction)
parameters that work fairly well. Committing.

:213]
