#!/usr/bin/perl -w  # -*- perl -*-
use Fcntl;
use File::Path qw(make_path remove_tree);
use File::Copy qw(move);
use File::Temp qw(tempdir);
use Errno qw(EAGAIN);
use Time::HiRes;
use List::Util qw/shuffle/;
use Digest::SHA qw(sha512_hex);
use Data::Dumper;

use warnings FATAL => 'all';
$SIG{__DIE__} = sub {
    die @_ if $^S;
    require Carp; 
    Carp::confess ;
};

my $BASE_DIR = "/cdm";
my $COMMON_DIR = "$BASE_DIR/common";
sub updateBaseDir {
    $BASE_DIR = shift;
    $COMMON_DIR = "$BASE_DIR/common";
}
my $CDM_INTERNAL_HANDLE = "t2-keymaster-release-10";
my $CDM_INTERNAL_REGNUM = "0";
my $DELETEDS_MFZ_NAME = "cdm-deleteds.mfz";
my $DELETEDS_MAP_NAME = "cdm-deleteds.map";
my $MFZRUN_PROGRAM = "/home/t2/MFM/bin/mfzrun";
my $MFZMAKE_PROGRAM = "/home/t2/MFM/bin/mfzmake";

my $VERBOSE = 1;

my %deletedsMap;
my $DEBUG_DIRS = 1;

sub hexEscape {
    my $str = shift;
    $str =~ s/([^-_.a-zA-Z0-9])/sprintf("%%%02x",ord($1))/ge;
    return $str;
}

sub deHexEscape {
    my $str = shift;
    $str =~ s/%([a-fA-f0-9]{2})/chr(hex($1))/ge;
    return $str;
}

sub hexEncode {
    my $binstr = shift;
    return unpack("H*",$binstr);
}

sub deHexEncode {
    my $hexStr = shift;
    return pack("H*",$hexStr);
}

sub makeTmpDir {
    my $template = "cdmctl-XXXXX";
    my $cleanup = 1;

    $cleanup = 0 
        if $DEBUG_DIRS;

    my $destdir =
        tempdir( $template,
                 TMPDIR => 1,
                 CLEANUP => $cleanup
        );
    return $destdir;
}

sub loadDeletedMap {
    my $dmref = {};

    print STDERR "Unpacking $DELETEDS_MFZ_NAME.." if $VERBOSE;

    my $path = "$COMMON_DIR/$DELETEDS_MFZ_NAME";
    if (!-r $path) {
        print STDERR "not found => no records\n" if $VERBOSE;
        return $dmref;
    }

    my $destdir = makeTmpDir();
    my $cmd = "$MFZRUN_PROGRAM -kd $BASE_DIR $path unpack $destdir";
    my $metadata = `$cmd`;

    print STDERR "done\n" if $VERBOSE;

    # Now we have to hunt for the path used to pack the payload
    my @paths = glob "$destdir/tmp/cdmctl-*/cdm-deleteds.map";

    my $deletedsFilePath = shift @paths;

    die "'$destdir' problem" unless defined $deletedsFilePath;

    print STDERR "Loading $deletedsFilePath.." if $VERBOSE;
    open(HDL, "<", $deletedsFilePath)
        or die "Can't read $deletedsFilePath: $!";
    while (<HDL>) {
        chomp;
        my @fields = split(/\s+/,$_);
        scalar(@fields) == 4 or die "Bad fmt '$_'";
        my $filename = deHexEscape($fields[0]);
        my $length = $fields[1];
        my $checksum = $fields[2];
        my $timestamp = $fields[3];
        $dmref->{$filename} = [$length, $checksum,$timestamp];
    }
    close(HDL) or die "Closing $deletedsFilePath: $!";
    print STDERR "done\n" if $VERBOSE;
    return $dmref;
}

my $digester = Digest::SHA->new(256);

sub checksumWholeFileHex {
    my $path = shift;
    $digester->reset();
    $digester->addfile($path);
    my $cs = substr($digester->digest(),0,16);
    my $hexcs = unpack("H*",$cs);
    return $hexcs;
}

sub getMetadataOfMFZ {
    my $mfz = shift;
    my $path = "$COMMON_DIR/$mfz";
    my $cmd = "$MFZRUN_PROGRAM -kd $BASE_DIR $path VERIFY";
    print STDERR "Extracting metadata of $mfz.." if $VERBOSE;
    my $metadata = `$cmd`;
    print STDERR "done\n" if $VERBOSE;
    my $mref = {};
    while ($metadata =~ /([a-zA-Z_]+) \[([^]]+)\]/sg) {
        $mref->{$1} = $2;
    }
    $mref->{WHOLE_FILE_CHECKSUM} = checksumWholeFileHex($path);
    $mref->{FILE_SIZE} = -s $path;
    return $mref;
}

sub checkOrAddToMap {
    my ($mfz,$dmref) = @_;
    if ($mfz eq $DELETEDS_MFZ_NAME) {
        print "Illegal to delete '$mfz'\n";
        return -1;
    }
    my $path = "$COMMON_DIR/$mfz";
    if (!-e $path) {
        print "No such file '$path'\n";
        return -1;
    }
    my $mfzref = getMetadataOfMFZ($mfz);
    my $length = $mfzref->{FILE_SIZE};
    my $checksum = $mfzref->{WHOLE_FILE_CHECKSUM};
    my $timestamp = $mfzref->{INNER_TIMESTAMP};
    defined $length and $checksum and defined $timestamp or die;
#    print "GOTS".Dumper($mfzref)."\n";
    if (defined $dmref->{$mfz}) {
        my ($len, $xsm, $its) = @{$dmref->{$mfz}};
        if ($length == $len && $checksum eq $xsm && $timestamp == $its) {
            print "$mfz at $its is already flagged as deleted, no changes\n";
            return 0;
        }
        if ($timestamp < $its) {
            print "$mfz is older ($timestamp) than one already deleted ($its), no changes\n";
            return 0;
        } # ELSE FALL THROUGH
        print "Updating existing $mfz deletion because $timestamp >= $its\n";
    }
    $dmref->{$mfz} = [$length, $checksum, $timestamp];
    return 1;
}

sub saveDeletedMap {
    my $dmref = shift;
    my $packDir = makeTmpDir();
    my $deletedsFile = "$packDir/$DELETEDS_MAP_NAME";
    open(HDL,">",$deletedsFile) or die "Can't write '$deletedsFile': $!";
    for my $mfzname (sort keys %{$dmref}) {
        my $aref = $dmref->{$mfzname};
        my $fname = hexEscape($mfzname);
        my $length = $aref->[0];
        my $checksum = $aref->[1];
        my $timestamp = $aref->[2];
        print HDL "$fname $length $checksum $timestamp\n";
    }
    close HDL or die "Can't close '$deletedsFile': $!";

    my $path = "$packDir/$DELETEDS_MFZ_NAME";
    my $cmd = "$MFZMAKE_PROGRAM cdmake $CDM_INTERNAL_REGNUM $path $deletedsFile";
    my $result = `$cmd`;

    -e $path or die "wha?";
    my $commonPath = "$COMMON_DIR/$DELETEDS_MFZ_NAME";
    move($path,$commonPath) or die "Couldn't move $path -> $commonPath: $!";
    print "Updated $commonPath\n";
}

sub doListDeleted {
    my @args = @_;

    if (scalar(@args) > 0) {
        die "Usage: $0 listDeleted\n";
    }
    my $dmref = loadDeletedMap();
    my $len = 0;
    my $count = 0;
    my @keys = sort keys %{$dmref};
    foreach my $mfzKey (@keys) {
        ++$count;
        $len = length($mfzKey) if $len < length($mfzKey);
    }
    foreach my $mfzKey (@keys) {
        my $ts = $dmref->{$mfzKey}->[2];
        printf("%*s  as of %s\n",$len,$mfzKey,$ts);
    }
}

sub doInitMap {
    my @args = @_;
    my $confirm = "yesiamsure";
    if (scalar(@args) != 1 || $ARGV[0] ne $confirm) {
        print STDERR "Usage: $0 initmap $confirm\n";
        exit 1;
    }
    my $dmref = {}; # Start with nothing.
    saveDeletedMap($dmref);
    print "Released empty deleteds map\n";
}

sub doDelete {
    my @mfzs = @_;
    if (scalar(@mfzs) == 0 || scalar(grep { $_ !~ /[.]mfz$/ } @mfzs) > 0) {
        die "Usage: $0 delete FILE1.mfz [FILE2.mfz...]\n";
    }

    my $dmref = loadDeletedMap();
    my $changes = 0;
    foreach my $mfz (@mfzs) {
        my $ret = checkOrAddToMap($mfz,$dmref);
        if ($ret < 0) {
            print "Processing aborted\n";
            exit 1;
        }
        $changes += $ret;
    }
    saveDeletedMap($dmref) if $changes > 0;
}

my %cmds = (
    "help" => \&doHelp,
    "delete" => \&doDelete,
    "listdeleted" => \&doListDeleted,
    "initmap" => \&doInitMap,
    );

sub doHelp {
    my @keys = sort keys %cmds;
    print "Commands are: ".join(" ",@keys)."\n";
    exit 3;
}

sub setBaseDirectory {
    my @args = @_;
    if (defined $args[0] && $args[0] eq "-bd") {
        shift @args;
        my $dir = shift @args;
        die "Missing/bad dir" unless defined $dir and -d $dir;
        updateBaseDir($dir);
    }
    return @args;
}

sub processArgs {
    push @ARGV, "help" unless scalar(@ARGV);
    @ARGV = setBaseDirectory(@ARGV);

    my $verb = shift @ARGV;
    my $code = $cmds{lc($verb)};
    return &$code(@ARGV) if defined $code;
    print "Unrecognized command '$verb'\n";
    doHelp();
}

sub main {
    processArgs();
}
main();
