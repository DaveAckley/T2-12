{227}  -*- text -*-
[0:

Sat Jan 19 12:29:28 2019 OK, so we've been struggling trying to pick a
userspace interaction/communication model for intertile stuff, and we
then perhaps the current missing link is we need an explicit 'neighbor
tile' abstraction.  Something that's not about the intertile
connection, but about the tile at the far end -- whether we currently
have a such a neighbor or not.

Unsure if it belongs in /dev, /sys/class, or something more userspace,
but perhaps like /dev/tile/ET etc.  For at least some users, we'd like
connection and disconnection events to be reported as just more
packets on some channel that stays open across such things.

And this abstraction would naturally be the place to handle those
currently-unhandled locstd 'P' and 'F' packets that we are currently
dumping to syslog like lost babies.  The /dev/tile/DIR object would
change status as a result, and that would be somehow visible more
broadly in userspace.

Perhaps we should draft a standard local packet type for 'tile event
notices' right now, so that our tile model can have an OoB way to
notify consumers about such changes.

OK, currently 201812171048-packet-format-notes.txt:1: has our
'documentation' for the defined local standard packet types.  0..3 (of
31) are currently in use.  Just take 4?  What is its name?[1:

Sat Jan 19 12:57:57 2019 'Tile Event Packet'?  TEP?  None of the std
loc packet types seem to have manifest constant names yet.[2:

Sat Jan 19 12:59:31 2019 And what is the TEP syntax?  Well, we finally
will not have the direction encoded in it, because that's now implicit
in which tile we are talking to.

So:
TEP := TEP_PKT_TYPE + EVENT_TYPE + OPT_ARGS
TEP_PKT_TYPE := 0xc4
OPT_ARGS     := BYTE*

EVENT_TYPE   :=
 0x00      Illegal
 0x01      Connect
 0x02      Disconnect
 0x03-0xff Reserved

[3:

Sat Jan 19 16:04:54 2019 The tile models, I guess, should provide
services by something like port number, so packets can be
demultiplexed by the tile model.

And I guess the userspace 'server' we're thinking of is the "actual"
tile that the remote tile models are modeling.
[4:

Sat Jan 19 17:21:36 2019 Looking at some FUSE tutorials..  I know
there's plenty of people hating on FUSE but it might be at least a
transition technology for us here as we try to figure out what we
actually want our LKMs to do for us.
[5:

Sun Jan 20 01:06:31 2019 Well, fuse is about what you'd expect -- a
giant pile of callbacks with a lot of fiddly details about
unimplemented flags and fuse-versions and so forth.  We can certainly
figure it out if we really want to but I'd rather have a clearer idea
what we want out of it before we try.

[6:

Sun Jan 20 01:08:10 2019 What are our main use cases?

1. mfmt2 would like to sit on one fd -- preferably via select() but
   perhaps block on a thread -- and receive all intertile mfm packets.

2. mfmt2 would also like to select() on one fd to know when it can
   send an intertile packet?

3. some 'physics daemon' would like to announce and monitor the tile's
   current physics 'version stamp' and do background intertile
   updating of newer versions.

4. at a minimum the physics daemon would manage mfz files; as a
   step-up it could propagate like the T2 repo as well.


5. 'general intertile communications', whatever that might mean?

[7:

Sun Jan 20 04:25:04 2019 Given that it's all about 1 & 2, really, what
about if we draft the reserved bit in

    FIRST BYTE

     Standard Routed Packet Header
      STND LOCL RSV1
     +----------------------------------------+
     |  1 |  0 |  0 |OVRN||EROR|DIR2|DIR1|DIR0|
     +----------------------------------------+

(from /home/t2/T2-12/pru/itcio/notes/201812171048-packet-format-notes.txt:0 )

to be the 'mfm bit'?

      STND LOCL MFMT
     +----------------------------------------+
     |  1 |  0 | 1  |OVRN||EROR|DIR2|DIR1|DIR0|
     +----------------------------------------+

So anything with MFMT set is 'MFM traffic' that would be routed to and
from like /dev/itc/mfm or something, and mfmt2 would select or block
on that.[8:

Sun Jan 20 04:33:55 2019 So, everybody else would do what?  Go through
some single daemon that managed packet services for everybody except
mfm?  And that guy would expect packets like what, perhaps:


      BYTE 0                                   BYTE 1
      STND LOCL MFMT
     +----------------------------------------++---------------------------------------+
     |  1 |  0 | 0  |OVRN||EROR|DIR2|DIR1|DIR0||DST3|DST2|DST1|DST0|SRC3|SRC2|SRC1|SRC0|
     +----------------------------------------++---------------------------------------+

and we'd support up to sixteen random packet service ports.  Or I
suppose we could go to a three byte header, jeez.[9:

Sun Jan 20 04:54:44 2019 And how would people offer and use those
services.  Open /dev/itc/svc/ff for RDWR|NONBLOCK or something?  But
then do we even need a distinct source port, or is everything peer to
peer?  That would be flavorful.
[13:

Thu Jan 31 00:36:25 2019 So, we're back here, and we have a public
challenge to get software moving between tiles before next t2sday.

So, picking up the discussion in :8:, we need to pull the trigger on a
format for STND,!LOCL,!MFMT packets.

Do we NEED source ports?  Well, why do source ports exist?  So that
multiple 'clients' can talk to one 'server'.  Now, in basic intertile
land, we are ONLY talking to neighboring tiles and are NOT routing
beyond that.  And the source DIRECTION is already present in the BYTE0
header, so clients on different neighboring tiles are already
distinguishable.

So these multiple clients, if we had them, would have to be all on a
SINGLE neighboring tile.  Do we really need that?  Well, what if we
wanted to update a bunch of files amongst our neighbors?  We might be
newer on some files and some of our neighbors might be newer on
others.  It would be arguably convenient to just start flows for each
file that has to move in any direction and let their packets get
interleaved however, rather than having to (go to all the onerous
extra trouble to) make a user-level queue or whatever for the files
destined for each neighbor.
[14:

Thu Jan 31 02:40:10 2019 So I guess that example isn't
super-compelling to me.  To the contrary, if we had a peer-to-peer
'managed file update service', we could (more easily) get different
pieces of files from different neighbors and so on.  (Eventually.)

Are there other cases to consider for source ports?[15:

Thu Jan 31 02:46:01 2019 ..I'm just not seeing it.  Screw it, let's go
full-on peer-to-peer and deal with any fall-out as we have to.  Worst
case we can always create a source port model underneath some
peer-to-peer service.

So, we'd be saying something like

      BYTE 0                                   BYTE 1
      STND LOCL MFMT
     +----------------------------------------++---------------------------------------+
     |  1 |  0 | 0  |OVRN||EROR|DIR2|DIR1|DIR0||RSV1|RSV0|SVC5|SVC4|SVC3|SVC2|SVC1|SVC0|
     +----------------------------------------++---------------------------------------+

where we offer up to 63 services (reserving service 0 as null), and
hold a couple of bits for the future.

Aaand we can go ahead and draft a few services here, at least
provisionally?

Say service 1 is a .. what?  Version number?  Liveness ping?  Maybe we
should stick to our knitting here and just say like service 8 is
'managed file update'.  We want a service that just falls towards
having the newest version of all managed files that any neighbor knows
about.  We'll have a directory of the current king of the hill files,
each with a version number and a checksum..[16:

Thu Jan 31 03:17:26 2019 Stop stop stop.  Crawl before fly my god you
have to get something running here.  A directory of MFZ files that are
all to be considered 'legitimates physics-es'.  All have to be signed
by a known key.  We go by the timestamp in the mfz to decide if a file
is newer.  As an idle background process, we send random mfz+timestamp
info to random neighbors every so often.  If we receive word about an
MFZ that we don't have or that's newer than what we do have, we
request that file.  The source starts streaming it to us.  We assemble
it in a temporary directory.  When/if it arrives completely and we
verify it locally, we (atomically-ish) cut it over into the live
directory, and that's when it will start getting broadcast to our
neighbors.

Somehow we have a way -- perhaps a different service in fact -- of
saying it's time to change physics, which we handle by shutting down
MFM and restarting it on a new MFZ.

For now we still won't have intertile events, so there's no issue yet
of mfm needing to check that neighbors are on the same MFZ.

:16]

:15]

:14]

:13]
:9]


:8]

:7]


:6]

:5]
:4]
:3]


:2]

:1]

:0]
[10:

Sun Jan 20 08:02:15 2019 But, I need to see something anything proof
of concept minimal crap actually working here, for me to feel
comfortable.

I want a Perl script daemon that

1. Watches the modification date of some counter file, and reloads it
   whenever it changes.

2. And advertises its counter value by sending it to all active
   neighbors every minute or so.

3. And tracks the counters of all active neighbors by monitoring their
   counter value advertisements.

4. And

:10]
[11:

Wed Jan 30 22:37:52 2019 Aaand, to make the guts of that work, we need
a way to send a file.  Which is a stream of bytes, plus metadata,
which has to be packetized, sent, received, and reassembled.

Aaaaad, damn the NIH torpedoes aaand damn the RTW (Reinventing The
Wheel) nay-sayers and let's just MAKE OUR OWWWWWWWWN.

[12:

Wed Jan 30 22:40:56 2019 So.  We need packet formats for metadata and
data stream.  We have some structure for such things already set up,
so we should find that.

:12]

:11]
[17:

Sat Feb  2 23:50:04 2019 Aaaand we're back.  [18:

Sun Feb  3 01:04:12 2019 So we're making 'cdm.pl', a demo 'common data
manager' script that, as far as I can tell right now, will have
essentially no user interface at all.  It will hog all the packets on
/dev/itc/packets -- a device which should, once mfmt2 exists, NOT
include mfm traffic -- and build a model of its own and its neighbors
common data, and automatically send updates as needed so that
everybody falls towards having an equivalent view of what counts as
the latest common data.  cdm.pl will generate output along the lines
of log messages about what's going on, but that's about it.

But first, nap.[19:

Sun Feb  3 02:36:19 2019 Well, maybe not nap yet.

Structures for file/directory model:

 @content => (sha512-of-content content-length-bytes path-to-content)


:19]

:18]


:17]
[20:

Sun Feb  3 04:44:54 2019 OK, say service 3 is CDM_PKT_TYPE.  Format
is:

      BYTE 0                                   BYTE 1                                   BYTE 2
      STND LOCL MFMT
     +----------------------------------------++---------------------------------------++----------------+
     |  1 |  0 | 0  |OVRN||EROR|DIR2|DIR1|DIR0||   0|   0|   0|   0|   0|   0|   1|   1|| CDM PKT TYPE   |...
     +----------------------------------------++---------------------------------------++----------------+

 => 0x80 | dir, 0x03, code, args..  Why service 3?  Because that's ^C
for 'CDM'?  Whatever.

And our first code is 'A'live, a liveness ping.  Let's implement that
and foggen PROCESS A PACKET.[21:

Sun Feb  3 05:17:49 2019 OK, so there it is.  Mr NW sent
'\203^CA' packets and Mr SE sent '\207^CA' packets, and Mr NW received
'\203^CA' packets and Mr SE received '\207^CA' packets.

Which seems like they could just be talking to themselves.. but the
dirs get remapped from dst->src as they move intertile.  (Which I just
confirmed by adding a random number payload to distinguish the 'A'
packet.)

So.  Progress.  Now nap.  (What _is_ happening to those packets we're
sending to unconnected tiles, hmm?)

:21]

:20]
[22:

Sun Feb  3 11:47:53 2019 OK, so, let's have a primitive neighbor model
to maintain and grow:

 - Direction to ngb
 - Time we last got an Alive pkt from them
 - Time we last sent an Alive pkt to them

I guess we ought to do 'object hash' style.  This is likely to grow
hunh?

Also, maybe we shouldn't use wall-clock time, but just
count-of-background-works or something.  We really want to avoid
leaning on absolute time if we don't need it.  We'll call an entry to
doBackgroundWork a.. what?  'Ticks' is way too overloaded already.
'Tocks'?  Just makes you look around for ticks.

'Background Work' -> 'Borks'?  Probably too distracting.. 'Clicks'?
Maybe.  'Clacks'?  Ooh, better :).  Like machinery!  Big old
steam-powered machinery suitable for slow background tasks.

[23:

Sun Feb  3 12:27:00 2019 Do we actually need even clacks, in the sense
of it being an absolute count of doBackgroundWork calls?  We're facing
count-to-infinity if we want absolute clacks.  And all we really need
is 'clack intervals' anyway, right?  Couldn't we do countdowns
instead?  And we don't even need countdowns if we seriously drink our
own koolaid and do 'stats instead of state'.  Every time we pick a ngb
to consider, we have some odds of sending it an Alive..  And if we
have it flagged as alive, we have some odds of clearing that flag.
Like 1 in 25 to send our Alive, 1 in 100 to clear their alive.

Going all-stats might be get pretty raggedy, though, for something
we're thinking of as fairly low-level.  Could mix it, stats to send
our alive but a countdown to expire their Alive?  Or countdown for
both but reset them to random range.  Or countup with random
expiration. [24:

Sun Feb  3 13:07:20 2019 Now, wait a minute.  Do we even need
aliveness packets given we have the credible and much lower-level
notion of packet sync?  Well, it's not about need, it's about
robustness.  If we have PS but aren't getting alive packets, our
neighbor has got problems in middle management.

Suppose we create an apoptosis signal packet -- a pretty low-level
one, that's handled in the LKM.  One such packet doesn't mean much,
but getting them frequently from multiple neighbors should be a sign
that we should try to make a note of the situation somewhere and then
reboot.

:24]

:23]

:22]
[25:

Sun Feb  3 14:21:27 2019 Well, we have two reserved bits in byte 1 of
standard routed tile (as opposed to mfm) packets.  I'm wondering about
drafting either or both as a 'network level' indicator or something,
like:

 00 User space
 01 LKM
 10 PRU reserved
 11 Illegal reserved

where 'normal' cdm packets would be 00 but apoptosis packets would be
01.

I suppose a more 'port-like' approach would be just reserve a low
range of service numbers to be 'system' level.[26:

Sun Feb  3 14:42:03 2019 BUT IN ANY FOGGEN EVENT I SHOULDN'T BE
DESIGNING INTERTILE APOPTOSIS RIGHT THE FOG NOW.  Sheesh.

:26]

:25]
[27:

Mon Feb  4 00:38:22 2019 OK, also want a data model to describe our
view of the common/ directory.  At least, stuff about file paths,
sizes, and checksums.  We're still struggling to define our
relationship with wall-clock time: We don't think we really need it,
and we don't think it's all that scalable, but it's what the
filesystem is going to be using so what do we do?

Fundamental data model question: When should some content count as a
new version of an existing name?[28:

Mon Feb  4 00:52:59 2019 All we really have at the moment is the
internal timestamp on mfz files.  We can get at that using the
extended version of 'mfzrun verify':

    ackley@coldaynell:~/PART4/code/D$ ./MFM/bin/mfzrun ../E/MFM/res/elements/demos/ForkBombs.mfz VERIFY
    SIGNATURE_CHECK [OK]
    INNER_CHECKSUM [2aafbf-aa30-a86bc6]
    INNER_TIMESTAMP [1536398164]
    SIGNING_HANDLE [MFM-DEMOS-20180908031520-ulam-3.0.12-ackley]
    HANDLE_FINGERPRINT [e1bf-234-7029]
    HANDLE_PUBKEY [-----BEGIN RSA PUBLIC KEY-----
    MIGJAoGBALdLR5qmGltWAx7Kt5yBAiNQbElAT9UuAjVNZCdHYTuTRckeyhNNF0VS
    0mKBAKAyzLXIG4yXJVCw5s/lx2J3DCcXOv62tNDL8uPpqM3PiGlSv+R5iSvDv27m
    mNpHxXYIwfrpaHLPSngPyYa3P31r8gRCka+K8IiF9dimYMjan+N/AgMBAAE=
    -----END RSA PUBLIC KEY-----
    ]

which absolutely does depend on absolute time, but, because it's also
signed by someone we've been told to trust, we're inclined to believe
that successive INNER_TIMESTAMPs will be legitimately comparable
within a given mfz name.[29:

Mon Feb  4 01:18:56 2019 Another natural, modrun possibility is
working off a git repo and deriving version precedence from successive
commits on a given path.  But that brings an awful lot of
infrastructure with it -- not necessarily bad infrastructure, but not
necessarily infrastructure we want to fundamentally depend upon
either.

Back in IXM-land a decade ago, we had 'green boot', 'blue boot', and
'red boot'.  Green boot accepted wall-clock-newer code from anybody,
blue required wall-clock-newer plus matching the current 'program id',
and red wouldn't accept new code at all without a physical button
press during boot up.

We could say a physical button-press is required to add something to
/data/common?  But how would that work?  We accept any contents in
/data/common when cdm.pl starts up, so put new crap in then restart.

[30:

Mon Feb  4 01:34:39 2019 Well, fog it, we have to get off the dime
here.  For today let's only consider .mfz files, let's checksum them
externally and recheck the checksums from time to time, and when they
change we use mfzrun VERIFY to get the internal timestamp, and if the
internal timestamp beats what we're holding we propagate it.

One practical problem is that mfzrun VERIFY is only in the github,
it's not in the MFM-4.0.12 that the tiles are using.  Now, I guess for
the moment we could just use 'mfzrun list' and take the time of the
MFZPUBKEY.DAT file as proxy for the 'internal timestamp'.

Let's do that.  Damn the torpedoes.

[31:

Mon Feb  4 01:40:45 2019 So, one cdm background task is load/refresh
an .mfz file.

The file info we'll keep is:

  [path, length, checksum, signing-handle, timestamp]

The file info we'll send to neighbors is

  [path, timestamp]

So our data model, for now, will be:

 %dataModel =
   [path => [length, checksum, signing-handle, inner-timestamp]]
   [path => [length, checksum, signing-handle, inner-timestamp]]
[33:

Mon Feb  4 08:35:41 2019 Well, now we're wondering we should have
'available-from' and 'bytes-needed' (or something) as well, in the
file info.  Otherwise we're going to have to have that info
elsewhere, right, and somehow link it to this?

Well, finish the mfz metadata gathering first, then come back to
this.

:33]
and that's all..[32:

Mon Feb  4 02:11:10 2019 Well, let's also keep an array of files to
check, that we can munch through one by one without hoping to keep a
directory handle open for long periods of time..

:32]

:31]

:30]
:29]

:28]

:27]
[34:

Mon Feb  4 09:54:10 2019 Well, alright, finally, here we are needing
to announce the existence of a file an alive cdm neighbor.  What's the
CDM packet type and format for that?

'B' because it's next after 'A'?  Doh.  'B' for 'Be aware'? 'C' for
content?  'F' for file?  'I' for info?  'M' for MFZ?

'F' for file I guess.
[45: SEE :44: BELOW  :45]
0x80 | dir, 0x03, 'F', len+filename, len+checksum, len+innertimestamp?
How big is that??

max    1/1   1/2   1/3 1/4 36/40     1/41 16/57    1/58 10/68

:34]
[35:

Mon Feb  4 10:33:01 2019 Well, I suspect I now know what happens once
the tx buffers fill up..  I suspect this is what happens:

    Feb  4 10:27:59 beaglebone kernel: [127827.790882] itc_pkt rpmsg0: timeout waiting for a tx buffer
    Feb  4 10:27:59 beaglebone kernel: [127827.796695] itc_pkt itc!pru0: Transmission on rpmsg bus failed -512
    Feb  4 10:29:11 beaglebone kernel: [127899.741438] itc_pkt rpmsg0: timeout waiting for a tx buffer
    Feb  4 10:29:11 beaglebone kernel: [127899.747269] itc_pkt itc!pru0: Transmission on rpmsg bus failed -512
    Feb  4 10:29:47 beaglebone kernel: [127935.828735] itc_pkt rpmsg0: timeout waiting for a tx buffer
    Feb  4 10:29:47 beaglebone kernel: [127935.834543] itc_pkt itc!pru0: Transmission on rpmsg bus failed -512
    Feb  4 10:30:45 beaglebone kernel: [127993.699574] itc_pkt rpmsg1: timeout waiting for a tx buffer
    Feb  4 10:30:45 beaglebone kernel: [127993.705409] itc_pkt itc!pru1: Transmission on rpmsg bus failed -512

And sitting here I can't think of any existing way to flush tx buffers
except reboot or possibly reload itc_pkt.ko..[36:

Mon Feb  4 10:40:01 2019 Well, in this case

    Error: Bad address at ./apps/t2/cdm/cdm.pl line 49.
    root@beaglebone:/home/t2/T2-12# modprobe -r itc_pkt
    root@beaglebone:/home/t2/T2-12# modprobe itc_pkt
    root@beaglebone:/home/t2/T2-12#

seemed to work (it shut down and rebooted the PRUs and everything), so
we'll go with that for now..
[37:

Mon Feb  4 10:51:43 2019 Maybe we shouldn't even queue a packet for
transmission unless we believe we have PS.  You shouldn't try to route
a packet toward an ITC unless you believe it has PS.  [38:

Mon Feb  4 11:23:59 2019 OK, we think we can do that pretty
reasonably..  What errno do we want to throw if you try it?[39:

Mon Feb  4 11:27:53 2019 Well, let's try -EHOSTUNREACH and see how we
like that..

:39]

:38]

:37]
:36]

:35]
[40:

Mon Feb  4 19:14:13 2019 OK, back in town getting stuff set up
again.[41:

Mon Feb  4 20:51:08 2019 Well that took longer than it should've but
we're now correctly parsing the CDM F type packet info, and we need to
decide how to store that info before we actually have the file in.

Let's start by adding a status field to finfo.  Status "Got"
means we have the whole file, it checks, and we can serve pieces of it
to anybody that asks.  Status "Need" means we are missing some or all
of the file.  ..Or more minimally, we could just have a count of the
bytes-from-the-front that we currently think we do have, and if that's
less than the length we ask somebody for the next segment.  How do we
know who to ask?  Keep a list of dirs that have offered it.  Pick at
random.  Drop dirs from the list every so often.  [42:

Mon Feb  4 21:32:54 2019 So, add 'currentLength', initially 0, and
'checkedLength', also initially 0.  When 'currentLength' is less than
'length', request a chunk starting at currentLength from anybody is
advertising the content.

When currentLength reaches length, go on to mfzrun checking, and when
that succeeds, set checkedLength to length.   Once checkedLength is
equal to length, start advertising the file.

Request a chunk with a CDM C type packet, for 'chunk' or 'content'
Format of C type is:
[59: SEE :58: BELOW  :59]
0x80 | dir, 0x03, 'C', len+filename, len+checksum, len+startingIndex

Host seeing a 'C' packet immediately checks if they have the file and
its checkedLength is greater than the requested starting index.  If
so, host replies with a CDM D type packet providing 'data'.  Format of
D type is:
[60: DITTO SEE :58:  :60]
0x80 | dir, 0x03, 'D', len+filename, len+checksum, len+startingIndex

[43:

Mon Feb  4 21:55:30 2019 OK well it's obviously a huge drag to have to
send the file name and checksum over and over in every C type
request.  We're going to add a 'tag' to the 'F' packet advertisement
-- like a stock number -- that is locally unique to the advertiser and
which can be used to refer to the content when talking to that
advertiser.  We'll take some bits from the file name, the checksum,
and the innertimestamp, and append an incrementing number.

SKU:  firstLetterOfFilename+4hexchecksumprefix+3loworderdigitsoftime+lexincr

SKU lexincr is assigned when the content is checked.  The point of the
identifying info is to help disambiguate the case where a neighbor cdm
restarts, for whatever reason, and starts handing out the same
lexincrs.

[44:

Mon Feb  4 22:13:23 2019 So F type becomes
[62: SEE :61: BELOW  :62]
0x80 | dir, 0x03, 'F', len+filename, len+checksum, len+innertimestamp, len+incr

and when we receive an F we need to store the incr with the associated
dir that we got it from.
[47:

Mon Feb  4 23:04:11 2019 Umm don't we need the content length too?
Else how do we know when we're done?

Adding length to F type.  Also fuck it let's cut the checksum in half.

:47]
And we need to refactor the F parsing to make the len+foo stripping
much more automatic..

:44]

:43]
:42]
:41]

:40]
[46:

Mon Feb  4 22:43:13 2019 And we're going to have to be veeeery careful
about making and distributing updates that affect the cdm protocol
itself.  We ultimately want to distribute cdm using cdm, which means
adjacent protocol versions must always be forward and backward
compatible.

While at the moment we don't even have a cdm protocol version.

I think a basic rule is that we shouldn't get pissed if there's extra
crap at the end of a packet, and future versions must only add shit at
the end, or else deal with the backward compatibility.

But anyway, we're just accepting that as technical debt at the moment.
CONTENT MUST MOVE!  NOW NOW NOW.

 :46]
[48:

Tue Feb  5 00:36:11 2019 So, we really need to keep the pending files
separate from the 'good content' files.  If cdm restarts with
incomplete files sitting in /data/common, it's going to be a huge mess
at best.  Much better to keep in-progress files separate and only cut
them into common when they are complete and checked.

So when we get an advertisement we have a few cases:

(1) We find it complete and matched in common/.  We ignore the
    advertisement.  Also ignore it if the name is in common/ but we
    can't check it yet.

(2) It's absent from common/ and pending/.  We create a record for it
    pending/, with the dir and sku of the advertiser.

(3) It's present and matched in pending/.  We add or refresh the dir
    and seqno in the record.

(4) We find it complete but mismatching in common/.  If we dominate,
    ignore the advertisement.  If they dominate, remove our complete
    from common/ (or move it to archive/ somehow) and continue at (2)

(5) We find it complete but mismatching in pending/.  If we dominate,
    ignore the advertisement.  If they dominate, remove our pending
    from pending/ and continue at (2).

Beyond that, we 'just' flush pending/ when we start up, And Then
Everything Just Works No Really.

:48][49:

Tue Feb  5 02:58:42 2019 Well, we have to get to shooting the video
and we're not 'technically' going to have INTERTILE S/W in a form I
would consider acceptable if I was grading my work.  But so be it;
tons of yada progress yada.

So current state is we have announcements getting sent and received
and processed plausibly -- leading to stubs in pending/ with metadata,
but we aren't requesting or sending the data chunks.

:49]
[50:

Wed Feb  6 03:52:20 2019 Well, t2sup#217 released an hour late, which
was a bummer, but at least it's out there.  Main extra delay was
zillions of tiny renders trying to get the webcam tile footage mostly
synced to the screengrab audio.

(Plus trying to get the damn CDM stuff working first.  Ahem.)

Now let's foggen get CDM actually MOVING some effen FILES.

Where we we?  Last design snarl I remember was realizing we really did
want to distinguish common/ and pending/ and to build incoming files
in pending/.

In the implementation, I wasn't sure whether I wanted %dataModel to
contain both although I thought not at first.  But then in the rush I
put both common/ and pending/ stuff in there and it wasn't an instant
disaster because the keys are full paths.  It may well be an issue if
I try to iterate over %dataModel, but that will depend on why I'm
iterating over %dataModel..

[51:

Wed Feb  6 04:11:42 2019 So let's try to see how we'll get to
requesting pieces of that we need![52:

Wed Feb  6 04:13:14 2019 Right now we go to checkAnnouncedFile, where
we do (the easy part of) the logic in :48: above.  We create a
pending/ record for the file, with no seqno and currentLength and
checkedLength both 0.  So now we 'just' have to find that record at
some appropriate time -- under our own initiative, without another
packet coming in.  And that's why we could want pendingModel separate
from dataModel.  Or rename dataModel to commonModel and make
pendingModel as a sibling.

Let's try that.[53:

Wed Feb  6 04:27:11 2019 Right now we are keying on the path
(including the 'common') instead of on the filename.  But I'd think
we'd want to go with the filename instead, and have the common vs
pending distinction in the surrounding table, so we could move finfo
records between tables as we move the associated files between
directories.

Let's try to key on filenames, just that much, and get that
established to our current level of functioning.[54:

Wed Feb  6 05:53:42 2019 Well, we cleaned things up a bit.  Still
struggling with whether finfo's contain their path or not.  Seems like
they need to but then we have to update that when they move.  Let's
have them store their current subdir, remember to update that, and
then build the path when we need it.[55:

Wed Feb  6 06:37:18 2019 OK, did that.  Pushing all this mess out and
then we circle back around to pulling files.

[56:

Wed Feb  6 06:42:49 2019 OK dammit its file pulling time.  Wooly bully
file pully.  First off we'll make a background step to check into
pending for something to do.[57:

Wed Feb  6 07:21:15 2019 OK, so have we defined packets for file
transfer yet? ..yes, back in :42:, but I guess we need to redo it to
include the sku..

[58:

Wed Feb  6 07:40:21 2019

Request a chunk with a CDM C type packet, for 'chunk' or 'content'
Format of C type is:

0x80 | dir, 0x03, 'C', len+filename, len+sku, len+startingIndex

A CDM D type packet provides 'data'.  Format of D type is:

0x80 | dir, 0x03, 'D', len+filename, len+sku, len+startingIndex, len+data

How much data in a D?  Well, something up to the rest of the packet, I
guess.  Filename, sku, startingIndex are all variable length.  Could
we go just with the sku in type C and type D?  Review the sku!

:43: Well the problem is what happens if a remote cdm restarts and
therefore restarts its 'unique' incrementing numbers?  Well so what?
We'll probably want a 'nack' D format anyway for when people ask for a
sku that we don't have, for whatever reason.  So let's redo.

:58]

:57]

:56]
:55]

:54]

:53]

:52]

:51]

:50]
[61:

Wed Feb  6 08:09:56 2019 Redoing the doc for type F, C, and D:

F type: File announcment

0x80 | dir, 0x03, 'F', len+filename, len+contentlength, len+checksum, len+innertimestamp, len+seqno

C type: Content request

0x80 | dir, 0x03, 'C', len+sku, len+startingIndex

D type: Data reply

Format 1 (C denied): 0x80 | dir, 0x03, 'D', len+sku, 0,

Format 2 (Has data): 0x80 | dir, 0x03, 'D', len+sku, len+startingIndex, len+data, 2+hack16

:61]
[63:

Wed Feb  6 08:41:33 2019 OK, implementing that stuff.  Just changed
otherSeqnos from an array ref to a hash ref, because scanning the
array for a random neighbor pick seems a pain.  But that raised the
question: How do we age information out of otherSeqnos?  We don't want
to be wasting time sending C types to neighbors that won't respond.

One possibility is to only keep the most-recently-announced neighbor
with the content, rather than trying to keep all of them.  We may end
up pounding a single guy for a while, even though other neighbors
might have the content, but, hey, the guy did advertise having the
content..  And if another advertisement comes in while we're pulling
content, we'll switch.

Well, let's try that.  [64:

Wed Feb  6 08:48:46 2019 But it's a (dir,seqno) pair we have to
remember, not just one item...  Arrays or hashes do that naturally..
Maybe whenever an advertisement comes in we'll randomly age out
previous occupants.

:64]

:63]
[65:

Wed Feb  6 09:56:14 2019 OK, we're sending C type requests finally:

    REQUEST(ƒC
    c9273844110)

making the neighbors say:

    UNHANDLED PKT(\207^CC
    c9273844110)

So it's time for a D type handler and then push all this again..

:65]
[66:

Wed Feb  6 10:13:14 2019 Aaaand how do we map from sku back to finfo?
You'd really think I'd see this type of thing coming by now.  I guess
we keep a seqno->filename map on top of everything else.  Add to it
whenever we burn a seqno.  Map only grows on content churn which is
expected to be low.

And we're only going to serve content from common/, so we only need to
look for finfos there.[67:

Wed Feb  6 17:44:37 2019 Buuut we receive content into pending/, so we
also have to look for finfos by sku in there.  We can't just have the
one global seqno map and use it for inbound D types.  seqno's are only
unique on per-neighbor, we have to store and look them up on that
basis.  Now, we have this neighborModel, don't we?  ..%hoodModel.
What all's in there?[68:

Wed Feb  6 21:05:23 2019 Well it seems the top level of the two-level
%cdmModel hash is really about the same thing as the %hoodModel and
they ought to be merged together.  But do I have the strength to do
that before seeing this damn thing work even once?

What's the alternative?  What's the quick hack to try?  Add a
seqno->filename map as like $hoodModel->{$dir}->{contentOffered},
update that as announcements are seen, and look up skus in that.

Yeah well let's try that.[69:

Wed Feb  6 21:22:04 2019 Well the checkSKUIn stuff needs refactored
even for the hack, though.  Passing the subdir isn't what we really
want.

If we redid the %hoodModel to be on top, and used some special code to
represent ourselves in the hood, it would probably be significantly
cleaner in the end..  But let's get this working first, gah down boy.
So we need to redo checkSKUIn to be checkSKUInDir, and use dir==8 to
mean ourselves?  For ourselves we look in subdir common when we need
the file, for other dirs we use pending.  And we're adding
contentOffered to the hoodModel guys..

:69]

:68]

:67]


:66]
[70:

Wed Feb  6 22:05:15 2019 OK, well, at VERY long last, we have
demonstrated INTERTILE S/W movement.

"clams.mfz, come here, I need you"

and all 863 bytes of clams.mfz is now in pending/, with the same
md5sum as the machine it originated on.

[71:

Wed Feb  6 22:06:56 2019 So, final step in this first round
implementation: Discover the file is complete and move it into
common/.

At that point it should start to move another hop All By It Selfs.

[72:

Wed Feb  6 23:08:19 2019 OK, making progress releasing the arrived
.mfz.  Currently we're hanging because the 'mfzrun list' is
complaining about an unrecognized handle and asking us what we want to
do.

(1) What does 'mfzrun verify' do with an unrecognized handle?
(2) How can we detect an unrecognized handle without having to
    supply input to a subprocess?[73:

Wed Feb  6 23:13:34 2019 We can check the exit status of 'mfzmake
canvalidate HANDLE' to know if HANDLE is usable.[75:

Thu Feb  7 00:40:02 2019 But, umm, excuse me, meester, MEESTER?  How
do we know what the handle _IS_, until we look into the .mfz file,
which we can't do without mfzrun hanging waiting for input?

:75][74:

Thu Feb  7 00:10:21 2019 Now, down the road, we'd really like for
different handles to be valid for different .mfz's, so we could let
people update their mfmt2 load, for example, without being able to
modify the CDM system itself.  So we'd like the CDM to control
HANDLES.mfz that somehow contains a mapping from .MFZ file to valid
handles for signing on it.

But for now it's fine that clams.mfz fails because we don't know its
handle.

For now let's just add a /cdm/pubkeys directory and -kd to that..


:74]

:73]

:72]
:71]

:70]
[76:

Thu Feb  7 15:44:59 2019 OK, well we now have INTERTILE S/W so that's
a thing.  But it still has a lot of problems and missing bits, and
we're going to have to push back and rethink our guts now that we have
some sense of the issues.  So maybe we'll branch off to logistics and
parts acquisition for a bit, and then circle back around here with a
redesign.  Looking for a somewhat principled way to deal with:

 1. New versions of existing files found on the filesystem
 2. New versions of existing files arriving on the wire
 3. The need to delete files somehow

and also, possibly

 4. The ability to decouple names from content and maintain a content
    cache so that giving

and also

 5. A daemon wrapper loop so that cdm can restart itself (after getting
    an update) simply by exiting.

and also

 6. Include full checksum + signing handle and fingerprint in announcements?

:76]
[77:

Sat Feb 16 03:16:06 2019 OK, we need to advance the cdm story a little
bit.  And obvious next stop is updating existing files.  We already
have an official place for that to die, no?[78:

Sat Feb 16 04:02:54 2019 Yeah, around cdm.pl:778, in
checkAnnouncedFile.  ..But actually we have code trying to handle
outdated common starting at 744.  I guess we need to see that code
blow up to see where we are.

:78]

:77]
[79:

Sat Feb 16 13:46:18 2019 OK, well one issue is that we weren't
updating the file length when we saw a modtime change.  Committing
just that to get it out to the neighbors.

Also seemed to have an issue that calling refreshProvider during a
file transfer could blow the transfer by deleting the pending record
where we were keeping our progress or something?  Saw something like
that but it's not diagnosed yet.[80:

Sat Feb 16 14:20:12 2019 OK, we seem to be propagating updated
versions of a given name.  So that's nice, though the code is gross.

A remaining issue is we're saying 'COMMON CHECKSUM MISMATCH
UNIMPLEMENTED, IGNORED' in response to an -- I think -- out-of-date
announcement.. [81:

Sat Feb 16 14:38:33 2019 OK, shut that up, I think.  Committing this,
though I believe detecting new common/ content in a running cdm is
still untested.

:81]

:80]

:79]
[82:

Sat Feb 16 15:20:53 2019 OK, well, one test of updating a common/ file
while cdm is running appeared to work, so I think maybe we're
galloping on to the next level up.

I think we should start a quick sort of 'command-line content manager'
script that will implement deletion by updating and releasing a
CDM-STATE.mfz file.  There would eventually be a CDM-CODE.mfz as well,
and perhaps a CDM-CONFIG.mfz.  They probably ought to correspond to
distinct subdirs of /cdm, and contain complete copies of same..[83:

Sat Feb 16 17:14:29 2019 So let's move here on this.  What is/are the
dir names? /cdm/{state|code|config}? /cdm/CDM/{state|code|config}?
/cdm/CDM-{STATE|CODE|CONFIG}?

Well, we're going to be special-casing the handling of these things
somehow, so how is that going to be done?  If it works directly off
the .mfz file name, then..

Let's say.. what's the difference between 'state' and 'config'?  Not
really sure yet I guess.  But where do the deleteds go?  In state,
that seems clear.  Where do the rules about what's handled specially
go?  In config?

/cdm/cdm/config/triggers.map

  -> A file mapping common/.mfz filenames to special actions, where
     special actions are like 'unpack to dir X', and 'restart service
     X'.  We don't put these triggers within the .mfz itself,
     apparently, because we want a pretense of separating code and
     data?

/cdm/cdm/state/deleteds.map

  -> A file containing a list of common/.mfz filenames + checksums.
     Every file on the list is (currently) 'deleted': It should be
     removed from common/ if it found, and it should not be announced
     or accepted.

  .. And we'll have a finfo for this?  Separate from the cmd-state.mfz
  that contains it?  Or no, just as part of triggering on cdm-state
  we'll reload this thing.  And at boot time?  That does seem like a
  finfo.  But this file, itself, is not shared.  When a new version of
  it appears, we don't pick it up and announce it.

What if there's no explicit 'unpacked' directory at all?  We'll have a
current CDM-STATE.mfz file in common/, and we'll have a special rule
so that on loading that (right after checksum success time, I guess),
we'll unpack it into /tmp or memory and process the info immediately.

Could it be a common/MFMT2-STATE.mfz that starts up mfmt2 (aka mfms at
the moment)?  So there wouldn't even be a systemd service to start up
mfm, just cdm?  And then cdm would start up mfm, etc?  That makes a
certain amount of sense.  Not sure how we make it robust though.

I guess mfmt2 needs a layer or two of robustness on its own.  A driver
script that just restarts it if it dies.  We'll see.[84:

Sun Feb 17 00:40:26 2019 So I realized the fact that we can just
wily-nily rename files and have them look new is evidence of the fact
that we can't or shouldn't rely just on file names for 'magic
triggering' purposes, or we open ourselves to DoS attacks at least.
Even filename + handle won't do it, since it's easy to copy signed
files to a new filename.

The signature applies only to the content, not to the filename.

So when we want to trigger on a special file, we want the manifest
inside the file to have the form we are expecting.  It should contain
the file(s) we expect, and we would know that because we go looking
for them as part of triggering.

So overall we'd say, for a rule to trigger, all this must hold:

(1) File name must match MFZ NAME
(2) Handle/pubkey must be in AUTHORIZED SET
(3) Manifest must contain FILE PATHS

at which point whatever are the TRIGGER ACTIONS are to be performed.

Now: This triggering is supposed to establish constraints between the
(latest recognized) trigger file and the files it updates.  In
particular, meaning that if a trigger-controlled file is modified
locally, those modifications are liable to be overwritten by the
trigger file being re-run at some point.  Like a 'git checkout foo'
overwriting local modifications to 'foo'.

The question is: When should a 'git checkout foo' be run
automatically?  Never?  Boot time only?  cdm.pl startup?  At random
intervals whenever cdm.pl is running?

Let's say cdm.pl startup for now.  But let's write the code so it
could be called at other times, yes.

[85:

Sun Feb 17 02:06:32 2019 All this discussion was also making me think
that maybe triggered .mfzs should only contain one path?  Expecting
cdm to be iterating through some random .mfz file... sniff, cdm has
much bigger and more important things to be doing.

But that circles back around to the synchronized updates issue.  If we
can only have one file per trigger mfz how do we update both cdm.pl
and stat13.pl in a synchronized way?  We'd have to add another level
of zipping, and then what have we accomplished except hide the paths
that will actually be ordered?

[86:

Sun Feb 17 02:49:21 2019 So we need to relax a little bit, here, I
think.  If the file name is right and the pubkey is right and some
single, top-level 'MFZ-NAME.txt' file exists and matches, then that's
it, we're good to go.  We position all the other contained files
anywhere in the fricken file system, and restart some services or
whatever.

We could generate MFZ-NAME.txt automatically in mfzmake, couldn't we?
It needs to be down in the inner zip, like MFZPUBKEY.DAT but unlike
MFZSIG.DAT.  So we'd call it MFZNAME.DAT I guess.

What happens if you try to pack a file names MFZPUBKEY.DAT?[87:

Sun Feb 17 03:08:01 2019 Ah, good boy:

    root@beaglebone:/# mfzmake make t2-cdm-debug-10 norg2.mfz MFZPUBKEY.DAT last-clams-before-deletion-is-possible.txt

    Error: 'MFZPUBKEY.DAT' is handled automatically, cannot pack it explicitly
    Type '/usr/bin/mfzmake help' for help
    root@beaglebone:/#

[88:

Sun Feb 17 03:13:25 2019 Aaaaahhummm, except, bad boy:

    root@beaglebone:/# mfzmake make t2-cdm-debug-10 norg2.mfz ./MFZPUBKEY.DAT last-clams-before-deletion-is-possible.txt
    Wrote 'norg2.mfz'
    root@beaglebone:/#

and then:

    norg2.mfz

    M Filemode      Length  Date         Time      File
    - ----------  --------  -----------  --------  ----------
      -rw-r--r--       172  17-Feb-2019  03:11:04  MFZSIG.DAT
      -rw-rw-rw-       689  17-Feb-2019  03:11:04  MFZ.ZIP
    - ----------  --------  -----------  --------  ----------
                           861                         2 files

and
    MFZ.ZIP

    M Filemode      Length  Date         Time      File
    - ----------  --------  -----------  --------  ------------------------------------------
      -rw-r--r--       280  17-Feb-2019  03:11:04  MFZPUBKEY.DAT
      -rw-rw-rw-         7  17-Feb-2019  03:07:08  MFZPUBKEY.DAT
      -rw-rw-rw-        10  16-Feb-2019  15:15:06  last-clams-before-deletion-is-possible.txt
    - ----------  --------  -----------  --------  ------------------------------------------
                         297                         3 files

So really we ought to ban MFZPUBKEY.DAT and MFZNAME.DAT from _any_
path in the mfz, not just the top-level?  Would it be safe to
normalize the path first using some perl whizzerd, and then check the
canonicalized form?[89:

Sun Feb 17 03:23:41 2019 Looks like maybe:

    root@beaglebone:/# mfzmake make t2-cdm-debug-10 norg2.mfz /root/../MFZPUBKEY.DAT last-clams-before-deletion-is-possible.txt
    ZONGABS(/MFZPUBKEY.DAT)
    ZONGABS(/last-clams-before-deletion-is-possible.txt)
    Wrote 'norg2.mfz'
    root@beaglebone:/#

And mfzmake is already 'abs_path'ing the files.. we 'just' need to
check for special-at-top-level files after rather than before doing
that.. [90:

Sun Feb 17 06:59:49 2019 OK we've been hacking in MFM to get the
original mfz filename into the inner zip, and that's starting to
work.  It really kind of feels like we should bump the .mfz format
version but I really don't want to do that considering we don't have
any code ready to handle backward compatibility there at all.

So even though it's lame, I'm much more inclined to just say the
existence of MFZFILE.DAT is not guaranteed in general, although we'll
require it for any 'triggering' mfz.[91:

Sun Feb 17 07:38:28 2019 Committing that stuff.

:91]

:90]

:89]

:88]

:87]

:86]

:85]

:84]

:83]

:82]
[92:

Sun Feb 17 12:56:33 2019 So pop pop how do we get to some visible
behavior quickly here?  Let's do deletion.  Let's start the
command-line cdm tool.  Called...  'cdmctl' I guess.

I also think we should now commit to using repo versions of the mfm
tools instead of the installed ones.  We can still fuss about the GFB
stuff, but we should commit to the tree for mfm, ulam, and SPLAT, and
figure out how to get updates for them moved without having to rebuild
them on each tile.  What happens if you try to diff a non-compressed
tar file?  [93:

Sun Feb 17 13:41:39 2019 Screw it let's just package everything for
now.  It's the only way to be robust, and updates at the
mfm/ulam/splat level are supposed to be asymptotically rare anyway.

But first let's get naming and syntax for the deleteds file, and then
something for the triggers file.

CDM-DELETEDS.mfz containing

  cdm/config/deleteds.map

in turn containing rows of the form..  announcement packets?  Could we
do that?  Put down a length byte first for packet framing, then put
down an announce packet?  Or maybe have a difference code for
reporting a deleted file -- cdm "D" type or something -- and use
that.  What info do we really need?  Just filename+checksum?
Or filename/length/checksum/innertimestamp, like cdm F type?  Why not
the handle too, then?

We either trust the checksum til the cows come home or we don't.  If
we do, then handle and inner timestamp are irrelevant since they're
covered by the checksum.  If we don't...?

I guess the point is that a 'deleteds map' should be smaller than
actually retaining all the deleted files.  After all, another way to
solve the deletions problem is just move the file to a 'deleted/'
directory like a Trash folder.  But we never reclaim the space that
way.  The deleteds map, the tombstone set, is to provide a more
compact representation of that-which-no-longer-exists than actually
keeping the stuff hidden somewhere.

Now, if we're constantly issuing new versions of some mfz, we don't
want to keep the checksums of all its older versions in the deleteds
map.  We want to (and already do) rely on the inner timestamp to
determine precedence.  So really, a deleteds entry should include the
timestamp, and it should be telling us that all versions of this
filename that are at least this old should be considered deleted.

And if a newer version of the same name is confirmed, I guess we
should remove that record from deleteds.

[94:

Sun Feb 17 14:40:46 2019 So, what's the easiest way to get some
version of this going?

Implement 'cdmctl delete FILE'.  Have it look in /cdm/common to find
FILE or die.  Get the filename/length/checksum/innerTimestamp from it.
(And handle?)  Load /cdm/config/deleted.map.  See if the filename is
already in there.  If not, add the current information to the map.  If
so, check if the inner timestamp of the deleted is newer than ours.
If so, then the file we are being asked to delete is 'already
deleted', so report that and do nothing.  Otherwise, update the
deleted record to our information, and rewrite the deleteds file.
Then (re)generate cdm-deleteds.mfz and place that in common/.  (User
must have t2-cdm-debug-10 private key to do this.)

"Done."[95:

Sun Feb 17 14:59:23 2019 Now, actually, don't we really need cdm.pl to
do most of that itself?  Because when a new version of the file is
asserted in common/, the older version should be removed from
deleteds, and we don't want cdm.pl and cdmctl to be racing to write
deleted.map.  How do we signal intention-to-delete?[96:

Sun Feb 17 16:22:11 2019 Maybe cdm.pl can't create a cdm-deleteds.mfz
on its own?  So if a new version of FILE comes along when it's
currently listed in deleteds.map, it stays in deleteds.map even though
it is no longer deleted since there's a newer version.

So really we want only cdm.pl to be writing deleteds.map, and to be
doing it only as part of unpacking a cdm-deleteds.mfz.  And cdmctl is
the only thing that should be writing cdm-deleteds.mfz, and if there's
a race between to cdmctl's writing two different cdm-deleteds.mfz on
two different tiles, both versions will circulate until the newer one
dominates the older one, and if they have exactly the same timestamp,
then.. the system will be broken?  Perhaps we should break the tie
with the lexicographically greater checksum at that point.

And it any case the system can still be broken, or at least DOSed, by
releasing a cdm-deleteds.mfz file with the maximum possible timestamp.
If we hold to our intention to only compare timestamps within a given
.mfz name 'lineage', we can't use our local clock to claim that some
given timestamp is in the future and reject it.  [97:

Sun Feb 17 16:38:11 2019 Anyway so do we have a plan here?  'cdmctl
delete FILE' is going to get the info from common/FILE, load
deleted.map, update it, then generate a new cdm-deleted.mfz -- without
actually updating the existing deleted.map.  The new cdm-deleted.mfz
gets dumped in common, replacing what's there, and that's it.

Then cdm.pl sees the modtime change on cdm-deleted.mfz, loads and
verifies it, discovers it's triggerable and triggers it, and the
triggering deletes FILE.  And..

You know, why the hell do we even have /cdm/config/deleted.map as a
separate file at all?  Why not just 'leave it' in
/cdm/common/cdm-deleted.mfz?  The cdm-deleted triggering can just load
the file into cdm.pl memory.  It seems like having the external 'bare'
file would be just an unnecessary special case to have to handle.
We'll get robustness by people announcing their cdm-deleted.mfz files
to us.[98:

Sun Feb 17 17:03:22 2019 Again. 'cdmctl delete FILE' gets info from
common/FILE, 'loads' common/cdm-deleted.mfz, updates it if necessary,
and generates a new common/cdm-deleted.mfz.  That's it.  Let's do it.
[99:

Sun Feb 17 17:11:53 2019 And hmm, what if we implemented 'deleted.map'
by encoding deleted filenames, plus their checksums and their
timestamps, as the names of 0-length files directly in the zip?  Is
there a limit on zip file filename length?  Then we could just do an
'mfzrun cdm-deleted.mfz LIST' command and get all the information we
need..   Too tricky for my shirt?[100:

Sun Feb 17 17:24:51 2019 Seems like might be a 255 or 250 byte limit
for filenames.  And 4096 (from unix) for full paths..  We could put
the checksum and timestamp as path elements..gah.
[101:

Mon Feb 18 00:04:30 2019 Problem isn't the trickiness so much as we'd
need to hook into mfzmake/mfzrun processing below its existing command
line level, and we don't really want to do _that_, for just a little
trickiness.

So back to the single deleted.map file inside cdm-deleted.mfz.

:101]
:100]

:99]
:98]

:97]
:96]

:95]

:94]

:93]

:92]
[102:

Mon Feb 18 04:26:04 2019 OK, well it's a total crock, but we have
cdmctl generating new and updated /cdm/common/cdm-deleteds.mfz files.
At the moment cdm.pl is not 'triggering' on them -- so in fact no actual
deletions are happening, still, doh -- but the updated
cdm-deleteds.mfz files are getting propagated around the grid
successfully.

:102]
[103:

Wed Jun 12 05:16:12 2019 OK so only four months later we are back here
again.  So we'd already mentioned /dev/itc/mfm as early as :7: above,
and that's what we're thinking we want to implement now.
[104:

Wed Jun 12 06:12:04 2019 Back from walk.  And note we'd pretty much
totally forgotten that '/home/t2/T2-12/apps/cdm/cdmctl' actually
exists. [105:

Wed Jun 12 07:07:06 2019 Which we've now punched up a little bit, and
refreshed for our current keymaster key and structure.  And note re
the 'DOS' discussion in :96: above, without the keymaster private key
one can't release a functional cmd-deleted.mfz anyway, so that's just
another thing hanging off the same private key, rather than a separate
distributed programming issue..

:105]

:104]
:103]
[106:

Wed Jun 12 07:11:04 2019 So, anyway, anyway.  Back to LKM land.[107:

Wed Jun 12 07:21:45 2019 In /home/t2/T2-12/pru/itcio/module/itc_pkt.h,
we see:

    #define MAX_PRU_DEVICES 2       /* PRU0, PRU1*/
    #define MINOR_DEVICES (MAX_PRU_DEVICES+1)  /* +1 for the ITC packet interface */

and couldn't we add another one in there for an MFM packet interface?
[111: Wed Jun 12 09:02:07 2019

DONE (or, messed with that anyway.)

:111]
[108:

Wed Jun 12 07:31:25 2019

[114: Wed Jun 12 09:13:17 2019
DONE :114] - We'd add another kfifo, mfmPacketKfifo.[112: Wed Jun 12 09:03:14
  2019 and?

[115: Wed Jun 12 09:13:39 2019
DONE :115] - We'd add another wait_queue mfmPacketWaitQ?[113: Yes I think so.
   And also

[116: Wed Jun 12 09:13:54 2019
DONE :116] - We'd add another mutex, mfmLock.

:113]

:112]

 - We'd make another const struct file_operations, mfm_pkt_fops. [109:
     Wed Jun 12 07:59:30 2019 Would we?  Maybe not.

[117: Wed Jun 12 09:16:54 2019
DONE :117] - We'd extend make_itc_minor, for example around itc_pkt.c:876, with
   stuff like

      if (minor_obtained == 3)
        snprintf(devname,BUFSZ,"itc!mfm");


:109]

[118: Wed Jun 12 09:20:11 2019
DONE :118] - We'd add a new case to itc_pkt_read for our new mfm case 3, that
   would look much like case 2 but on a different kfifo.

[119: Wed Jun 12 09:22:12 2019
DONE :119] - We'd change itc_pkt_write around itc_pkt.c:475 to include minor
   3 as well as minor 2, so mfm packets would go through standard
   packet routing.

[120: Wed Jun 12 09:22:48 2019
DONE :120] - We'd change itc_pkt_cb around itc_pkt.c:703 to check the 'mfm' bit
   in the type byte, and divert to using S.mfmPacketKfifo and
   S.mfmPacketWaitQ if it's set.

[121: Wed Jun 12 09:23:09 2019 Made it a loop
DONE :121] - We'd check what's going on in itc_pkt_probe with all that minor==2
   stuff to see if it needs to be generalized or duplicated for minor
   3.
[110:

Wed Jun 12 08:57:36 2019 Well, is this more or less try-able?

:110]
:108]

:107]

:106]
[122:

Wed Jun 12 09:23:22 2019 OK well I did all the implicit TODO I'd made
up. [123:

Wed Jun 12 09:24:47 2019 And it compiles.  But nap time before I try
running this s'cah.

:123]

:122]
[124:

Wed Jun 12 13:10:00 2019 OK trying it..[125:

Wed Jun 12 13:10:45 2019 Well would you look at that:

    root@beaglebone:/home/t2/T2-12/pru/itcio/module# ls -l /dev/itc/
    total 0
    crw------- 1 root root 247, 0 Jun 10 12:21 locks
    crw------- 1 root root 246, 3 Jun 12 13:10 mfm
    crw------- 1 root root 246, 2 Jun 12 13:10 packets
    crw------- 1 root root 246, 0 Jun 12 13:10 pru0
    crw------- 1 root root 246, 1 Jun 12 13:10 pru1
    root@beaglebone:/home/t2/T2-12/pru/itcio/module#

and /dev/itc/packets is minor 3 and everything.  [126:

Wed Jun 12 13:12:24 2019 Looks like /dev/itc/packets might still be
working:

    root@beaglebone:/home/t2/T2-12/pru/itcio/module# cat /dev/itc/packets
    …A…Fcdmd-T2-12.mfz987765õ¡MÒyNsŸ¥”0bÏ
    156017469010‡FBONGERS.mfz7509*áäÈS=hï«¹eYcŠš
    15494995928‡Fcdmd-t2.mfz314460f´J§ÖnŸ/e#A¦wÝ
    156023444815…F	CDM11.mfz12066¯Wë_ {/¶ós–üo#Ý
    154986702213…FPONGERS.mfz7509*áäÈS=hï«¹eYcŠš
    154949959211‚Fcdmd-T2-12.mfz987765õ¡MÒyNsŸ¥”0bÏ
    15601746908‡Fcdm-distrib-T2-GFB.mfz7780FtÁø7vûiaaÄ»ý
    15597802765‚Fcdm-distrib-T2-GFB.mfz7780FtÁø7vûiaaÄ»ý
    155978027613…Fcdmd-devbins.mfz682276eÚƒìzxAæ>ùC3ó>ÌÚ
    15601239402‚Fcdm-distrib-T2-GFB.mfz7780FtÁø7vûiaaÄ»ý
    155978027613‡Fcdm-distrib-MFM.mf16903483ˆÕvzƒ¾`%’¯Ú»
    15600916064…Fcdmd-MFM.mf10417990ËÝˆ9=Ìˆn™Xh|X
    156021665012Fcdm-distrib-MFM.mf16903483ˆÕvzƒ¾`%’¯Ú»
    156009160610‡Fcdmd-T2-12.mfz987765õ¡MÒyNsŸ¥”0bÏ
    15601746902…Fcdmd-T2-12.mfz987765õ¡MÒyNsŸ¥”0bÏ
    156017469010‚Fcdmd-T2-12.mfz987765õ¡MÒyNsŸ¥”0bÏ
    15601746908…Fcdm-distrib-MFM.mf16903483ˆÕvzƒ¾`%’¯Ú»
    15600916065ƒA‡Fcdmd-MFM.mf10417990ËÝˆ9=Ìˆn™Xh|X
    156021665010…FPONGERS.mfz7509*áäÈS=hï«¹eYcŠš
    154949959211‚FBONGERS.mfz7509*áäÈS=hï«¹eYcŠš
    15494995925…A‚F	CDM11.mfz12066¯Wë_ {/¶ós–üo#Ý
    154986702211‡Fcdm-distrib-T2-GFB.mfz7780FtÁø7vûiaaÄ»ý
    CDM11COPY.mfz12066¯Wë_ {/¶ós–üo#Ý
    15498670223  C-c C-c
    root@beaglebone:/home/t2/T2-12/pru/itcio/module#

Which sure look like advertisements inbound from the neighbors.  Now
why it that there's a newline just before the tag in all those
packets?


:126]

:125]

:124]
[127:

Wed Jun 12 17:31:47 2019 OK well we're starting up apparently cleanly
again, after I wasted an hour or so by not rebooting and therefore
having an major:minor in use that shouldn't have existed.  Doh and doh.

So now I guess we need a legal-looking mfm packet to trying echoing
into /dev/itc/mfm..  And I guess the current status of packet format
development is something like:

      BYTE 0                                   BYTE 1                                   BYTE 2
      STND LOCL MFMT
     +----------------------------------------++---------------------------------------++----------------+
     |  1 |  0 | 1  |OVRN||EROR|DIR2|DIR1|DIR0||    MFM PKT FORMAT...                  ||
     +----------------------------------------++---------------------------------------++----------------+

Do we get to screw around imagining all-sancing MFM packet formats here now?[128:

Wed Jun 12 21:23:31 2019 Well, now after evening break, maybe we get
to think about it a little.  But really, we already have a cache
protocol, right?  How well does or doesn't it just drop in, here?[129:

Wed Jun 12 21:28:48 2019 Well, in src/core/include/CacheProcessor.tcc,
we see

        u8 byte = (u8) plen;  // plen<128 since OString128..
        m_channelEnd.Write(&byte, 1);  // Packet length, then data
        m_channelEnd.Write((const u8 *) pb.GetBuffer(), plen);

with no direction info since m_channelEnd is point-to-point so it
already knows.  But since we have OoB packet framing, we wouldn't need
the plen -- and we might prefer having a checksum instead.[130:

Wed Jun 12 22:07:46 2019 Also looks like we'd want to replace the
ChannelEnd abstraction since it expects to accumulate the bytes of a
packet but on the T2 packets will be handled atomically.[131:

Wed Jun 12 22:16:31 2019 So the MFM packet payloads are way small --
like a type byte plus one atom, or a type byte plus two shorts.  If
we're adding a routing byte plus a packet terminator to each of those
that could be pretty signficant overhead.[132:

Wed Jun 12 22:24:23 2019 So, the CacheProcessor already buffers up a
whole bunch of 'packets', in the form of CachePacketInfo structs,
inside its m_toSend array.  But when it gets to AdvanceShipping, it
breaks that back down to individual PacketIO::SendAtom chunks.

On the receiving side, the small individual packets are handled as
they are seen from ChannelEnd::ReceivePacket(); there's no inbound
buffering.  In principle, with smaller packets, the whole update
process would be pipelined between the two tiles -- the receiver could
be applying changes before the send has finished sending them
all.[133:

Wed Jun 12 23:21:06 2019 But in any event it seems we should leave the
cache protocol semantics alone until we have things working that way.
So we'll have little packets with a lot of overhead.

But we could still have other types of mfm packets beyond cache
packets -- like here's my simulation id, request to clear the world,
restart mfm, reboot t2, whatever.  Potentially in both p2p and flood
versions.

Now, if these cache packets really are so tiny, we could carve off
byte 7 at least and put the length right in byte 1:

      BYTE 0                                   BYTE 1                       BYTE 2            BYTE 3
      STND LOCL MFMT                            SPEC
     +----------------------------------------++---------------------------++----------------++--
     |  1 |  0 | 1  |OVRN||EROR|DIR2|DIR1|DIR0||  0 | MFM CACHE PKT LENGTH || CACHE PKT TYPE ||
     +----------------------------------------++---------------------------++----------------++--
     +----------------------------------------++---------------------------++----------------++--
     |  1 |  0 | 1  |OVRN||EROR|DIR2|DIR1|DIR0||  1 | MFM SPECIAL TYPE     || MFM SPEC TYPE ARGS..
     +----------------------------------------++---------------------------++----------------++--

with the understanding that if the t2 packet length was bigger than
the mfm cache pkt len, that means there's another mfm cache pkt in the
same t2 pkt?  Blows the ignore-excess-packet-for-forward-compatibility
theory mentioned around here somewhere -- but if we say a 0 byte in
the length position means end we could have it back sort of.  Or if we
just say ignore and skip unknown packet types like MOV file chunks etc.

[134:

Thu Jun 13 00:20:49 2019 How actually are we going to identify the
simulation we are running?  Do we need an mfmt2 argument so mfzrun can
pass info in?[135:

Thu Jun 13 00:22:46 2019 We also need to remember we want to
prioritize mfm packets outbound.  Where does that happen?  We want the
mfm kfifo to be flat empty before we consider /dev/itc/packets
traffic.[136:

Thu Jun 13 00:28:50 2019 Umm we don't have any outbound kfifos, we
just blast packets directly to rpmsg_send and tough noogies if there's
no rpmsg bufs available.  So /dev/itc/packets and /dev/itc/mfm are
first-come-first-serve serialized by rpmsg -- and umm where is the
lock controlling access to that?  itc_pkt_write(..) doesn't appear to
ever lock anything, but at least the following are shared data:

  static unsigned char driver_buf[RPMSG_BUF_SIZE];
    - where we buffer the message in kernel space

  devstate = S.dev_packet_state[newMinor];
    - the state for pru0 or pru1, including

  devstate->rpmsg_dev
    - the thing we actually send the messages on.

[137:

Thu Jun 13 00:56:00 2019 Maybe we should make an outbound kernel
thread that pumps out the rpmsg bufs.  We'll make two outbound kfifos
-- a priority lane for mfm, and a background process for itc -- and
have them share one waitqueue.  minor 2 writes to the itc fifo and
wakes the shared queue, minor 3 writes to the mfm fifo and does the
same.  The kernel thread makes rpmsg bufs as fast as it can.  Now
when rpmsg bufs are exhausted and the thread has to sleep, who wakes
it up again?  It's got to be the rpmsg interrupt that we didn't really
believe in so much, ugh.  Well we could have it be a short sleep.

It's a lot more complexity, and another layer of buffering.  Vs just
putting a lock around much of itc_pkt_write.

(Are we even safe on the read side?  I bet not either.  But sleep now.)
[138:

Thu Jun 13 07:29:10 2019 Well, looks like the read side has the
potential to be already okay, because of the existing kfifos.  People
trying to read /dev/itc/pru0 fight to acquire pru0's specialLock
mutex, and ditto for /dev/itc/pru1.  Once they have it, they block on
pru0's or pru1's private specialWaitQ until the the appropriate kfifo
(global S.special0Kfifo or S.special1Kfifo) is non-empty.

The same happens for /dev/itc/packets -- fight for S.standardLock,
wait on S.itcPacketWaitQ, until S.itcPacketKfifo is non-empty.  Ditto
/dev/itc/mfm, fight for S.mfmLock, wait on S.mfmPacketWaitQ, until
S.mfmPacketWaitQ is non-empty.

So read side might be okay.  And the only reason we've gotten away
with the existing write side is that we actually had only one
user-space writer.  Which is precisely what we are changing now.

What other alternatives are there?  Put a single lock around all write
activity, so only one process can get to rpmsg_send at a time.[139:

Thu Jun 13 09:09:40 2019 So I'm pretty conflicted about what to do
here.  A 'priority lane' for mfm seems like the right thing to do, but
just putting a lock around all writing seems like the easier thing to
try.

Fuck it, it's only Thursday.  Let's try to code up the priority lane.

[140:

Thu Jun 13 10:21:05 2019 Well here's another thing.  If we're tearing
up itc_pkt much at all, there's a variety of crap that seems like it
needs rewriting/cleaning.  Such as the comment in itc_pkt.h:

    /* per maj,min device -- so in our case, per PRU */
    typedef struct itc_dev_state {
     ..
    } ITCDeviceState;


which just isn't true given that we have two PRUs but four minors --
and in fact we do make four of them, via

    typedef struct itc_pkt_driver_state {
  ..
      ITCDeviceState    * (dev_packet_state[MINOR_DEVICES]); /* ptrs to all our device states */
    } ITCPacketDriverState;

and

    static int itc_pkt_probe(struct rpmsg_channel *rpmsg_dev)
    {
      int ret;
      ITCDeviceState *devstate;
      int minor_obtained;
  ..
      minor_obtained = rpmsg_dev->dst - 30;

      devstate = make_itc_minor(&rpmsg_dev->dev, minor_obtained, &ret);
  ..
      S.dev_packet_state[minor_obtained] = devstate;


and

    for (i = 2; i <= 3; ++i) {
 ..
      S.dev_packet_state[i] = make_itc_minor(&rpmsg_dev->dev, i, &ret);


It really seems like that should be rewritten to be per PRU and the
minor stuff should be handled separately sort of as an overlay.. but
that's a complete redesign of the code, which implies a complete
restabilization of a big pile of new code.

:140]

:139]

:138]
:137]

:136]

:135]

:134]


:133]

:132]

:131]

:130]

:129]

:128]


:127]
[141:

Thu Jun 13 15:39:48 2019 Let's think about the design then.  I need to
dig in.

Annotated structs:

typedef struct itc_dev_state {
  struct rpmsg_channel *rpmsg_dev;

   - channel provided to us in itc_pkt_probe when the PRUs are being
     booted and their handling module is being initted.

   - itc_pkt_probe gets called with a different rpmsg_dev for each PRU
     (I believe), but since we init /dev/itc/packets and /dev/itc/mfm
     during the first probe, their 'parent' is set to whichever
     rpmsg_dev we saw first.

     = I suspect that means that the ITCDeviceState dynamically
       allocated by devm_kzalloc for packets and mfm will both be
       released when that first-probed PRU is being 'detached', which
       is I hope harmless.


  struct device *dev;

   - Pointer to our 'parent' device in rpmsg_dev.  Used in dev_err and
     dev_info calls, at least.

  struct mutex specialLock; /*if held, a special packet roundtrip is in progress*/

   - lock hold by the low-level roundtrip packet comm between lkm and
     pru, used in these cases:

     = itc_pkt_read takes it before reading from S.special0Kfifo or 1.

     = send_msg_to_pru takes it around a call to rpmsg_send plus a
       wait for a return packet on S.special0Kfifo or 1.
       send_msg_to_pru is used for 'atomic' access to PRU resources in
       itc_pin_write_handler and itc_pin_read_handler, and to send the
       initial 'throat clearing' packet after the PRUs boot.  And, I
       think, that's it.

  wait_queue_head_t specialWaitQ;

   - A wait queue associated the above specialLock, and indirectly
     through that to the S.special[01]Kfifo

   - I really don't understand why I have the specialKfifo's as
     globals rather than just as data members in this struct.

  bool dev_lock;

   - A flag enforcing a single simultaneous open on the inode, used
     only in itc_pkt_open and itc_pkt_release, and seems fine for it's
     purpose -- especially as creating /dev/itc/mfm means we don't
     need multiple simultaneous opens on any single inode anyway.

  struct cdev cdev;

   - Linux' struct for a char device, with the file operations

  dev_t devt;

   - The major,minor for this device.

} ITCDeviceState;[142:

Thu Jun 13 17:07:16 2019 Well, that took forever.  And it still leaves
open the question of whether we want to use ITCDeviceState's for our
virtual devices.  What might it look like if we didn't?

#define PRU_MINORS 2   /* low-level access to PRU0, PRU1*/
#define PKT_MINORS 2   /* processed access to itc, mfm */
#define MINOR_DEVICES (PRU_MINORS + PKT_MINORS)

in global driver state S --

..
  ITCPRUDeviceState * (dev_pru_state[PRU_MINORS]);  /* ptrs to state for /dev/itc/pru[01] */
  ITCPktDeviceState * (dev_pkt_state[PKT_MINORS]);  /* ptrs to state for /dev/itc/{packets,mfm,?}*/
..

/* per rpmsg-probed PRU device - /dev/itc/pru[01] */
typedef struct {
  struct rpmsg_channel *rpmsg_dev;
  struct device *dev;

  struct mutex specialLock;        /* if held, a special packet roundtrip is in progress*/
  wait_queue_head_t specialWaitQ;  /* where to wait if special packet roundtrip in progress*/
  SpecialPacketFIFO specialKfifo;  /* buffer for inbound special packets */

  bool dev_lock;
  struct cdev cdev;
  dev_t devt;
} ITCPRUDeviceState;

/* per 'virtual' packet device - /dev/itc/{packets,mfm} */
typedef struct {
  struct device *dev;

  ITCPacketFIFO     pktKfifo;      /* buffer for all inbound packets on this device */
  wait_queue_head_t pktWaitQ;      /* for people blocking on this device */
  struct mutex      pktReadLock;   /* lock for reading packets on this device */

  bool dev_lock;
  struct cdev cdev;
  dev_t devt;
} ITCPktDeviceState;

and for outbound virtual packets, the write fops would use
S.dev_pru_state[minorNeeded] to get to the rpmsg_channel we need.
While for inbound virtual packets, the cb fops would use
S.dev_pkt_state[pktType] to get to the kfifo to stash in.

[143:

Thu Jun 13 17:42:46 2019 Well this is a giant redo but it feels kind
of right.  But, time for cocktails.

:143]

:142]


:141]
[144:

Fri Jun 14 01:45:48 2019 OK, things are all torn up.  Stopping for
tonight on this issue: Now we have separate kfifos for mfm vs itc
packets, but don't we also need to multiply that by PRU0 and PRU1
destinations?  The packet callback is per-pru; it needs to get just
what it needs.

So that means another reorg of the structs, at least.

:144]
[145:

Fri Jun 14 15:42:57 2019 Well, it's time to pack up for the weekend.
Checkpointing all this stuff -- in its unbuildable glory, so there'll
be at least one obvious prompt to get us going again.

:145]
[146:

Sun Jun 16 00:34:19 2019 OK, so we're cleaning up in itc_pkt_cb and we
have to redecide what to do about non-standard packets -- the ones
with the first byte high order bit turned off.  Questions:

 - Where do they come from?  What is their purpose?

 - What might the rest of first byte look like?

[147:

Sun Jun 16 00:46:30 2019 So, one thing is this: The bottom three bits
of the first byte of EVERY PACKET ORIGINATING OFF TILE are set to the
compass rose dir of the ITC where the packet arrived.  That's
hardcoded -- regardless of how 'non-standard' the packet might (want
to) be in other ways.[149:

Sun Jun 16 01:22:09 2019 So, at one point, in this T2 development, we
imagined that, like with the IXM packet format, people might be able
to type directly into an ITC and communicate successfully.

But that only worked, way back when, BECAUSE THE IXMS COMMUNICATED
OVER UARTS, AND because we did byte-stuffing instead of bit stuffing,
AND because we used '\n' as the packet delimiter.

And none of those things are true in the T2s.  We expose 1 UART port
for debug serial, and that's not an ITC and none of our LKM code
touches it.

So anything talking to us over an IC is going to be some kind of 'T2
ecosystem' device that's been designed to handle our in

:149]

:147]

:146]
[148:

Sun Jun 16 01:05:37 2019 HMM drive-by issue noticed looking at the PRU
asm code: It appears that overlength inbound packets are not detected.
It appears the bInpByte idx simply wraps back to 0 and subsequent
bytes overwrite the packet starting from the beginning.  And (if and)
whenever a valid end-of-packet is seen, the current first bInpByte of
data will be delivered as a valid packet, with no clue that k*256
bytes were discarded at the front.

Seems we should blow sync if bInpByte wraps in setupForNextInputByte,
no????  Instead of the current:

    setupForNextInputByte:  ;; Here to initialize for reading another byte
            sendITag """SFNB""",CT.bInpByte ; report in
            add CT.bInpByte,  CT.bInpByte, 1 ; Move on to next byte
            ldi CT.bInpData, 0               ; Clear the byte data itself
            ldi CT.bInpBCnt, 0               ; And clear the bit in byte

don't we really want:

    setupForNextInputByte:  ;; Here to initialize for reading another byte
            sendITag """SFNB""",CT.bInpByte ; report in
            add CT.bInpByte,  CT.bInpByte, 1 ; Move on to next byte
            qbeq frameError, CT.bInpByte, 0  ; But blow sync if len > 255
            ldi CT.bInpData, 0               ; Clear the byte data itself
            ldi CT.bInpBCnt, 0               ; And clear the bit in byte

I THINK WE DO, but I'M NOT MAKING THAT CHANGE NOW.  Waiting until the
LKM code is stabilized before messing with the PRU code!

:148]
[150:

Sun Jun 16 04:30:20 2019 OK knocking off for now.  Still converting to
the new data structures; haven't even gotten them initted yet.  But
just a note to self: kfifo_in and similar return the number of 'items'
actually copied, and that's how one would check if an insertion
succeeded.  We're not currently doing anything with the value of
kfifo_in()'s as far as I can see.

:150]
[151:

Sun Jun 16 12:46:06 2019 Oh fudge.  The 'new' itc_pkt.c built clean.
So now we have to start trying it, and the real pain begins.  Let's
get all these bits off the keymaster first, of course.

:151][152:

Sun Jun 16 12:50:45 2019 OK well everything in T2-12 up through :151:
is now on the laptop too.  Time to 'make install', here, and watch
everything get shot to shoot?

Wait a sec.  We didn't write any code to actually implement the
bulk-vs-priority stuff, did we?  Doesn't that need to exist somewhere
before we could even DREAM of trying this stuff?  Hunh?[153:

Sun Jun 16 12:58:25 2019 Oh yeah, hmm.  All this depended on ALSO
setting up a whole nother kernel thread to be reading the outbound
kfifos and shipping off their packets.  That's where the
prioritization is to happen, yes?

Yes?

So what do we know about this mythical creature?  When all the OB
buffers are empty, it sleeps on its own private wait queue, and all
the userspace packet writers wake it up?

And also if there's no rpmsg buffers?  It sleeps then too?  On time?
I guess the packet cb could wake it up too, under the assumption the
cb must have just freed a buffer?

And when it awakes, it loops while the priority OB is non-empty and
rpmsg buffers are available, sending the priority packets.  If the
priority OB is empty around the loop, but rpmsg buffers are still
available, it checks the bulk OB once, and sends one bulk packet if
it's available, then goes back to the top of loop, checking the
priority OB again.

And is there only one of these mythical creatures?  Or two?  After all
there are two PRUs and two ITCPRUDeviceStates and therefore two
mPriorityOBs.  Would we really want to empty pru0's mPriorityOB before
even checking pru1's even once?  Well do these mythical creatures
preempt each other?  Even if they do, is that what we'd want?

Maybe just one kthread for this, and have it flip back and forth
between checking pru0 and pru1 buffers?  Use a static variable and
leave it on whichever side we stopped at least time?[154:

Sun Jun 16 13:46:27 2019 Well any way we slice it we're going to need
a thread, so we better get that set up.[155:

Sun Jun 16 14:21:49 2019 OK, so, we've been here before but here we
are again: The rpmsg API appears to provide no way to ask if a TX
buffer is immediately available, so there's no way to know whether a
rpmsg_send will block.

You say: Well but 'rpmsg_trysend' doesn't block!  Just use that!

But no no.  To use rpmsg_trysend you have to have a packet ready to
go, just in case it succeeds.  That means you have to take the packet
off its kfifo BEFORE YOU KNOW IF IT WILL GET SENT.  And if
rmpsg_trysend then returns -ENOMEM, what will you do with this
slimy slippery in-flight packet sitting in your hands?  You can't push
it back into your kfifo.[156:

Sun Jun 16 14:31:14 2019 Ah, okay, well, there's kfifo_peek.  So we
can copy the packet out, try to send it, then somehow flush it from
the kfifo if the send succeeds.[157:

Sun Jun 16 14:32:32 2019 And maybe we can use kfifo_skip to flush?
The fogging kfifo doc is SO DAMN MINIMAL, while its source code IS ALL
HOPELESSLY GNARLY MACROS.[158:

Sun Jun 16 14:36:17 2019 I suspect we can use kfifo_skip after kfifo_peek.

:158]

:157]

:156]

:155]

:154]

:153]

:152]
[159:

Sun Jun 16 14:57:50 2019 Well, made
shipAPacketToPRU(ITCPrudDeviceStatus*), but not clear if it's any kind
of sensible.  Still don't have a kthread set up yet.

:159]
[160:

Sun Jun 16 17:19:30 2019 OK have cuts at the OB packet shipper set
up.  Still need to kick it from the packet writers.[161:

Mon Jun 17 05:10:50 2019 OMG well it built again.  With big changes
including a writer wait queue to join the (previously implicitly)
reader wait queue in every ITCPacketBuffer.

And this is all still all totally UNTESTED!

Have we got any excuse not to try it?

Well, get the bits off the keymaster first, of course.

:161]

:160]
[162:

Mon Jun 17 05:14:08 2019 Well, here goes, first try at make install..

:162]
[163:

Mon Jun 17 05:17:49 2019 Well we blew up quick, but the machine is
still alive at the moment.  Problem is I installed, so if we reboot
now we're going to get the new blowing-up itc_pkt module right off the
bat, yes?  That sounds like a good way to corrupt the disk again.

In any case, for the record, it looks like an init-order problem:

    Jun 17 05:15:29 beaglebone kernel: [197010.416883]  remoteproc2: remote processor 4a338000.pru1 is now up
    Jun 17 05:15:29 beaglebone kernel: [197010.438478] virtio_rpmsg_bus virtio1: rpmsg host is online
    Jun 17 05:15:29 beaglebone kernel: [197010.444268] virtio_rpmsg_bus virtio1: creating channel itc-pkt addr 0x1f
    Jun 17 05:15:29 beaglebone kernel: [197010.484709] ZORG itc_pkt_init
    Jun 17 05:15:29 beaglebone kernel: [197010.506188] OOKE 00000000
    Jun 17 05:15:29 beaglebone kernel: [197010.511533] itcOBPktThreadRunner: Started
    Jun 17 05:15:29 beaglebone kernel: [197010.515972] ------------[ cut here ]------------
    Jun 17 05:15:29 beaglebone kernel: [197010.520713] kernel BUG at /home/t2/T2-12/pru/itcio/module/itc_pkt.c:151!
    Jun 17 05:15:29 beaglebone kernel: [197010.527533] Internal error: Oops - BUG: 0 [#1] SMP ARM
    Jun 17 05:15:29 beaglebone kernel: [197010.532783] Modules linked in: itc_pkt(O+) virtio_rpmsg_bus pru_rproc pruss pruss_intc 8021q garp mrp stp llc joydev fb_ili9486(C) ads7846 fbtft(C) ti_am335x_adc kfifo_buf industrialio ti_am335x_tsc ti_am335x_tscadc pwm_tiecap omap_sham omap_aes_driver omap_rng rng_core spi_omap2_mcspi evdev uio_pdrv_genirq uio usb_f_mass_storage usb_f_acm u_serial usb_f_ecm usb_f_rndis u_ether libcomposite cmemk(O) itc(O) spidev tieqep pwm_tiehrpwm [last unloaded: pruss]
    Jun 17 05:15:29 beaglebone kernel: [197010.573743] CPU: 0 PID: 18581 Comm: ITC_Pkt_Shipper Tainted: G         C O    4.4.54-ti-r93 #1
    Jun 17 05:15:29 beaglebone kernel: [197010.582480] Hardware name: Generic AM33XX (Flattened Device Tree)
    Jun 17 05:15:29 beaglebone kernel: [197010.588691] task: dacd2700 ti: da870000 task.ti: da870000
    Jun 17 05:15:29 beaglebone kernel: [197010.594253] PC is at itcOBPktThreadRunner+0x12c/0x144 [itc_pkt]
    Jun 17 05:15:29 beaglebone kernel: [197010.600288] LR is at 0xfce9c800
    Jun 17 05:15:29 beaglebone kernel: [197010.603533] pc : [<bf18e2f0>]    lr : [<fce9c800>]    psr: 600e0013
    Jun 17 05:15:29 beaglebone kernel: [197010.603533] sp : da871f20  ip : fce9ca5c  fp : da871f5c
    Jun 17 05:15:29 beaglebone kernel: [197010.615237] r10: 00000000  r9 : da870020  r8 : 00000000
    Jun 17 05:15:29 beaglebone kernel: [197010.620572] r7 : c0f97a88  r6 : 00000044  r5 : bf190b00  r4 : 00000000
    Jun 17 05:15:29 beaglebone kernel: [197010.627215] r3 : 00000002  r2 : 01f25107  r1 : 00000000  r0 : 711b2800
    Jun 17 05:15:29 beaglebone kernel: [197010.633862] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none
    Jun 17 05:15:29 beaglebone kernel: [197010.641117] Control: 10c5387d  Table: 9a800019  DAC: 00000051
    Jun 17 05:15:29 beaglebone kernel: [197010.646976] Process ITC_Pkt_Shipper (pid: 18581, stack limit = 0xda870218)
    Jun 17 05:15:29 beaglebone kernel: [197010.653969] Stack: (0xda871f20 to 0xda872000)
    Jun 17 05:15:29 beaglebone kernel: [197010.658442] 1f20: da870000 00000002 bf18e1c4 dc8ba636 00000000 00000000 dad963c0 00000000
    Jun 17 05:15:29 beaglebone kernel: [197010.666749] 1f40: bf18e1c4 00000000 00000000 00000000 da871fac da871f60 c0064f18 bf18e1d0
    Jun 17 05:15:29 beaglebone kernel: [197010.675056] 1f60: 00000000 dc0da700 00000000 00000000 00000000 da871f74 da871f74 00000000
    Jun 17 05:15:29 beaglebone kernel: [197010.683363] 1f80: 00000000 da871f84 da871f84 dc8ba636 dad963c0 c0064e1c 00000000 00000000
    Jun 17 05:15:29 beaglebone kernel: [197010.691669] 1fa0: 00000000 da871fb0 c0010f20 c0064e28 00000000 00000000 00000000 00000000
    Jun 17 05:15:29 beaglebone kernel: [197010.699976] 1fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    Jun 17 05:15:29 beaglebone kernel: [197010.708283] 1fe0: 00000000 00000000 00000000 00000000 00000013 00000000 00000000 00000000
    Jun 17 05:15:29 beaglebone kernel: [197010.716667] [<bf18e2f0>] (itcOBPktThreadRunner [itc_pkt]) from [<c0064f18>] (kthread+0xfc/0x114)
    Jun 17 05:15:29 beaglebone kernel: [197010.725603] [<c0064f18>] (kthread) from [<c0010f20>] (ret_from_fork+0x14/0x34)
    Jun 17 05:15:29 beaglebone kernel: [197010.732954] Code: e89daff0 e370000c 03a04001 eaffffe7 (e7f001f2) 
    Jun 17 05:15:29 beaglebone kernel: [197010.739170] ---[ end trace aa3c8da4e28da3e0 ]---
    Jun 17 05:15:29 beaglebone kernel: [197010.763124] KOOK 00000000
    Jun 17 05:15:29 beaglebone kernel: [197010.787399] OKKO

with itc_pkt.c:

148    /* return 0 if a priority packet shipped, 1 if a bulk packet shipped, or errno < 0 if problem */
149    static int shipAPacketToPRU(ITCPRUDeviceState * prudevstate) {
150      int ret;
151      BUG_ON(!prudevstate);
152      BUG_ON(!prudevstate->mRpmsgChannel);

So apparently the outbound packet shipper is getting to:

173    while ( (ret = shipAPacketToPRU(S.mPRUDeviceState[idx])) == 0 ) { /* empty */ }

before S.mPRUDeviceState[idx] is set up.  Does that seem plausible?
[164:

Mon Jun 17 05:23:22 2019 Certainly does, since the thread is started
at the end of initITCModuleState(), which is called before we even
alloc_chrDev_region and on and on.

So we need to move the thread boot to much later.  That doesn't answer
the question of how we're going to reboot here, since we now have a
lingering undestroyed device and we're getting errors about that..

:164]
:163]
[165:

Mon Jun 17 05:29:39 2019 Moving off a new copy of bits.

:165]
[166:

Mon Jun 17 05:33:21 2019 Well I'm not sure how to avoid a reboot at
this point, and it totally could be all-bets-off when it happens.

:166]
[167:

Mon Jun 17 05:38:54 2019 OK, going for it.  Copied files I think.  At
least I have the serial port plugged in, perhaps that will help -- if
the boot gets far enough to even let me in that way..

:167]
[168:

Mon Jun 17 05:43:57 2019 Yikes it came back up.  Didn't see any
obvious blowups in the serial debug.  Let's take a closer look at
syslog.. [169:

Mon Jun 17 05:45:10 2019 No way.  No way.  The neighbors are seeing
packet sync with the keymaster?  No Way.  We must not have actually
successfully installed the new module.  We must still be running the
old thing untouched.[170:

Mon Jun 17 05:48:46 2019 Well.  Well.  I don't think there's any way
that this line:

    Jun 17 05:41:24 beaglebone kernel: [   42.703073] ZERGIN: makeITCCharDeviceState(dc3a1208,17228,0,dc44bb74) for itc!pru0

could have come from the old itc_pkt module.  The whole idea of having
a makeITCCharDeviceState function is part of the new thing,
right?[171:

Mon Jun 17 05:52:26 2019 Yeah, it totally is.  So it seems we're
running the new version of itc_pkt.ko and at least bulk transport via
/dev/itc/packets is still working well enough for the cdm neighbors to
think we're alive and vice-versa.  Holy crab.

:171]

:170]

:169]

:168]
[172:

Mon Jun 17 05:57:07 2019 Here's something to debug:

    root@beaglebone:/home/t2/T2-12/pru/itcio/notes# echo -e "\xa1foo" >/dev/itc/mfm 
    bash: echo: write error: No route to host
    root@beaglebone:/home/t2/T2-12/pru/itcio/notes# echo -e "\xa2foo" >/dev/itc/mfm 

So considering :133: above, I think \xa1 is a packet header meaning
"standard, mfmt, in direction 1", which is I think NE.  And indeed
keymaster's NE is currently unconnected.  And I think \xa2 should be
going ET.

And I thought that second echo was just hanging doing nothing, but
actually from the t2viz display it appears to be blasting crap east at
'unprecedented speeds'.  With claims like '1554190>308095' -- 1.5MB
sent in 300K packets??  Has to be total BS -- not least of which
because the tile-to-the-east is reporting nothing untoward inbound.

Going to ^C the echo..[173:

Mon Jun 17 06:03:05 2019 ^C appears to do nothing.

Going to kill the shell it's in.[174:

Mon Jun 17 06:03:58 2019 Well, that stopped it.  But here's some
evidence:

    root@beaglebone:/home/t2/T2-12/pru/itcio/notes# cat /sys/class/itc_pkt/statistics 
    dir bsent brcvd psent prcvd psan sfan toan
    0 0 0 0 0 0 0 0
    1 0 0 0 0 0 0 0
    2 599216123 42 119842541 14 1 0 0
    3 3030 42 69 14 1 0 0
    4 0 0 0 0 0 0 0
    5 2737 48 62 16 1 0 0
    6 0 0 0 0 0 0 0
    7 0 0 0 0 0 0 0
    root@beaglebone:/home/t2/T2-12/pru/itcio/notes# 

which also reminds us that we're going to want to redo the statistics
processing throughout to separate bulk and priority traffic.

:174]

:173]

:172]
[175:

Mon Jun 17 06:10:15 2019 Actually, it looks like the neighbors may not
be hearing anything from the keymaster linux level.  They're getting
to packet sync, so the doors are open, but I see no evidence that any
actual packets are actually arriving.  So okay that's a little more
plausible. 

:175][176:

Mon Jun 17 06:13:07 2019 Turning on debugging briefly gets us like
this:

    root@beaglebone:/home/t2/T2-12/pru/itcio/notes# echo f > /sys/class/itc_pkt/debug ; sleep 10; echo 0 > /sys/class/itc_pkt/debug
    Jun 17 06:12:45 beaglebone kernel: [ 1866.374887] set debug f
    Jun 17 06:12:45 beaglebone kernel: [ 1866.680119] <pru0: 83 03 41                                         ..A
    Jun 17 06:12:45 beaglebone kernel: [ 1866.696080] <pru0: c3 4d 30 33 30 3a 70 30 20 30 30 30 30 30 30 30  .M030:p0 0000000
    Jun 17 06:12:45 beaglebone kernel: [ 1866.703995] <pru0: 30                                               0
    Jun 17 06:12:45 beaglebone kernel: [ 1866.710630] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 06:12:45 beaglebone kernel: [ 1866.718459] <pru1: 37                                               7
    Jun 17 06:12:46 beaglebone kernel: [ 1867.042204] Routing '85'+55 packet to PRU0
    Jun 17 06:12:46 beaglebone kernel: [ 1867.444910] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 06:12:46 beaglebone kernel: [ 1867.452849] <pru1: 37                                               7

so we're getting to itc_pkt.c:585 

:176]
[177:

Mon Jun 17 06:24:48 2019 OK I hadn't initted a 'ret' to zero which
conceivably could have keep us from trying to ship a packet.  Getting
bits off again then trying a reinstall.. with no users of itc_pkt
according to lsmod..

:177][178:

Mon Jun 17 06:28:24 2019 OK, that got us to:

    Jun 17 06:27:42 beaglebone kernel: [ 2763.423328] Unable to handle kernel NULL pointer dereference at virtual address 00000000
    Jun 17 06:27:42 beaglebone kernel: [ 2763.431624] pgd = da87c000
    Jun 17 06:27:42 beaglebone kernel: [ 2763.434419] [00000000] *pgd=00000000
    Jun 17 06:27:42 beaglebone kernel: [ 2763.438069] Internal error: Oops: 5 [#2] SMP ARM
    Jun 17 06:27:42 beaglebone kernel: [ 2763.442712] Modules linked in: joydev fb_ili9486(C) fbtft(C) ads7846 ti_am335x_adc kfifo_buf industrialio ti_am335x_tsc ti_am335x_tscadc pwm_tiecap omap_aes_driver omap_sham omap_rng rng_core spi_omap2_mcspi evdev uio_pdrv_genirq uio 8021q garp mrp stp llc usb_f_mass_storage usb_f_acm u_serial usb_f_ecm usb_f_rndis u_ether libcomposite cmemk(O) itc_pkt(O-) virtio_rpmsg_bus itc(O) spidev tieqep pwm_tiehrpwm pru_rproc pruss_intc pruss
    Jun 17 06:27:42 beaglebone kernel: [ 2763.481555] CPU: 0 PID: 6546 Comm: modprobe Tainted: G      D  C O    4.4.54-ti-r93 #1
    Jun 17 06:27:42 beaglebone kernel: [ 2763.489507] Hardware name: Generic AM33XX (Flattened Device Tree)
    Jun 17 06:27:42 beaglebone kernel: [ 2763.495629] task: dc255b00 ti: dc3e6000 task.ti: dc3e6000
    Jun 17 06:27:42 beaglebone kernel: [ 2763.501067] PC is at exit_creds+0x2c/0x90
    Jun 17 06:27:42 beaglebone kernel: [ 2763.505112] LR is at __put_task_struct+0x60/0x148
    Jun 17 06:27:42 beaglebone kernel: [ 2763.509839] pc : [<c0067544>]    lr : [<c0040140>]    psr: 60010013
    Jun 17 06:27:42 beaglebone kernel: [ 2763.509839] sp : dc3e7ee0  ip : dc3e7ef8  fp : dc3e7ef4
    Jun 17 06:27:42 beaglebone kernel: [ 2763.521369] r10: 00000000  r9 : dc3e6000  r8 : c0011024
    Jun 17 06:27:42 beaglebone kernel: [ 2763.526616] r7 : 00000800  r6 : 0000000b  r5 : dacd750c  r4 : dacd7500
    Jun 17 06:27:42 beaglebone kernel: [ 2763.533173] r3 : 00000000  r2 : 00000000  r1 : dacd7500  r0 : 00000000
    Jun 17 06:27:42 beaglebone kernel: [ 2763.539732] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none
    Jun 17 06:27:42 beaglebone kernel: [ 2763.546900] Control: 10c5387d  Table: 9a87c019  DAC: 00000051
    Jun 17 06:27:42 beaglebone kernel: [ 2763.552671] Process modprobe (pid: 6546, stack limit = 0xdc3e6218)
    Jun 17 06:27:42 beaglebone kernel: [ 2763.558880] Stack: (0xdc3e7ee0 to 0xdc3e8000)
    Jun 17 06:27:42 beaglebone kernel: [ 2763.563265] 7ee0: 00000000 dacd7500 dc3e7f0c dc3e7ef8 c0040140 c0067524 dacd7500 dacd750c
    Jun 17 06:27:42 beaglebone kernel: [ 2763.571486] 7f00: dc3e7f2c dc3e7f10 c00655ac c00400ec bf03db00 bf03d648 8104d20c 00000800
    Jun 17 06:27:42 beaglebone kernel: [ 2763.579706] 7f20: dc3e7f44 dc3e7f30 bf03c0a8 c00654e4 c0f97a88 bf03d900 dc3e7fa4 dc3e7f48
    Jun 17 06:27:42 beaglebone kernel: [ 2763.587927] 7f40: c00d91c4 bf03c090 5f637469 00746b70 dc3e7f6c dc3e7f60 c01c5388 c0062f50
    Jun 17 06:27:42 beaglebone kernel: [ 2763.596148] 7f60: dc3e7f8c dc3e7f70 c0062f50 c0015220 dc3e6010 c0011024 dc3e7fb0 dc3e6000
    Jun 17 06:27:42 beaglebone kernel: [ 2763.604368] 7f80: 003e7fac dc8ba636 8104d1d8 8104d1d8 00000001 00000081 00000000 dc3e7fa8
    Jun 17 06:27:42 beaglebone kernel: [ 2763.612588] 7fa0: c0010e60 c00d9020 8104d1d8 8104d1d8 8104d20c 00000800 fc0e4200 00000000
    Jun 17 06:27:42 beaglebone kernel: [ 2763.620808] 7fc0: 8104d1d8 8104d1d8 00000001 00000081 00000000 00000001 8104d1d8 beffd6f4
    Jun 17 06:27:42 beaglebone kernel: [ 2763.629028] 7fe0: b6eca521 beffc31c 7f60f857 b6eca526 80010030 8104d20c 00000000 00000000
    Jun 17 06:27:42 beaglebone kernel: [ 2763.637266] [<c0067544>] (exit_creds) from [<c0040140>] (__put_task_struct+0x60/0x148)
    Jun 17 06:27:42 beaglebone kernel: [ 2763.645238] [<c0040140>] (__put_task_struct) from [<c00655ac>] (kthread_stop+0xd4/0x1b4)
    Jun 17 06:27:42 beaglebone kernel: [ 2763.653413] [<c00655ac>] (kthread_stop) from [<bf03c0a8>] (itc_pkt_exit+0x24/0x44 [itc_pkt])
    Jun 17 06:27:42 beaglebone kernel: [ 2763.661932] [<bf03c0a8>] (itc_pkt_exit [itc_pkt]) from [<c00d91c4>] (SyS_delete_module+0x1b0/0x23c)
    Jun 17 06:27:42 beaglebone kernel: [ 2763.671038] [<c00d91c4>] (SyS_delete_module) from [<c0010e60>] (ret_fast_syscall+0x0/0x44)
    Jun 17 06:27:42 beaglebone kernel: [ 2763.679349] Code: e5900414 e5842414 f57ff05b f5d0f000 (e1902f9f) 
    Jun 17 06:27:42 beaglebone kernel: [ 2763.685628] ---[ end trace a8afe9481c0ec8de ]---

which kind of looks like it died removing the old module rather than
adding the new one.  Especially considering:

    grep cmemk /etc/modules-load.d/t2_12_modules.conf || echo cmemk >> /etc/modules-load.d/t2_12_modules.conf
    cmemk
    depmod
    modprobe -r itc_pkt || exit 0
    Segmentation fault
    modprobe -r pru_rproc || exit 0
    modprobe: FATAL: Module pru_rproc is in use.
    modprobe pru_rproc || exit 0

from the *compilation* window.

So, a null pointer deref during kthread_stop

:178]
[179:

Mon Jun 17 06:39:17 2019 Trying again with more defenses around kthread_stop.

:179]
[180:

Mon Jun 17 06:42:36 2019 Now we see this on initial boot:

    Jun 17 06:41:05 beaglebone kernel: [   12.875224] ITC WT i11 -> i00
    Jun 17 06:41:05 beaglebone kernel: [   12.922379] ZORG itc_pkt_init
    Jun 17 06:41:05 beaglebone kernel: [   12.925447] OOKE 00000000
    Jun 17 06:41:05 beaglebone kernel: [   12.976010] KOOK 00000000
    Jun 17 06:41:05 beaglebone kernel: [   13.023974] OKKO
    Jun 17 06:41:05 beaglebone kernel: [   13.058114] KOKO
    Jun 17 06:41:05 beaglebone kernel: [   13.077952] KKOO
    Jun 17 06:41:05 beaglebone kernel: [   13.079850] itcOBPktThreadRunner: Started
    Jun 17 06:41:05 beaglebone kernel: [   13.084133] ------------[ cut here ]------------
    Jun 17 06:41:05 beaglebone kernel: [   13.088781] kernel BUG at /home/t2/T2-12/pru/itcio/module/itc_pkt.c:161!
    Jun 17 06:41:05 beaglebone kernel: [   13.095509] Internal error: Oops - BUG: 0 [#1] SMP ARM
    Jun 17 06:41:05 beaglebone kernel: [   13.100670] Modules linked in: itc_pkt(O) virtio_rpmsg_bus itc(O) spidev tieqep pwm_tiehrpwm pru_rproc pruss_intc pruss
    Jun 17 06:41:05 beaglebone kernel: [   13.111581] CPU: 0 PID: 595 Comm: ITC_Pkt_Shipper Tainted: G           O    4.4.54-ti-r93 #1
    Jun 17 06:41:05 beaglebone kernel: [   13.120052] Hardware name: Generic AM33XX (Flattened Device Tree)
    Jun 17 06:41:05 beaglebone kernel: [   13.126173] task: dc749380 ti: dc534000 task.ti: dc534000
    Jun 17 06:41:05 beaglebone kernel: [   13.131637] PC is at itcOBPktThreadRunner+0x12c/0x144 [itc_pkt]
    Jun 17 06:41:05 beaglebone kernel: [   13.137581] LR is at 0xafbf8800
    Jun 17 06:41:05 beaglebone kernel: [   13.140735] pc : [<bf03b2f0>]    lr : [<afbf8800>]    psr: 60000013
    Jun 17 06:41:05 beaglebone kernel: [   13.140735] sp : dc535f20  ip : afbf8f55  fp : dc535f5c
    Jun 17 06:41:05 beaglebone kernel: [   13.152260] r10: 00000000  r9 : dc534020  r8 : 00000001
    Jun 17 06:41:05 beaglebone kernel: [   13.157505] r7 : c0f97a88  r6 : 00000045  r5 : bf03dc40  r4 : 00000000
    Jun 17 06:41:05 beaglebone kernel: [   13.164057] r3 : 00000002  r2 : 8a5ed0ec  r1 : 00000001  r0 : c0777ce2
    Jun 17 06:41:05 beaglebone kernel: [   13.170613] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none
    Jun 17 06:41:05 beaglebone kernel: [   13.177776] Control: 10c5387d  Table: 9ade8019  DAC: 00000051
    Jun 17 06:41:05 beaglebone kernel: [   13.183545] Process ITC_Pkt_Shipper (pid: 595, stack limit = 0xdc534218)
    Jun 17 06:41:05 beaglebone kernel: [   13.190274] Stack: (0xdc535f20 to 0xdc536000)
    Jun 17 06:41:05 beaglebone kernel: [   13.194654] 5f20: dc534000 00000002 bf03b1c4 dc8ba636 00000000 00000000 dc53a940 00000000
    Jun 17 06:41:05 beaglebone kernel: [   13.202869] 5f40: bf03b1c4 00000000 00000000 00000000 dc535fac dc535f60 c0064f18 bf03b1d0
    Jun 17 06:41:05 beaglebone kernel: [   13.211083] 5f60: 00000000 dc0da700 00000000 00000000 00000000 dc535f74 dc535f74 00000000
    Jun 17 06:41:05 beaglebone kernel: [   13.219297] 5f80: 00000000 dc535f84 dc535f84 dc8ba636 dc53a940 c0064e1c 00000000 00000000
    Jun 17 06:41:05 beaglebone kernel: [   13.227513] 5fa0: 00000000 dc535fb0 c0010f20 c0064e28 00000000 00000000 00000000 00000000
    Jun 17 06:41:05 beaglebone kernel: [   13.235727] 5fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    Jun 17 06:41:05 beaglebone kernel: [   13.243942] 5fe0: 00000000 00000000 00000000 00000000 00000013 00000000 00000000 00000000
    Jun 17 06:41:05 beaglebone kernel: [   13.252203] [<bf03b2f0>] (itcOBPktThreadRunner [itc_pkt]) from [<c0064f18>] (kthread+0xfc/0x114)
    Jun 17 06:41:05 beaglebone kernel: [   13.261043] [<c0064f18>] (kthread) from [<c0010f20>] (ret_from_fork+0x14/0x34)
    Jun 17 06:41:05 beaglebone kernel: [   13.268302] Code: e89daff0 e370000c 03a04001 eaffffe7 (e7f001f2) 
    Jun 17 06:41:05 beaglebone kernel: [   13.274426] ---[ end trace 77ee554a16f83a65 ]---

[181:

Mon Jun 17 06:43:53 2019 Suggesting the thread is still starting too
early, and I guess obviously we need to delay starting the OB shipper
until the PRU device probing happens, and all the ITCPRUDeviceState
initting actually happens.[182:

Mon Jun 17 06:48:58 2019 OK, moving it until the second PRU has been
probed and set up.

Bits off and going again.

:182]

:181]
:180]
[183:

Mon Jun 17 07:04:07 2019 Well took a few boots to flush out some FS
corruption muhmoh but now we're back up.  And the OB shipper seems to
be starting plenty late now:

    Jun 17 06:50:03 beaglebone kernel: [   42.438025] DEBUG1 00000031 PRU1 Releasing the hounds
    Jun 17 06:50:03 beaglebone kernel: [   42.449927]  remoteproc1: registered virtio0 (type 7)
    Jun 17 06:50:03 beaglebone kernel: [   42.455227] pru-rproc 4a338000.pru1: PRU rproc node /ocp/pruss@4a300000/pru1@4a338000 probed successfully
    Jun 17 06:50:03 beaglebone kernel: [   42.465883] fb_ili9486 spi1.0: Display update: 759 kB/s, fps=0

not there, on the first pru probe, but here:

    Jun 17 06:50:03 beaglebone kernel: [   42.551570] RECTOBLURGE back with buf=''
    Jun 17 06:50:03 beaglebone kernel: [   42.551802]  remoteproc2: registered virtio1 (type 7)
    Jun 17 06:50:03 beaglebone kernel: [   42.551912] pru-rproc 4a334000.pru0: PRU rproc node /ocp/pruss@4a300000/pru0@4a334000 probed successfully
    Jun 17 06:50:03 beaglebone kernel: [   42.561960] KKOO
    Jun 17 06:50:03 beaglebone kernel: [   42.562052] DEBUG0 00000031 PRU0 Releasing the hounds
    Jun 17 06:50:03 beaglebone kernel: [   42.562163] itcOBPktThreadRunner: Started

on the last.

But we still see no signs that the neighbors are getting any packets
from the keymaster..  Trying the debug snapshot..

    root@beaglebone:~# echo f > /sys/class/itc_pkt/debug ; sleep 10; echo 0 > /sys/class/itc_pkt/debug
    Jun 17 07:07:41 beaglebone kernel: [  487.828548] set debug f
    Jun 17 07:07:42 beaglebone kernel: [  488.182558] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 07:07:42 beaglebone kernel: [  488.190434] <pru1: 37                                               7
    Jun 17 07:07:42 beaglebone kernel: [  488.416216] <pru0: c3 4d 30 33 30 3a 70 30 20 30 30 30 30 30 30 30  .M030:p0 0000000
    Jun 17 07:07:42 beaglebone kernel: [  488.424159] <pru0: 30                                               0
    Jun 17 07:07:42 beaglebone kernel: [  488.922115] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 07:07:42 beaglebone kernel: [  488.930028] <pru1: 37                                               7
    Jun 17 07:07:43 beaglebone kernel: [  489.376411] <pru0: c3 4d 30 33 30 3a 70 30 20 30 30 30 30 30 30 30  .M030:p0 0000000
    Jun 17 07:07:43 beaglebone kernel: [  489.384306] <pru0: 30                                               0
    Jun 17 07:07:43 beaglebone kernel: [  489.661624] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 07:07:43 beaglebone kernel: [  489.669527] <pru1: 37                                               7
    Jun 17 07:07:44 beaglebone kernel: [  490.336217] <pru0: c3 4d 30 33 30 3a 70 30 20 30 30 30 30 30 30 30  .M030:p0 0000000
    Jun 17 07:07:44 beaglebone kernel: [  490.344120] <pru0: 30                                               0
    Jun 17 07:07:44 beaglebone kernel: [  490.401055] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 07:07:44 beaglebone kernel: [  490.408961] <pru1: 37                                               7
    Jun 17 07:07:44 beaglebone kernel: [  490.485480] Routing bulk '83'+62 packet to PRU0
    Jun 17 07:07:45 beaglebone kernel: [  491.140735] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 07:07:45 beaglebone kernel: [  491.148686] <pru1: 37                                               7
    Jun 17 07:07:45 beaglebone kernel: [  491.296629] <pru0: c3 4d 30 33 30 3a 70 30 20 30 30 30 30 30 30 30  .M030:p0 0000000
    Jun 17 07:07:45 beaglebone kernel: [  491.304549] <pru0: 30                                               0
    Jun 17 07:07:45 beaglebone kernel: [  491.879957] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 07:07:45 beaglebone kernel: [  491.887873] <pru1: 37                                               7
    Jun 17 07:07:46 beaglebone kernel: [  492.006143] Routing bulk '83'+51 packet to PRU0
    Jun 17 07:07:46 beaglebone kernel: [  492.256712] <pru0: c3 4d 30 33 30 3a 70 30 20 30 30 30 30 30 30 30  .M030:p0 0000000
    Jun 17 07:07:46 beaglebone kernel: [  492.264616] <pru0: 30                                               0
    Jun 17 07:07:46 beaglebone kernel: [  492.619081] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 07:07:46 beaglebone kernel: [  492.626972] <pru1: 37                                               7
    Jun 17 07:07:47 beaglebone kernel: [  493.216773] <pru0: c3 4d 30 33 30 3a 70 30 20 30 30 30 30 30 30 30  .M030:p0 0000000
    Jun 17 07:07:47 beaglebone kernel: [  493.224675] <pru0: 30                                               0
    Jun 17 07:07:47 beaglebone kernel: [  493.358417] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 07:07:47 beaglebone kernel: [  493.366288] <pru1: 37                                               7
    Jun 17 07:07:48 beaglebone kernel: [  494.034790] Routing bulk '85'+61 packet to PRU0
    Jun 17 07:07:48 beaglebone kernel: [  494.097953] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 07:07:48 beaglebone kernel: [  494.105862] <pru1: 37                                               7
    Jun 17 07:07:48 beaglebone kernel: [  494.176787] <pru0: c3 4d 30 33 30 3a 70 30 20 30 30 30 30 30 30 30  .M030:p0 0000000
    Jun 17 07:07:48 beaglebone kernel: [  494.184733] <pru0: 30                                               0
    Jun 17 07:07:48 beaglebone kernel: [  494.837177] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 07:07:48 beaglebone kernel: [  494.845099] <pru1: 37                                               7
    Jun 17 07:07:49 beaglebone kernel: [  495.136659] <pru0: c3 4d 30 33 30 3a 70 30 20 30 30 30 30 30 30 30  .M030:p0 0000000
    Jun 17 07:07:49 beaglebone kernel: [  495.144566] <pru0: 30                                               0
    Jun 17 07:07:49 beaglebone kernel: [  495.576428] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 07:07:49 beaglebone kernel: [  495.584345] <pru1: 37                                               7
    Jun 17 07:07:50 beaglebone kernel: [  496.096843] <pru0: c3 4d 30 33 30 3a 70 30 20 30 30 30 30 30 30 30  .M030:p0 0000000
    Jun 17 07:07:50 beaglebone kernel: [  496.104747] <pru0: 30                                               0
    Jun 17 07:07:50 beaglebone kernel: [  496.315700] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 07:07:50 beaglebone kernel: [  496.323616] <pru1: 37                                               7
    Jun 17 07:07:51 beaglebone kernel: [  497.055381] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 07:07:51 beaglebone kernel: [  497.063362] <pru1: 37                                               7
    Jun 17 07:07:51 beaglebone kernel: [  497.070024] <pru0: c3 4d 30 33 30 3a 70 30 20 30 30 30 30 30 30 30  .M030:p0 0000000
    Jun 17 07:07:51 beaglebone kernel: [  497.077870] <pru0: 30                                               0
    Jun 17 07:07:51 beaglebone kernel: [  497.794731] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000
    Jun 17 07:07:51 beaglebone kernel: [  497.802629] <pru1: 37                                               7
    Jun 17 07:07:51 beaglebone kernel: [  497.867679] set debug 0
    root@beaglebone:~# 

[184:

Mon Jun 17 07:08:50 2019 It's unfortunate that the keymaster is
currently connected ET, SE, and SW, which turn out, I believe to all
be serviced by PRU0.  So the fact that all the bulk routing is going
that way is probably not a problem..

:184]
:183]
[185:

Mon Jun 17 07:16:38 2019 Adding DBGPRINTK's inside the OB shipper
flow. [186:

Mon Jun 17 07:17:13 2019 Going again.[187:

Mon Jun 17 07:19:13 2019 Wow it appears we might have actually shut
down clean:

    Jun 17 07:18:46 beaglebone systemd[1]: Started Boot time cdm processing.
    Jun 17 07:18:53 beaglebone kernel: [ 1159.965340] itcOBPktThreadRunner: Stopping by request
    Jun 17 07:18:54 beaglebone kernel: [ 1159.994147] ti-pruss 4a300000.pruss: unconfigured system_events = 0x0000000000030000 host_intr = 0x00000005
    Jun 17 07:18:54 beaglebone kernel: [ 1160.004097]  remoteproc2: stopped remote processor 4a334000.pru0
    Jun 17 07:18:54 beaglebone systemd-udevd[566]: Network interface NamePolicy= disabled on kernel command line, ignoring.
    Jun 17 07:18:54 beaglebone kernel: [ 1160.068110] virtio_rpmsg_bus virtio0: msg received with no recipient
    Jun 17 07:18:54 beaglebone kernel: [ 1160.087416] ti-pruss 4a300000.pruss: unconfigured system_events = 0x00000000000c0000 host_intr = 0x0000000a
    Jun 17 07:18:54 beaglebone kernel: [ 1160.097374]  remoteproc1: stopped remote processor 4a338000.pru1
    Jun 17 07:18:54 beaglebone kernel: [ 1160.251922] pru-rproc 4a334000.pru0: pru_rproc_remove: removing rproc 4a334000.pru0
    Jun 17 07:18:54 beaglebone kernel: [ 1160.288201]  remoteproc2: releasing 4a334000.pru0
    Jun 17 07:18:54 beaglebone kernel: [ 1160.312051] pru-rproc 4a338000.pru1: pru_rproc_remove: removing rproc 4a338000.pru1
    Jun 17 07:18:54 beaglebone kernel: [ 1160.348193]  remoteproc1: releasing 4a338000.pru1
    Jun 17 07:18:54 beaglebone kernel: [ 1160.384129] ti-pruss 4a300000.pruss: remove PRU cores and other child platform devices

by killing cdm.sh and cdm.pl in time that itc_pkt had no users when
the make install got to the modprobe -r..[188:

Mon Jun 17 07:21:14 2019 Trying the debug snapshot..

:188]

:187]

:186]

:185]
[189:

Mon Jun 17 07:21:52 2019 Hmm, no sign of routing..  Oh yeah I guess
we'd have to start cdm back up..[190:

Mon Jun 17 07:28:43 2019 Well, now we see stuff like:

    Jun 17 07:27:05 beaglebone kernel: [ 1651.678114] <pru0: 30                                               0
    Jun 17 07:27:06 beaglebone kernel: [ 1652.059504] Routing bulk '82'+62 packet to PRU0
    Jun 17 07:27:06 beaglebone kernel: [ 1652.138133] Trying to send '82'+1 packet to via prudev da8f8010
    Jun 17 07:27:06 beaglebone kernel: [ 1652.149840] >pru: 82                                               .

Which looks like the rpmsg_trysend worked, but that the pktlen was
messed up..[191:


Mon Jun 17 07:34:49 2019 Ah you dog

       /* show the size of the next record in the fifo */
       printk(KERN_INFO "fifo peek len: %u\n", kfifo_peek_len(&test));
   
from https://elixir.bootlin.com/linux/v4.4.54/source/samples/kfifo/record-example.c

It's kfifo_peek_len to get the next length.[192:

Mon Jun 17 07:36:49 2019 Going again.

:192]

:191]

:190]

:189]
[193:

Mon Jun 17 08:21:55 2019 And it's not kfifo_peek() I wanted either.
Of course I wanted kfifo_out_peek().  Thanks for the fantastic
documentation there, Stef.

Anyway.

Now we get to this:

    Jun 17 08:21:03 beaglebone kernel: [ 4889.887301] <pru0: 30                                               0
    Jun 17 08:21:04 beaglebone kernel: [ 4890.191605] Routing bulk '82'+59 packet to PRU0
    Jun 17 08:21:04 beaglebone kernel: [ 4890.196334] Copied 59 from user space, count 59, avail 255, len 60, ret 0
    Jun 17 08:21:04 beaglebone kernel: [ 4890.203295] Trying to send '82'+59 packet to via prudev da860010
    Jun 17 08:21:04 beaglebone kernel: [ 4890.215901] >pru: 82 46 4f 4f 50 4f 4f 44 4f 50 44 73 64 6b 73 64  .FOOPOODOPDsdksd
    Jun 17 08:21:04 beaglebone kernel: [ 4890.223719] >pru: 6b 6c 73 64 6b 6c 64 73 6b 6c 64 73 6b 6c 64 73  klsdkldskldsklds
    Jun 17 08:21:04 beaglebone kernel: [ 4890.231497] >pru: 6b 6c 64 73 6b 6c 64 73 6b 6c 73 64 6b 6c 73 64  kldskldsklsdklsd
    Jun 17 08:21:04 beaglebone kernel: [ 4890.239224] >pru: 6b 6c 73 64 6b 6c 64 73 6c 6b 0a                 klsdkldslk.
    Jun 17 08:21:04 beaglebone kernel: [ 4890.394649] <pru1: c3 4d 31 33 37 3a 70 31 20 30 30 30 30 30 30 30  .M137:p1 0000000

so we finally have evidence a packet is getting shipped to a PRU.

Let's start up cdm.pl again..[194:

Mon Jun 17 08:27:23 2019 Well, I think cdm.pl is talking to its peers
again.  I think it's time to get bits off one more time, and then get
on about the day.

:194]

:193]
[195:

Mon Jun 17 13:46:09 2019 OK, back in the trenches.  Let's debug just a
little more /dev/itc/mfm before nap time.

:195]
[196:

Mon Jun 17 18:03:41 2019 So have a couple hours here only to see if we
can get something we could show.  During nap time the bulk input
buffers filled up with announcements and such from the neighbors, and
I woke up plenty of:

 ..
    Jun 17 18:00:04 beaglebone kernel: [12366.922522] (ET) Inbound queue full, dropping bulk len=22 packet
    Jun 17 18:00:14 beaglebone kernel: [12377.470180] (NE) Inbound queue full, dropping bulk len=22 packet
    Jun 17 18:00:18 beaglebone kernel: [12381.184095] (ET) Inbound queue full, dropping bulk len=22 packet
    Jun 17 18:00:33 beaglebone kernel: [12395.494024] (NE) Inbound queue full, dropping bulk len=22 packet
    Jun 17 18:00:34 beaglebone kernel: [12396.917456] (ET) Inbound queue full, dropping bulk len=22 packet
    Jun 17 18:00:44 beaglebone kernel: [12406.801044] (ET) Inbound queue full, dropping bulk len=3 packet
    Jun 17 18:00:44 beaglebone kernel: [12406.807099] (ET) Inbound queue full, dropping bulk len=22 packet
    Jun 17 18:00:49 beaglebone kernel: [12411.519870] (NE) Inbound queue full, dropping bulk len=22 packet
    Jun 17 18:00:56 beaglebone kernel: [12419.186594] (ET) Inbound queue full, dropping bulk len=22 packet
    Jun 17 18:00:57 beaglebone kernel: [12419.603542] (NE) Inbound queue full, dropping bulk len=3 packet
  ..

Which I can see are going to need to be put under a debug flag
eventually but are nice to see now.

But, still seem to be seeing kfifo_out_peek() returning 0 after
kfifo_peek_len returned() non-zero, and trying to debug that.
Changing from a BUG_ON(1) to a printk KERN_ERR when it happens, trying
to get more information.

Bits off again.

:196]
[197:

Mon Jun 17 18:34:22 2019 OK, so, a couple things.  Even though we're
getting all these messages, we are not actually stuck:

    Jun 17 18:28:21 beaglebone kernel: [  887.837829] OB pktlen 3 but kfifo_out_peek returned 0 (kfifo dc473318, prudev dc470010)
    Jun 17 18:28:22 beaglebone kernel: [  887.949815] OB pktlen 3 but kfifo_out_peek returned 0 (kfifo dc473318, prudev dc470010)
    Jun 17 18:28:22 beaglebone kernel: [  888.166024] OB pktlen 16 but kfifo_out_peek returned 0 (kfifo dc473318, prudev dc470010)
    Jun 17 18:28:22 beaglebone kernel: [  888.277882] OB pktlen 16 but kfifo_out_peek returned 0 (kfifo dc473318, prudev dc470010)

and in fact we can see len 3 or 16 or whatever packets actually moving
in t2viz around the time the pktlen changes in syslog.  And, the delay
between messages often appears to be about a 100 ms, in line with the

    int waitms = 100;                /* producers kick us so timeout should be rare backstop */
    set_current_state(TASK_RUNNING);
    if (shipCurrentOBPackets()) waitms = 1; /* Except short wait if txbufs ran out */
    msleep_interruptible(waitms);      

in itcOBPktThreadRunner.

:197]
[198:

Mon Jun 17 19:00:38 2019 Now trying the hypothesis that you must see
kfifo_len() non-zero before you can get a valid result from
kfifo_peek_len().

Bits off.

:198]
[199:

Mon Jun 17 21:22:32 2019 Holy moly well we've gotten to this:

    root@beaglebone:/home/t2# ./mfmiospike 
    Primed pump
    Got packet ' £HELOME'
    root@beaglebone:/home/t2#

where mfmiospike sent itself a packet via external loopback, through
/dev/itc/mfm.  So that's a little first, and, here are 9:30ishpm, it
keeps hope alive that I might be able to demonstrate inter-mfmt2
interactions, however lamely, by tonight.

So what I want right now now now is an inter MFMT2 packet format that
has a time-to-live byte and a reflooding property.  We'll send it to
everybody that we didn't get it from, counting down its time-to-live.

Aaand when do we actually do the command that's flooding out to
everybody?  Do we have a command index spinner and we do it once for
each new command?  Guess so.


:199]
[200:

Mon Jun 17 22:44:13 2019 OK, all that's starting to work, in
'mfmiospike.c', which we've just moved to /home/t2/T2-12/apps/t2/ so
we can save and build it without rebuilding all of MFM..  We're way
running out of time here.

Bits off.

:200]
[201:

Wed Jun 19 02:31:22 2019 OK so we got past t2sup-ep236 -- but we only
have a couple days really to work this week so we need to bear down
again here.  Another plate of DO handles is cooking on the 3d printer.
So: Re-view then to-do.  [202: Wed Jun 19 02:34:28 2019 

 - OK, the :198: 'don't call kfifo_peek_len() unless kfifo_len() != 0'
    hypothesis seems to be holding up so far.

 - We implemented a 'struct FlashTraffic', in mfmiospike.cpp, five
   bytes long including the itc packet header at the front and a one
   byte checksum at the back.  It presumes that byte 1 of the packet
   is the 'mCommand' byte, and drafts 'F' (0x46) as the 'Flash
   Traffic' command.

 - The 'F' command packet currently contains no command arguments --
   the other four bytes are all concerned with validity and transport
   -- so the implication must be that other command values will also
   use struct FlashTraffic, and the use of 'F' for this first testing
   one is kind of misleading.

 - Also, we had a theory that maybe byte 1 values < 128 could imply
   cache update, which 'F' would blow:

      BYTE 0                                   BYTE 1                       BYTE 2            BYTE 3
      STND LOCL MFMT                            SPEC
     +----------------------------------------++---------------------------++----------------++--
     |  1 |  0 | 1  |OVRN||EROR|DIR2|DIR1|DIR0||  0 | MFM CACHE PKT LENGTH || CACHE PKT TYPE ||
     +----------------------------------------++---------------------------++----------------++--
     +----------------------------------------++---------------------------++----------------++--
     |  1 |  0 | 1  |OVRN||EROR|DIR2|DIR1|DIR0||  1 | MFM SPECIAL TYPE     || MFM SPEC TYPE ARGS..
     +----------------------------------------++---------------------------++----------------++--

[203:

Wed Jun 19 03:00:33 2019 OK, enough.  Some

TODO:

 - Make a 'section' structure with 'claimable' numbers like we had in
   201711120544-itcio-notes.txt, that takes us all the way to mfmt2
   running legit across tiles while handling itc status changes and
   intertile mfz compatibility checking.

:203]

:202]
:201]
[204:

Wed Jun 19 03:09:29 2019 The last 'claimable' we had in
201711120544-itcio-notes.txt was 6.2, so I guess we'll start here at
round 7.

(7) Demo mfmiospike executing multiple commands across a grid.[205: Wed Jun 19 04:26:06 2019 
(7.0) Debug current semi-working mfmiospike.
  :205]
(7.1) Create some kind of pipe or file input so the user can inject
      commands into mfmiospike.
(7.2) Make a perl mfmiospikectl stub that injects such commands via
      command line arguments
(7.3) Maybe do (8) first?[209: Wed Jun 19 05:14:23 2019
(7.4) Expand /sys/class/itc_pkt/statistics to separate priority and
bulk stats
(7.5) Rehack t2viz to handle the added stats  :209]

(8) Integrate mfmiospike functionality into mfmt2 in a way that we do
    not have to rebuild all of mfm every time mfmiospike changes.
(8.1) Decide if using an anonymous memory map, and having mfmt2 fork
      to mfmiospike, might be a good way to do that.
(8.2) Make subgoals to do that, or find and alternative, starting at
      8.3

(9) Demo an inter-mfmt2 tile open/close protocol, including mfz id
(9.1) Find out if we also need to share an element type number map.
(9.2) See if we easily couldn't if so.  Make mfm id match be good
      enough to send unaltered atoms in cache updates.

(10) Demo 'Ponger' running intertile.  Ponger picks a random color and
     moves in a fixed random direction until it encounters a non-live
     site ahead, then it picks a new random color and direction.
(10.1) Interact with cdm somehow to create an index of runnable mfzs.

(11) Demo a half-decent mfmt2 bespoke display
(11.1) Demo a new display for mfmt2 that reserves a visible pixel (or 2?
       3?) all the way around the display for itc hint info.
(11.2) Demo a new pop-up menu with big hittable 'R' options like
       rezup (sim) refresh (caches), reset (grid), restart (mfmt2),
       reboot (t2).
(11.3) Either fix the foggen mouse pointer mapping mess, or just work
       around it at mfmt2 level.  We don't need an actual (OS/SDL)
       mouse pointer for early mfmt2 stuff anyway.

:204]
[206:

Wed Jun 19 05:04:18 2019 Oh yeah, on issue we had just recently dealt
with was the 'checksum header' problem: The 'dir' field of itc packet
byte 0 changes in transit, so it can't be included in checksums.  (We
must have run into this in cdm.pl already, right?[207: Wed Jun 19
05:08:34 2019 No, cdm only checksums _content_ -- as a whole file or
as a chunk in a packet -- and not the whole packet itself.  :207])
[208:

Wed Jun 19 05:09:53 2019 So we already did exclude mPktHdr from
computeChecksum() in FlashTraffic.  So what happens now on the loopback?

:208]
:206]
[210:

Thu Jun 20 01:15:05 2019 So, with variable length records such as we
are using, kfifo_avail returns the max number of bytes YOU CAN PUT IN
THE NEXT RECORD.  That's why I'm seeing avail==255 both before and
after I stick stuff in a kfifo.

:210]
[211:

Thu Jun 20 02:24:01 2019 Well, no real progress, but I cleaned up
stuff to make debug logging a little prettier, and to slow down the
monitoring packets from the LinuxThreadRunner to like 1.5+sec each.

But running out of time to hack here.  Have to start packing up for
three days travel.

Bits off.

:211]
[212:

Thu Jun 20 03:08:30 2019 Really have to stop now.  Summary:

 - We can receive standard routed packets from other tiles to
   /dev/itc/packets

 - We can send and receive local packets like 'P', and receive and
   handle internall local packets like 'M'.

 - When we send standard routed packets outbound it appears they are
   being received by the PRUs because the new 'l' counter of packets
   received from linux appears to increment.  Use like

     echo "Pd0fhpxl??????????" > /dev/itc/pru1;head -1 /dev/itc/pru1

   to see the l count in hex on pru1.  (Note it increments each time
   by at least one for the 'P' packet itself.)

 - But when we have a loopback cable connected that is working enough
   to achieve packet sync, we get no evidence that any packets sent in
   those directions are ever seen.
[213:

Thu Jun 20 03:15:54 2019 But when we connect the serial cable to a
neighboring tile THAT IS RUNNING OLD CODE, and send a standard packet
to them, we DO SEE THEM GETTING IT in the syslog!  Packets ARE getting
off the keymaster with the new code.[214:

Thu Jun 20 03:21:00 2019 And on the keymaster we can receive routed
packets sent by (an old code) neighbor:

NEIGHBOR:

    root@beaglebone:~# echo -e "\x85OGOGOGOMMMM" > /dev/itc/packets

KEYMASTER:

    Jun 20 03:19:56 beaglebone kernel: [205578.753020] <pru1: 81 4f 47 4f 47 4f 47 4f 4d 4d 4d 4d 0a           .OGOGOGOMMMM.
    Jun 20 03:19:56 beaglebone kernel: [205578.760725] Stashed 0x81/13 packet for pktdev itc!packets ipb mUserIB, waking dc5f108c
    Jun 20 03:19:57 beaglebone kernel: [205579.848356] <pru1: c3 4d 31 33 31 3a                                .M131:

    root@beaglebone:/home/t2# cat /dev/itc/packets 
    AAAAAAOGOGOGOMMMM
      C-c C-c
    root@beaglebone:/home/t2# 

[215:

Thu Jun 20 03:23:01 2019 So... WHAT THE EVERLOVING FOG?  It's as if
the loopback cable is only willing to send packet delimiters, and all
real packets are silently discarded BY THE CABLE.

We should try to send a packet via a cable TO THE NEIGHBOR..  BUT I
HAVE TO HAVE TO HAVE TO STOP STOP STOP.

Bits off.

:215]

:214]

:213]

:212]
[216:

Sun Jun 23 06:17:13 2019 OK I'm back.  Time to reboot brain and try
the non-loopback-cable experiment.  So, are those previous
observations all consistent with the idea that the new code is not
able to receive new packets?  Although I don't see how that helps much
even if it is.  'New' packet looks fine to old code, 'old' packet
looks fine to new code..

:216]
[217:

Sun Jun 23 07:46:14 2019 Well, now it's looking like some of the
keymaster ITCs are intermittent or dead at the hardware level?  I
*can* send and receive new-to-new packets on keymaster loopback
between SE and WT.  But SE to NE doesn't sync and SE to NW doesn't
sync.  [218:

Sun Jun 23 07:49:26 2019 And WT to NE doesn't sync.[219:

Sun Jun 23 07:50:28 2019 And keym-NE to nghb-NW doesn't sync[220:

Sun Jun 23 07:51:39 2019 And nghb-NW to nghb-NE doesn't sync !?[221:

Sun Jun 23 07:52:37 2019 But nghb-NW to nghb-ET DOES sync.

And nghb-NW to nghb-SE DOES sync.  [222: Sun Jun 23 07:55:14 2019

Aaaand keym-SE to nghb-NW DOES sync.[223:

Sun Jun 23 07:59:46 2019 So, keym-NE and nghb-NE are both dead, for
starters? [224:

Sun Jun 23 08:06:48 2019 Buuut it's not that simple.  I just connected
ngb2 to keym-NE and it came up:

     Jun 23 08:06:16 beaglebone kernel: [ 5375.335525] ITCCHANGE:UP:NE



:224]

:223]

:222]


:221]

:220]

:219]

:218]

:217]
[225:

Wed Jun 26 16:20:55 2019 Hmm, just noticed an accounting problem in
itc_pkt.c -- routeOutboundStandardPacket increments mPacketsSent and
mBytesSent without knowing whether the write actually succeed.  We
need to delay stats changing at least until the packet actually goes
out in an rpmsg buffer and gets removed from its kfifo.

Maybe we should take that as a sign it's time to fix up the stats
stuff for bulk-vs-priority as well.  As least there's something
concrete and relatively quick we could work on.[226:

Thu Jun 27 03:57:17 2019 OK well the bad accounting is likely fixed if
I didn't mess up other stuff doing it, and we've now split bulk and
priority stats and pushed that change through all or most of the sites
that care about it.

BITS OFF.

:226]

:225]
