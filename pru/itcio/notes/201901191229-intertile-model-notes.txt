{17}  -*- text -*-
[0:

Sat Jan 19 12:29:28 2019 OK, so we've been struggling trying to pick a
userspace interaction/communication model for intertile stuff, and we
then perhaps the current missing link is we need an explicit 'neighbor
tile' abstraction.  Something that's not about the intertile
connection, but about the tile at the far end -- whether we currently
have a such a neighbor or not.

Unsure if it belongs in /dev, /sys/class, or something more userspace,
but perhaps like /dev/tile/ET etc.  For at least some users, we'd like
connection and disconnection events to be reported as just more
packets on some channel that stays open across such things.

And this abstraction would naturally be the place to handle those
currently-unhandled locstd 'P' and 'F' packets that we are currently
dumping to syslog like lost babies.  The /dev/tile/DIR object would
change status as a result, and that would be somehow visible more
broadly in userspace.

Perhaps we should draft a standard local packet type for 'tile event
notices' right now, so that our tile model can have an OoB way to
notify consumers about such changes.

OK, currently 201812171048-packet-format-notes.txt:1: has our
'documentation' for the defined local standard packet types.  0..3 (of
31) are currently in use.  Just take 4?  What is its name?[1:

Sat Jan 19 12:57:57 2019 'Tile Event Packet'?  TEP?  None of the std
loc packet types seem to have manifest constant names yet.[2:

Sat Jan 19 12:59:31 2019 And what is the TEP syntax?  Well, we finally
will not have the direction encoded in it, because that's now implicit
in which tile we are talking to.

So:
TEP := TEP_PKT_TYPE + EVENT_TYPE + OPT_ARGS
TEP_PKT_TYPE := 0xc4
OPT_ARGS     := BYTE*

EVENT_TYPE   :=
 0x00      Illegal
 0x01      Connect
 0x02      Disconnect
 0x03-0xff Reserved

[3:

Sat Jan 19 16:04:54 2019 The tile models, I guess, should provide
services by something like port number, so packets can be
demultiplexed by the tile model.

And I guess the userspace 'server' we're thinking of is the "actual"
tile that the remote tile models are modeling.
[4:

Sat Jan 19 17:21:36 2019 Looking at some FUSE tutorials..  I know
there's plenty of people hating on FUSE but it might be at least a
transition technology for us here as we try to figure out what we
actually want our LKMs to do for us.
[5:

Sun Jan 20 01:06:31 2019 Well, fuse is about what you'd expect -- a
giant pile of callbacks with a lot of fiddly details about
unimplemented flags and fuse-versions and so forth.  We can certainly
figure it out if we really want to but I'd rather have a clearer idea
what we want out of it before we try.

[6:

Sun Jan 20 01:08:10 2019 What are our main use cases?

1. mfmt2 would like to sit on one fd -- preferably via select() but
   perhaps block on a thread -- and receive all intertile mfm packets.

2. mfmt2 would also like to select() on one fd to know when it can
   send an intertile packet?

3. some 'physics daemon' would like to announce and monitor the tile's
   current physics 'version stamp' and do background intertile
   updating of newer versions.

4. at a minimum the physics daemon would manage mfz files; as a
   step-up it could propagate like the T2 repo as well.


5. 'general intertile communications', whatever that might mean?

[7:

Sun Jan 20 04:25:04 2019 Given that it's all about 1 & 2, really, what
about if we draft the reserved bit in

    FIRST BYTE

     Standard Routed Packet Header
      STND LOCL RSV1
     +----------------------------------------+
     |  1 |  0 |  0 |OVRN||EROR|DIR2|DIR1|DIR0|
     +----------------------------------------+

(from /home/t2/T2-12/pru/itcio/notes/201812171048-packet-format-notes.txt:0 )

to be the 'mfm bit'?

      STND LOCL MFMT
     +----------------------------------------+
     |  1 |  0 | 1  |OVRN||EROR|DIR2|DIR1|DIR0|
     +----------------------------------------+

So anything with MFMT set is 'MFM traffic' that would be routed to and
from like /dev/itc/mfm or something, and mfmt2 would select or block
on that.[8:

Sun Jan 20 04:33:55 2019 So, everybody else would do what?  Go through
some single daemon that managed packet services for everybody except
mfm?  And that guy would expect packets like what, perhaps:


      BYTE 0                                   BYTE 1
      STND LOCL MFMT
     +----------------------------------------++---------------------------------------+
     |  1 |  0 | 0  |OVRN||EROR|DIR2|DIR1|DIR0||DST3|DST2|DST1|DST0|SRC3|SRC2|SRC1|SRC0|
     +----------------------------------------++---------------------------------------+

and we'd support up to sixteen random packet service ports.  Or I
suppose we could go to a three byte header, jeez.[9:

Sun Jan 20 04:54:44 2019 And how would people offer and use those
services.  Open /dev/itc/svc/ff for RDWR|NONBLOCK or something?  But
then do we even need a distinct source port, or is everything peer to
peer?  That would be flavorful.
[13:

Thu Jan 31 00:36:25 2019 So, we're back here, and we have a public
challenge to get software moving between tiles before next t2sday.

So, picking up the discussion in :8:, we need to pull the trigger on a
format for STND,!LOCL,!MFMT packets.

Do we NEED source ports?  Well, why do source ports exist?  So that
multiple 'clients' can talk to one 'server'.  Now, in basic intertile
land, we are ONLY talking to neighboring tiles and are NOT routing
beyond that.  And the source DIRECTION is already present in the BYTE0
header, so clients on different neighboring tiles are already
distinguishable.

So these multiple clients, if we had them, would have to be all on a
SINGLE neighboring tile.  Do we really need that?  Well, what if we
wanted to update a bunch of files amongst our neighbors?  We might be
newer on some files and some of our neighbors might be newer on
others.  It would be arguably convenient to just start flows for each
file that has to move in any direction and let their packets get
interleaved however, rather than having to (go to all the onerous
extra trouble to) make a user-level queue or whatever for the files
destined for each neighbor.
[14:

Thu Jan 31 02:40:10 2019 So I guess that example isn't
super-compelling to me.  To the contrary, if we had a peer-to-peer
'managed file update service', we could (more easily) get different
pieces of files from different neighbors and so on.  (Eventually.)

Are there other cases to consider for source ports?[15:

Thu Jan 31 02:46:01 2019 ..I'm just not seeing it.  Screw it, let's go
full-on peer-to-peer and deal with any fall-out as we have to.  Worst
case we can always create a source port model underneath some
peer-to-peer service.

So, we'd be saying something like

      BYTE 0                                   BYTE 1
      STND LOCL MFMT
     +----------------------------------------++---------------------------------------+
     |  1 |  0 | 0  |OVRN||EROR|DIR2|DIR1|DIR0||RSV1|RSV0|SVC5|SVC4|SVC3|SVC2|SVC1|SVC0|
     +----------------------------------------++---------------------------------------+

where we offer up to 63 services (reserving service 0 as null), and
hold a couple of bits for the future.

Aaand we can go ahead and draft a few services here, at least
provisionally?

Say service 1 is a .. what?  Version number?  Liveness ping?  Maybe we
should stick to our knitting here and just say like service 8 is
'managed file update'.  We want a service that just falls towards
having the newest version of all managed files that any neighbor knows
about.  We'll have a directory of the current king of the hill files,
each with a version number and a checksum..[16:

Thu Jan 31 03:17:26 2019 Stop stop stop.  Crawl before fly my god you
have to get something running here.  A directory of MFZ files that are
all to be considered 'legitimates physics-es'.  All have to be signed
by a known key.  We go by the timestamp in the mfz to decide if a file
is newer.  As an idle background process, we send random mfz+timestamp
info to random neighbors every so often.  If we receive word about an
MFZ that we don't have or that's newer than what we do have, we
request that file.  The source starts streaming it to us.  We assemble
it in a temporary directory.  When/if it arrives completely and we
verify it locally, we (atomically-ish) cut it over into the live
directory, and that's when it will start getting broadcast to our
neighbors.

Somehow we have a way -- perhaps a different service in fact -- of
saying it's time to change physics, which we handle by shutting down
MFM and restarting it on a new MFZ.

For now we still won't have intertile events, so there's no issue yet
of mfm needing to check that neighbors are on the same MFZ.

:16]

:15]

:14]

:13]
:9]


:8]

:7]


:6]

:5]
:4]
:3]


:2]

:1]

:0]
[10:

Sun Jan 20 08:02:15 2019 But, I need to see something anything proof
of concept minimal crap actually working here, for me to feel
comfortable.

I want a Perl script daemon that

1. Watches the modification date of some counter file, and reloads it
   whenever it changes.

2. And advertises its counter value by sending it to all active
   neighbors every minute or so.

3. And tracks the counters of all active neighbors by monitoring their
   counter value advertisements.

4. And

:10]
[11:

Wed Jan 30 22:37:52 2019 Aaand, to make the guts of that work, we need
a way to send a file.  Which is a stream of bytes, plus metadata,
which has to be packetized, sent, received, and reassembled.

Aaaaad, damn the NIH torpedoes aaand damn the RTW (Reinventing The
Wheel) nay-sayers and let's just MAKE OUR OWWWWWWWWN.

[12:

Wed Jan 30 22:40:56 2019 So.  We need packet formats for metadata and
data stream.  We have some structure for such things already set up,
so we should find that.

:12]

:11]
