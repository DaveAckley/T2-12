{831}  -*- text -*-
[0:
[3:
[35:
[36:

Thu Feb  6 14:20:38 2020 And here we are.

:36]
Thu Feb  6 14:19:30 2020 MOVING THIS TO
/home/t2/T2-12/pru/itcio/notes/ since we're now about LKM hacking
again.

:35]
[4:

Sun Feb  2 01:29:46 2020 And here we are.

:4]
Sun Feb  2 01:28:16 2020 MOVING THIS TO
/home/t2/MFM/src/drivers/itcSpike/ where we've been working for a
while now..

:3]


Sat Feb  1 04:15:53 2020 So, starting in to a spike to get more real
about ITC state machines for the levels and so forth.

First question: Are we going to redo the itc_pkt to break out the
packet channels?  Right now, MFM/src/drivers/mfmt2/include/MFMIO.h is
opening MFM_DEV_PATH == /dev/itc/mfm and that's that.[1:

Sat Feb  1 04:48:19 2020 And we're already doing a loop, in
mfmt2/src/main.cpp, to ship flash traffic, since we have to customize
the packet headers.  With separate devices I suppose we could even
have the LKM slug the src/dst info into the pkt hdr.

Well I think it's pretty clear we're thinking of making
/dev/itc/mfm/{ET..NE} devices, so why don't we get on down to
~/T2-12/pru/itcio/module/ and see what that might involve.  One think
to think about is that packet writes will still need to be merged into
the outbound queue for the appropriate pru, so the locking on that
could start actually getting stressed, since there will be six (well,
three) separate devices that might be trying to a given outbound kfifo
at once.

But nap first.[2:

Sat Feb  1 10:00:37 2020 OK, let's have some

TODO

[5: Sun Feb  2 01:30:16 2020
DONE :5] - Make a tiny little stub that we'll grow into the itc level
   sequencer.

[12: Wed Feb  5 04:34:28 2020
DONE :12] - Change boot sequence to start the stub INSTEAD of mfm, so the
   former can grab /dev/itc/mfm

[13: MFMIO.h/cpp was already that, so
DONE :13] - Maybe let's make a little abstraction that wraps /dev/itc/mfm and
   turns it into a like pollable pseudo-device?  So we could start our
   level sequencing code without immediately doing the LKM stuff?

[14:
DONE:14] - Rough up some packet formats for the levels

[15:
DONE :15] - Demo first-cut on-tile level sequencer talking on loop-back then
   between tiles, with results visible ONLY in the log file -- NO
   DISPLAY HACKING ALLOWED :)

:2]

:1]

:0]
[6:

Sun Feb  2 05:01:08 2020 OK we're at ITC::sendLevelPacket() so we need
a packet format.  What do cache updates currently use?  Let's just get
OoB wrt that?[7:

Sun Feb  2 05:04:16 2020 In src/core/include/Packet.h, we have like
PacketType::UPDATE_BEGIN == 'b'.[8:

Sun Feb  2 05:25:31 2020 But that's the second byte.  The packet
actually starts with

      u8 cmd = 0xa0|dir8; // STD MFM pkt hdr
      packet.Printf("%c",cmd);

according to src/drivers/mfmt2/src/main.cpp:262

So let's just keep going with the second byte scheme, I guess.  The
cache processing code appears to be using second byte types [ucea].
We notice they're all 7 bit ASCII.  If we take the high bit for our
level scheme we can pack the level and stage all into the second byte,
with room leftover..

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1 | L1| L0| S1| S0|RV0|RV1|RV2|
   +---+---+---+---+---+---+---+---+

Three bits left over, if we say no more than three levels.
[9:

Sun Feb  2 05:41:39 2020 Well let's do that.  We can always change it
if pressing needs come up.[10:

Sun Feb  2 05:45:26 2020 Uhhhhm except flash traffic is already using
the top bit of byte 1.

      if (amt > 1 && (buf[1] & 0x80)) // byte 1 MSB set is MFM SPECIAL, clear is

So we'll need to rethink.  Probably just draft 'l' or 'L' for Level
packet, and take another byte and not worry about it.

But first nap.


:10]

:9]
:8]

:7]

:6]
[11:

Sun Feb  2 12:21:36 2020 OK, so we're sending 'l' packets to ourselves
via loopback cable, and handling them a little, and are getting quite
close to the frontier of chnlSim.pl's implemented behavior.  But it's
time to move the flag, so we've got to get this stuff actually into
the tree for safety..

:11]
[16:

Wed Feb  5 04:35:19 2020 OK so we're post-t2sup#269 and want to get
some thoughts down while they still don't seem to suck.

A LEVEL has

 - SUPPORTS.  These are things that must be true to remain in or at
   the LEVEL.  The level code should check all these things every time
   it runs, and if any are untrue the level crashes.

 - PROPERTIES.  These are things that can be accessed, and can affect
   processing both within level code and by other entities

 - Triggers? Advancers? Exiters?  These are the conditions that allow
   advancing from one level to another.

[17:

Wed Feb  5 04:58:46 2020 So the problem with levels is that you can't
fork states, because you have this one dimensional notion of altitude,
of progress, of sequence.  So you have to fold all cases at a given
level into the properties of that level -- like COMPATIBLE vs
INCOMPATIBLE physics.

The good thing about levels is you can do altitude comparisons.  You
can say 'if (foo.level >= ACTIVE)' or whatever, and have that be a
meaningful thing.

[18:

Wed Feb  5 05:07:06 2020 There's also the interlock implied by the
stages, reflecting the distributed aspect of the state machine.  In
principle we could be looking to stage-interlock not just ITC<->ITC
but also the ITC<->TileModel.

Could there be a cross-entity global notion of levels?  And things
might but at different levels on that scale, but they'd still be
commensurate.

MFMT2 can be:

  CLOSED - not running, or starting up or loading or ..
  OPEN - running events under whatever circumstances prevail

ITCs can be

  CLOSED - not connected, or negotiating physics, or incompatible physics
  OPEN - handling locks and cache updates between compatible MFMT2s

[19:

Wed Feb  5 06:29:54 2020 In addition, entities might be stable or
unstable within a level.  Entering/stable/leaving?  What is the
purpose(s) of stability?

 - Coordination with remote entities
 - Non-atomic processing internal to level

Externally we say something isn't really AT a level until they are at
least STABLE in that level.

:19]

:18]

:17]
:16]
[20:

Wed Feb  5 06:51:12 2020

TILE
  Coordination tasks:
  (1) Host PRUs
  (2) Host ..
  Computation tasks

ITC
  Coordination tasks:
   (1) Host Tile
   (2) Peer ITC
   (3) Host MFM
  Computation tasks:
   (1) Compatibility check

MFM
  Coordination tasks:
   (1) Local ITCs (limited)



                          TIMEOUT       RCVE
 ITC::CLOSED::ENTER       reannounce    ITC::CLOSED::ENTER -> ITC::CLOSED::STABLE
                          + remain

 ITC::FAILED::

:20]
[21:

Wed Feb  5 07:28:34 2020 What if we move the compatibility negotiation
into the kernel???  That would certainly establish the decoupling of
the ITCs from MFMT2.

How might it work?

Open /dev/mfmctl for read/write.  It's single user so that's how mfmt2
locks out any other userspace competitors.  Write MFZ fingerprint to
it?  Poll to read it for events?  Do we even believe in events?  Vs
states?  Perhaps advisory events just to speed things up, but the
event just triggers reading states, rather than trusting the advice.
Everything should still work, just slower, even if all events (other
than timeouts) are ignored.
[22:

Wed Feb  5 08:54:16 2020 So an event is really just like a wake-up,
rather than a real event.  Even a timeout is really just a wake-up,
and the entity checks its own internal clock to see if it's a 'real'
timeout.

I do think we're going to go to actual time-based intervals for
timeouts and such, though, rather than the count-based stuff from this
weekend.  After all, that's counting wake-ups, which we JUST SAID
weren't supposed to matter if they happened or not.

But we only want intervals, not absolute times, and only at say
millisecond res.

[23:

Wed Feb  5 09:26:12 2020 When we accumulate state, like advancing a
level, we associate a rate at which we expect that state to be
refreshed.  And indeed, maybe we do not think in terms of a single
timeout for an entity, but in terms of a timeout for refreshing each
bit of state it is maintaining.

But first nap.

:23]

:22]


:21]
[24:

Wed Feb  5 12:48:58 2020 Suppose we try to rough out an LKM approach
to mfm configuration and cache updates.  Goals:

 - Userspace informs LKM of its ability to run events of some given
   MFZ and no other.  After that returns successfully, all KITC fds
   have been put into an error state, and userspace must close and
   reopen those connections before they can be used.

 - User space sees 'only' cache updates (and flash traffic?) via the
   new device.  And KITC status, OPEN/CLOSED, with open implying
   'ready for events'.   'And like everything,' we should somehow get
   a wake-up when a KITC changes, or we can interrogate it at our own
   rate.

When mfm considers an event window it tries for locks on the ITCs it
believes to be OPEN, and goes from there.

[25:

Wed Feb  5 15:58:17 2020 Are we saying we'd just expand itc_pkt for
this, or would there be a separate LKM?  I guess we're saying expand
itc_pkt.  We don't want to figure out how to call between LKMs for
example.

So,

TODO
[29: Thu Feb  6 11:13:11 2020

DONE :29] - Review itc_pkt.[ch] to remember what we're dealing with.

[37: Thu Feb  6 14:20:58 2020
DONE :37] - Make an expanded struct for each direction, and

[50: Fri Feb  7 14:45:10 2020
DONE :50] - Make a struct for mfm info like the mfzversion.

[45: Fri Feb  7 12:03:33 2020
DONE :45] - Review packet formats to see where we could fit it the inter-itc
   negotiation stuff (aka 'level packets').

[38:
DONE :38] - Also review for expanding to per-ITC packet-IO devices to
   userspace.  Like /dev/itc/mfm/ET../dev/itc/mfm/NE or whatever.

:25]

:24]
[26:

Thu Feb  6 01:15:57 2020 So for starters, we're talking about a bunch
of new minors, right?  For the record, here's what we're using now:

    t2@beaglebone:~/T2-12/pru/itcio/module$ ls -l /dev/itc/* | sort -k 1.1,1.2 -k 5n -k 6n
    crw------- 1 root root 237, 0 Feb  5 01:23 /dev/itc/pru0
    crw------- 1 root root 237, 1 Feb  5 01:23 /dev/itc/pru1
    crw------- 1 root root 237, 2 Feb  5 01:23 /dev/itc/packets
    crw------- 1 root root 237, 3 Feb  5 01:23 /dev/itc/mfm
    crw------- 1 root root 237, 4 Feb  5 01:23 /dev/itc/pktevents
    crw------- 1 root root 238, 0 Feb  5 01:23 /dev/itc/locks
    crw------- 1 root root 238, 1 Feb  5 01:23 /dev/itc/lockevents
    t2@beaglebone:~/T2-12/pru/itcio/module$

so we'd be talking SIX more minors under /dev/itc?  And does this mean
they ALL need/want to be DIRECTLY under /dev/itc?  Well, maybe not.
The makeITCCharDeviceState code like at itc_pkt.c:2129 does:

  switch (minor_obtained) {
  case PKT_MINOR_ITC: snprintf(devname,BUFSZ,"itc!packets"); break;
  case PKT_MINOR_MFM: snprintf(devname,BUFSZ,"itc!mfm"); break;
  case PKT_MINOR_EVT: snprintf(devname,BUFSZ,"itc!pktevents"); break;

so perhaps we could 'just' do "itc!mfm!ET" ?  Except that would imply
/dev/itc/mem is a directory not a device.  But maybe "itc!bydir!ET" or
whatever.  Or maybe device /dev/itc/mfm does become a directory -- do
we still need it as a device if we're exploding the itcs by direction?
Bulk traffic still goes by /dev/itc/packets; flash traffic will appear
in the by-direction queues (?), along with the 'mfm' traffic.  So

Assuming we really can go more than one '!' deep in that naming
scheme.
[27:

Thu Feb  6 02:54:13 2020 So anyway.  I think itc_pkt.[ch] isn't in
terrible shape for adding another chunk of minors.  For now, let's
preserve /dev/itc/mfm and try going with /dev/itc/bydir/ET..[28:

Thu Feb  6 11:00:15 2020 Post coffee with Melanie and Chris Thachuk.

[30:

Thu Feb  6 11:13:32 2020 So let's go for more minors.  This part of
the hack is basically about demuxing the inbound mfm packets on a
per-direction basis, and we can do that separately from moving
additional protocol negotiation into the kernel.[31:

Thu Feb  6 14:00:25 2020 OK so we theoretically have six more minors
being built and torn down, all untested.  Wait, where did we actually
name their paths?[32:

Thu Feb  6 14:05:21 2020 And their paths have been named.  All, as
previously mentioned, untested.

We have a new script on the workstation,
CDM-TGZS-BACKUP/scripts/PullT2HomeDir, that just rsyncs /home/t2, with
no versioning or extra redundancy on the workstation side.  But trying
that now because I think we're facing

BITS OFF

:32]

:31]

:30]

:28]

:27]
:26]
[33:

Thu Feb  6 14:17:05 2020 OK well we seem to have survived
install+reboot okay so far.  No logoops that I can see.  And we see
this:

    root@beaglebone:~# ls /dev/itc
    bydir  lockevents  locks  mfm  packets	pktevents  pru0  pru1
    root@beaglebone:~# ls /dev/itc/bydir
    ET  NE	NW  SE	SW  WT
    root@beaglebone:~# ls -l /dev/itc/bydir
    total 0
    crw------- 1 root root 237,  5 Feb  6 14:10 ET
    crw------- 1 root root 237, 10 Feb  6 14:10 NE
    crw------- 1 root root 237,  9 Feb  6 14:10 NW
    crw------- 1 root root 237,  6 Feb  6 14:10 SE
    crw------- 1 root root 237,  7 Feb  6 14:10 SW
    crw------- 1 root root 237,  8 Feb  6 14:10 WT
    root@beaglebone:~#

which all seems plausible.

[34:

Thu Feb  6 14:18:43 2020 But, this file is currently in ~/MFM, which
seems wrong since we're now into LKM stuff over in ~/T2-12/pru.

:34]
:33]
[39:

Thu Feb  6 14:44:59 2020 So let's see if we can demux inbound MFM
packets to our new devices, while still sending them to /dev/itc/mfm
as well.[40:

Fri Feb  7 02:45:27 2020 Well, we'd have to introduce a new packet
copying thing to do that, so maybe let's just bite the bullet and
stop sending to /dev/itc/mfm.  However, we're wondering if while we're
tearing all this up, we might make yet another minor to represent
flash traffic.  With the desired semantics being that flash traffic
reads are not demuxed per-dir6, but perhaps flash writes are
automatically broadcast in all active dir6s.

Actually now that I say it perhaps /dev/itc/mfm could be repurposed
for flash traffic, rather than creating yet another minor?  So we'd

(1) Insert a diversion around itc_pkt.c:1768 where we'd fall through
    on flash traffic, but go off to some new demux handler for
    everything else.

(2) Change the code around itc_pkt.c:1399 to broadcast flash traffic
    rather than routing it.

[41:

Fri Feb  7 06:26:56 2020 So how do we distinguish flash traffic, and
'ITC level' traffic, at the LKM level?



:41]

:40]

:39]
[42:

Fri Feb  7 10:33:48 2020 OK, well I spent a couple hours, here, making
T2-12/doc/T2-Packet-Header-Formats-11.ods and .pdf files.  It presumes
we're going to take byte 1 bit 7 on routed standard packets to mean
'MFM traffic', as opposed to 'flash traffic', so itc_pkt can split
those streams before delivery to userspace.

It further presumes we're going to take byte 1 bit 6 on MFM traffic to
mean 'ITC level traffic', which is to be handled by itc_pkt.c and
never delivered to userspace, directly, at all.  That leaves only six
bits for the the cache packet type code, so we can't just be happy and
use 7 bit ASCII.  Now, according to MFM/core/include/Packet.h, we
currently have cache type codes [bucea] in use, and none of them fit
in six bits.

But I'm thinking now might be the time to support merging cache
'minipackets' together for transport anyway, in which case we might
not even be using the remaining six bits of byte 1, and might just be
starting at byte 2.

[43:

Fri Feb  7 10:49:26 2020 Let's see.

 Format: UPDATE_BEGIN + s16:CX + s16:CY          --5 bytes
 Format: UPDATE + u8:SITENO + T:ATOM             --14 bytes
 Format: CHECK + u8:SITENO + T:ATOM              --14 bytes
 Format: UPDATE_END                              --1 bytes
 Format: UPDATE_ACK + u8:CONSISTENT_ATOM_COUNT   --2 bytes

So we could fit like (/ 250 14) ~16 site updates anyway in a single
packet, and a DReg- or Res-like diffuser would be (+ 5 14 14 1) < 40
bytes all done, if no check atoms were needed.  (Or alternatively,
more than a dozen check atoms could be included and still fit in one
packet.)

Worst case, if we had to ship absolutely the whole event window, we'd
be talking (+ 5 (* 41 14) 1) == 580 bytes, meaning three packets.

:43]

:42]
[44:

Fri Feb  7 11:52:08 2020 So where are we?  Have we got some to-do to
check off?[46:

Fri Feb  7 12:03:45 2020 Well, all that's left on the most recent
to-do is an mfm struct to capture downward state information.  Let's
knock that out.[47:

Fri Feb  7 12:53:19 2020 So, what ARE we going to use as the real 'MFZ
version string'?  The question drives the issue of what kind of
intertile security -- if any -- are we going to have in these
'research-only prototype tiles'.  About the best we could do, if we
wanted to, was to have some kind of private key inside the MFZ, and do
a challenge-response during KITC level negotiation.  But that would be
BS because it would only prove that the peer tile HAD POSSESSION of
some particular MFZ secret key, and not also that the peer tile WAS
RUNNING THE ASSOCIATED CODE unmodified.

So we shouldn't pretend we're getting intertile SECURITY here, and
just focus on avoiding intertile ACCIDENTS.  Seems like a hash of the
whole damn MFZ file would be the obvious way to go.  A SHA256 is 64
bytes in hex.  Suppose we make the max length 127 bytes.[48:

Fri Feb  7 13:14:03 2020 Actually, what does cdm.pl do?[49:

Fri Feb  7 13:22:40 2020 cdm.pl appears to use the FIRST HALF (16
bytes/32 hex) of the (32 bytes/64 hex) sha256 result.

Suppose we do this:

(1) Take the whole sha256 result as the id, but handle it in binary,
    taking 32 bytes.

(2) Make the max id string like 50 bytes.

(3) As part of leveling up, after we establish matching ids, we
    exchange a random token of perhaps 2 or 4 bytes.  That's what
    we'll use in later status announcements.  So a lower level is
    supported by matching ids, but a higher level is supported by
    matching side-specific tokens.  Maybe 2 bytes each, and the
    confirmation packet supplies our two bytes and our belief about
    their two bytes.  And we pick a random non-zero starting point
    when the LKM inits, and then increment-skipping-zero from there.


:49]

:48]

:47]

:46]

:44]
[51:

Fri Feb  7 14:45:33 2020 OK, made an mfmstate thing and initted it.
How do we set the config?  'echo $id > /sys/class/itc_pkt/mfzid'?

Well let's try more

TODO

[53: Fri Feb  7 16:39:14 2020
DONE :53] - Init MFMTileState via /sys/class/itc_pkt/mfzid

[64: Sat Feb  8 15:28:06 2020
DONE :64] - Draft the KITC levels considering the mfzid/seqno distinction

[54:
DONE :54] - Make code to open ITCMFMDeviceStatuss.  Ensure they are exclusive use.

[55:
DONE :55] - Mod ITCMFMDeviceStatus to have an invalid flag to set forcing reopen

[99: Thu Feb 13 13:38:13 2020
DONE :99] - Rename /dev/itc/mfm to /dev/itc/flash and route flash traffic there.

:51]
[52:

Fri Feb  7 16:38:45 2020 OK time to break for cooking dinner, but we
have some cargo cult progress at least.
[56:

Fri Feb  7 16:39:40 2020 All that crab builds but is totally untested
at present.

:56]
:52]
[57:

Sat Feb  8 00:08:42 2020 So, the levels, the levels, let's try again.

Level 0: ALONE
  Requires:        Nothing
  Announce stages: false
  Entry timeout:   1000+-100ms
  On timeout:      Re-enter
  Update on:       ITCCHANGE, L rcvd, timeout
  Stage1 on:       PacketSync
  Stage2 on:       PacketSync
  Advance on:      PacketSync

Level 1: KITC
  Requires:        PacketSync
  Announce stages: true
  Entry timeout:   300+-100ms
  On timeout:      Re-enter
  Update on:       ITCCHANGE, L rcvd, timeout
  Stage0 argument: None
  Stage1 on:       t>=1.0 && t<2.0
  Stage2 on:       t>=1.0 && t<2.0
  Advance on:      t>=1.1 && u==1.2

Level 2: CONFIG
  Requires:        t>=1.1
  Announce stages: true
  Entry timeout:   300+-100ms
  On timeout:      if u==2.1, Backoff else Retreat
  Update on:       ITCCHANGE, L rcvd, timeout
  Stage0 argument: MFZId
  Stage1 on:       t>=2.0 && t.MFZId!=u.MFZId
  Stage2 on:       t>=2.0 && t.MFZId==u.MFZId
  Stage2 argument: mfm.seqno
  Advance on:      t>=2.2 && u==2.2

Level 3: MFM
  Requires:        t>=2.2 && mfm.seqno == t.seqno
  Announce stages: true
  Entry timeout:   1000+-100ms
  On timeout:      if u>=3.1 backoff else re-enter
  Update on:       ITCCHANGE, L rcvd, timeout
  Stage0 argument: mfm.seqno t.seqno
  Stage1 on:       t>=3.0 && mfm.seqno == t.seqno
  Stage2 on:       false
  Advance on:      false

:57]
[58:

Sat Feb  8 07:24:45 2020 Well I presume stages 0..3, there, in part
because of compat/incompat but also because we gave two bits for stage
in the level packet, but I'm thinking we should go back to just stages
0..2 and do compat/incompat with additional state, like we're already
kind of doing for their seqno.  Or something.

[59: Sat Feb  8 07:32:13 2020

 - KITCs are updated on: ITCCHANGE, L rcvd, timeout

 - Level confirmation packet data is cumulative.

 - update begins with requirements check.  Level requirements are
   cumulative.  If currently supported level < previous level, enter
   at currently supported level, stage 0.  Otherwise enter at previous
   level, previous stage.

 - All timeouts are randomized +- 25%

 - Most recently received peer level info is stored in 't'.  't' data
   is reset on restart or if T timeout expires.

DEFAULT LEVEL VALUES:
  Requires:        t>=(L-1).1
  U timeout:       100ms, re-enter
  T timeout:       500ms, retreat
  Exchange:        nothing
  Decide:          true
  Confirm:         nothing
  Advance:         t>=L.1 && u==L.2

Level 0 CONTACT
  Requires:        Nothing
  U timeout:       10000ms, restart
  T timeout:       10000ms, restart
  Advance:         PacketSync

Level 1 COMMUNICATION
  Requires:        PacketSync
  Exchange:        u.seqno
  Confirm:         u.seqno + t.seqno

Level 2 COMPATIBILITY
  Exchange:        MFZId
  Decide:          d = u.MFZId == t.MFZId
  Confirm:         d

Level 3 COMPUTATION
  U timeout:       10000ms, re-enter
  T timeout:       50000ms, retreat
  Advance:         false

:59]

:58]
[60:

Sat Feb  8 09:33:59 2020 OK, so :59: seems to have some potential.
Separate Us-vs-Them timeouts seems pretty key, in the spirit of
output strict, input generous.  Was picking times so we'd send our
stuff at least twice, and probably three times, before giving up for
lack of their stuff in response.

Could we start going to code here?  Flesh out 'class' structs and
'method' funcs?  We're going to try to go array-of-structs-of-fncptrs,
right?  What might the functions be?

  enum LevelAction { DO_REENTER, DO_RESTART, DO_RETREAT, DO_ADVANCE, DO_CONTINUE };
  bool levelRequires(ITCMFMDeviceState * itc) ;
  LevelAction levelTimeout(ITCMFMDeviceState * itc, bool usNotThem, u32 & nextTimeoutAroundMs) ;
  u32 levelSend(ITCMFMDeviceState * itc, bool exchangeNotConfirm, char * pkt, u32 startIndex) ;
  u32 levelReceive(ITCMFMDeviceState * itc, bool exchangeNotConfirm, char * pkt, u32 startIndex) ;
  LevelAction levelDecide(ITCMFMDeviceState * itc) ;

:60]
[61:

Sat Feb  8 15:01:08 2020 Urgh just did a big reorg including renaming
itc_pkt.[ch] to itcpkt.[ch] to get the 'multiple source file building
into one ko module' working.  It now appears to be building but I'm
terrified to try it.

I guess we do our risky 'rsync pull' to get our

BITS OFF

:61][62:

Sat Feb  8 15:08:26 2020 Well, 'make install'ing..

:62]
[63:

Sat Feb  8 15:13:45 2020 Well we appear to have survived reboot
without oops.

Soooo can we check some stuff off heah?
[65:

Sat Feb  8 15:28:57 2020 Well, I still don't really want to rename
/dev/itc/mfm to /dev/itc/flash, so let's instead make up some new

TODO

[68: Sat Feb  8 22:19:51 2020
DONE :68] - Finish setting up the structs for the draft levels

[80: Mon Feb 10 15:57:31 2020
DONE :80] - Detect and divert on whatever now counts as 'L' packets

[98: Thu Feb 13 13:37:55 2020 Anyway basically
DONE :98] - Make a generic level update() function for externals to call.

[81:
DONE :81] - Get some level-related crab appearing in the log file.

:65]

:63]
[66:

Sat Feb  8 17:24:29 2020 OK having been doing horrible XX YY macro
hackery, and have gotten as far as declaring the needed 'custom level
functions', but not yet defined them:

      CC [M]  /home/t2/T2-12/pru/itcio/module/itcmfm.o
    /home/t2/T2-12/pru/itcio/module/itcmfm.c:43:48: warning: ‘ilsRequireCONTACT’ used but never defined
     #define YY1(NM,TYPE) static Level##TYPE##_func ils##TYPE##NM;
                                                    ^~~
    /home/t2/T2-12/pru/itcio/module/itcmfm.c:46:3: note: in expansion of macro ‘YY1’
       YY##REQ(NAM,Require)                \
       ^~
    /home/t2/T2-12/pru/itcio/module/itcmfm.c:33:9: note: in expansion of macro ‘XX’
     /* 0 */ XX(CONTACT,      1,  1,   0,   0,            _)    \
             ^~
    /home/t2/T2-12/pru/itcio/module/itcmfm.c:51:1: note: in expansion of macro ‘ALL_LEVELS_MACRO’
     ALL_LEVELS_MACRO();
     ^~~~~~~~~~~~~~~~
    /home/t2/T2-12/pru/itcio/module/itcmfm.c:43:48: warning: ‘ilsTimeoutCONTACT’ used but never defined
     #define YY1(NM,TYPE) static Level##TYPE##_func ils##TYPE##NM;

etc

So that's where to pick up.  But it's Saturday evening so break
  time.[67:

Sat Feb  8 22:19:20 2020 OK, so log-only versions of the level
customizations are building.

:67]

:66]
[69:

Sun Feb  9 08:06:14 2020 Well, so finally went back and systematized
the dir8-vs-dir6 distinction more thoroughly, which meant hitting tons
of stuff all over the place.  But it's building again; untested.

We've theoretically detected when a KITC packet has arrived, but we're
just logging when it hits.

Perhaps we should head back down to loopback-only and then give this a
try?  We haven't done much on the send side yet so we could probably
handmake a KITC packet and inject it.[70:

Sun Feb  9 08:35:00 2020 Well since we're blowing it all up we also
did the device renaming.  Now we have:

  /dev/itc/bulk
  /dev/itc/flash
  /dev/itc/pru/0
  /dev/itc/pru/1
  /dev/itc/mfm/ET
    ..
  /dev/itc/mfm/NE

but userspace still can't read or write anything via /dev/itc/mfm/*

[71:

Sun Feb  9 08:44:36 2020 We need to merge itc_pkt_write and
itc_mfmitc_write.  They might end up being the same or nearly so.  We
could have itc_mfmitc slug in the correct destination automatically
before dishing off to the factored-out guts of itc_pkt_write.

But first, business of the day.

:71]

:70]

:69]
[72:

Sun Feb  9 11:48:54 2020 Well, risky

BITS OFF

:72]
[73:

Sun Feb  9 12:12:26 2020 OK so had some BUG_ONs hit due to error
checking in mapPruAndPruDirToDir8, but hacked around that and now
appear to be coming up again.

Have rehacked cdm.pl to look for /dev/itc/bulk.

TODO

[74: Mon Feb 10 12:50:02 2020
DONE :74] - Rehack MFMIO (MFM/src/drivers/itcSpike11) to open all six
   /dev/itc/mfm/* devices!

:73]
[75:

Mon Feb 10 12:50:22 2020 OK, userspace is now hitting the fact that
itc_mfmitc_write returns -EOPNOTSUPP so we need to implement that.

:75]
[76:

Mon Feb 10 13:19:00 2020 Well trying that write implementation after

BITS OFF

:76]
[77:

Mon Feb 10 13:23:15 2020 OK we're back.  We have an ET-WT loopback
plugged in, and itcSpike is seeing their PS, but not deciding they are
compatible.  Let's dig in.

:77]
[78:

Mon Feb 10 14:39:22 2020 OK it was 'user error' -- we're writing 'l00'
packets from itcSpike11, and they are now, 'correctly', being
delivered to /dev/itc/flash, because they do not have the MFM bit
(0x80) set on byte 1.

So we need to send proper MFM packets!  Buut, actually, officially, we
don't want to be sending 'l' packets from userspace at all, we want to
be having itcmfm.c doing that.  Are we getting to the point where we
go back to that?

:78]
[79:

Mon Feb 10 15:55:29 2020 OK, finally we got to this:

    root@beaglebone:/home/t2/T2-12/pru/itcio/module# tail /var/log/syslog
    Feb 10 15:55:04 beaglebone kernel: [ 5519.721844] (ET) HANDLE ITC TRAFFIC HERE (2) packet
    Feb 10 15:55:04 beaglebone kernel: [ 5519.756940] (WT) HANDLE ITC TRAFFIC HERE (2) packet
    Feb 10 15:55:04 beaglebone kernel: [ 5519.819234] (ET) HANDLE ITC TRAFFIC HERE (2) packet
    Feb 10 15:55:04 beaglebone kernel: [ 5519.832708] (WT) HANDLE ITC TRAFFIC HERE (2) packet

meaning we have successfully diverted on level packets and gotten crab
into the log file..
[82:

Mon Feb 10 15:57:51 2020 So now let's get an itcmfm dispatch to call
there, and foggen call it.

:82]
:79]
[83:

Mon Feb 10 17:06:00 2020 Quick evening break.  On return, I think
ready to try touching some of the ITCMFMDeviceState unique data
members.  [84:

Mon Feb 10 18:58:12 2020 Well, that worked for what little it was
doing.  It's getting to be time to have an idea how timeouts are
supposed to be generated.  Hoping we don't need another kthread,
right? [85:

Mon Feb 10 19:09:07 2020 Well, we probably do need another kthread,
but I don't want to try to get into that now.

Couldn't we get a fair chunk going just with responses to packets?

:85]

:84]

:83]
[86:

Mon Feb 10 19:21:21 2020 OK, so one thing we need right away is to
ACTUALLY GENERATE A STRUCT TO HOLD OUR ITC STATE.  That's a leftover
undone bit from the XX hackery.[87: Mon Feb 10 19:24:32 2020 Or, did
we decide to ditch that for the hardcoded ITCLevelState that we
already see in itcmfm.h?[88:

Mon Feb 10 19:26:28 2020 I think we did but if we didn't let's do that
now.  [89:

Mon Feb 10 19:33:05 2020 Trying to implement from :59:

:89]

:88]  :87]

:86]
[90:

Wed Feb 12 06:55:56 2020 Well, let's set up a KITC timing thread in
  itcmfm.c[91:

Wed Feb 12 07:46:48 2020 Getting there.  Abstracted the thread
creation stuff.  Still need the threadrunner routine, though wow:

    make[1]: Entering directory '/usr/src/linux-headers-4.19.79-ti-r30'
      CC [M]  /home/t2/T2-12/pru/itcio/module/itcpkt.o
      LD [M]  /home/t2/T2-12/pru/itcio/module/itc_pkt.o
      Building modules, stage 2.
      MODPOST 1 modules
    WARNING: "itcLevelThreadRunner" [/home/t2/T2-12/pru/itcio/module/itc_pkt.ko] undefined!
      CC      /home/t2/T2-12/pru/itcio/module/itc_pkt.mod.o
      LD [M]  /home/t2/T2-12/pru/itcio/module/itc_pkt.ko
    make[1]: Leaving directory '/usr/src/linux-headers-4.19.79-ti-r30'

"Successful build, exit status 0"

:91]

:90]
[92:

Wed Feb 12 15:46:45 2020 OK, so we have some of the level callbacks
kind of implemented.  Need more.  Also need to start handling level
packets.  How do we do that?

TODO

 - Review the update requirements check.  In particular,

 - Deal with the 'entering' clauses in :59:.

 - Deal with the timeout randomization and mTimeout management

[97: Thu Feb 13 13:37:17 2020
DONE:97] - Deal with storing the most recently received peer level info in 't'

 - Finish implementing the default requires, using 't'

 - Finish implementing the default advance, using 't'

 - Flesh out non-default cb's of CONTACT

 - Flesh out non-default cb's of COMMUNICATION

 - Flesh out non-default cb's of COMPATIBILITY

 - Flesh out non-default cb's of COMPUTATION

 - See this stuff BEGIN to work.

:92]
[93:

Wed Feb 12 16:22:47 2020 OK, in handleKITCPacket, do we know we're
dealing with a 'level packet'?[94:

Wed Feb 12 16:24:20 2020 Yes, we do, because itc_pkt_cb checked URG &
MFM & ITC before it dispatched to us.  So that means we have a
LevelStage in the bottom five bits of packet[1];

:94]

:93]
[95:

Thu Feb 13 08:50:40 2020 OK we need to reboot so long overdue to get
our

BITS OFF

:95]
[96:

Thu Feb 13 13:36:48 2020 All right it's time to move the flag again.
Let's see where we are here.[100:

Thu Feb 13 13:38:32 2020 Well didn't get much in the latest set of
to-dos but there you are.  Have still been doing infrastructure ahead
of that stuff.  We have the ITCLevelState structs getting implemented
with at least some plausibility now, etc.

BITS OFF

:100]

:96]
[101:

Thu Feb 13 16:07:08 2020 OK, flag moved.

:101]
[102:

Thu Feb 13 16:34:58 2020 OK, so :59: says 'KITCs are updated on:
ITCCHANGE, L rcvd, timeout'.  We've implemented a cut at updating on
timeout, but how do we update on 'L rcvd'?  The idea, such as it was,
was to call the .packetio callback at that time.  But is that an
'update'?  Like do the level support checks happen at that time?

Or do we perhaps imagine that level packets 'arrive between' updates
and are always handled wrt the cached state at that time?

That seems bad, like we'll end up leaning on the timeout when we
wanted that just to be a backstop.  So that says we DO want to update
as part of packet handling.  Do we update before or after the
.packetio callback?  Or do we somehow let the update call that
callback?  Right now updateKITC() doesn't have the arguments to know
about any possible packet.. But that seems wrong anyway.

So that says we should call .packetio 'asynchronously', but also call
update.  Before or after?  [103:

Fri Feb 14 01:27:35 2020 Let's say before.  Handle the packet, then
update.  What's the downside, handling a packet without realizing a
timeout had already occurred?  If there actually is a packet you'd
think we want to deal with it.  And again, we're trying to avoid
leaning on timeouts at all on error-free paths.

:103]

:102]
[104:

Fri Feb 14 06:06:55 2020 Trying to get to the point of using
.packetio, and starting to think the interface is stupid.  As I
understand it, the distinction between 'exchange' and 'confirm' is
supposed to be strictly determined by what stage we're in within the
level.  So why not just have a single 'handleInboundLevelPacket' sort
of callback, and let the callee decide how to interpret it?

But nap now.
[105:

Fri Feb 14 11:00:35 2020 Because we were going to use .packetio also
for generating outbound packet args?  How was that going to work?[106:

Fri Feb 14 11:03:15 2020 Well, in :60: we had TWO functions listed:

  u32 levelSend(ITCMFMDeviceState * itc, bool exchangeNotConfirm, char * pkt, u32 startIndex) ;
  u32 levelReceive(ITCMFMDeviceState * itc, bool exchangeNotConfirm, char * pkt, u32 startIndex) ;

each with the exchangeNotConfirm, which would cover the four cases of
sending and receiving during exchange and confirm.  But that somehow
folded down to .packetio with only two cases, how?[107:

Fri Feb 14 11:48:56 2020 Let's change that bool to recvNotSend and let
the callback decide what to expect/generate based on its own view of
the level state.

:107]

:106]

:105]

:104]
[108:

Fri Feb 14 15:27:24 2020 OK, so, what happens after we do the
requirements check in update?  :59: is kind of silent on this matter.

We update mUCurrentLS based on level requirements and the :59:
language.  ..Then we call the .decide callback?  And it does,
something, maybe?  ..And then call the .advance callback?  And if it
returns true we do like mUCurrentLS.level++, mUCurrentLS.stage=0?
When do we send a level packet?[109:

Fri Feb 14 15:57:23 2020 Well, in :57: we have an 'Announce stages:
BOOL' row, but that didn't make it into :59:.  Was there going to be
some kind of special return from something?  Is that something that
LevelAction is supposed to cover?[110:

Fri Feb 14 16:06:54 2020 So I think the idea was auto-announce the
level when it changes?  Or whenever the level or stage changes?  Maybe
that's it.  Then we'd need to be checking that in the update
requirements check loop.  But that was probably it.

:110]

:109]

:108]
[111:

Fri Feb 14 17:22:00 2020 OK, so, now the question is: Why do we have
both a .advance callback, and a DO_ADVANCE LevelAction coming back
from .decide?
[112:

Fri Feb 14 17:39:03 2020 So it's about the stage numbers.  We enter at
LX0 for some level X.  When that's a new LS for us, we send a LX0
packet that includes the 'exchange' data.  After we receive an LX0
packet (ignoring L(X-1)2 packets), we go to LX1, run the .decide, and
(if we DO_CONTINUE anyway), we send a LX1 packet including the
'confirm' data.  When we get an LX1 packet (ignoring LX0 packets), we
confirm it matches (HOW??), and go to LX2.

Each step along the way there, we were running the .advance callback
as well?  And by default it was saying false until they're at least at
LX1 and we're at LX2?

STILL NOT CLEAR AGAIN.  But time to cook.

:112]
:111]
[113:

Fri Feb 14 23:01:52 2020 OK,

recv packet:

 - Modify state based on packet and current expectations.  State
   includes mTLastLS plus whatever you parsed out of the packet.

 - Then call update

update:

 - Compute newly supported level based on packet sync, TLastLS, and so
   forth

 - Compare to mUCurrentLS.

 - If different, attempt to send level packet.  Custom sendPacket can
   return 0 to abort packet send.

 - If packet send apparently succeeds, set mUCurrentLS to new LS.  If
   packet send apparently fails, do not change mUCurrentLS (but
   shorten utimeout?  But we need to avoid getting into a tight
   spamming-a-full-outbound-buffer loop.  )

..and that's it?  That's all?  The rest is magic?

 - Update is also called on timeout and ITCCHANGE.  (ITCCHANGE will be
   caught by the requirements check so nothing special is needed
   there.)

:113]
[114:

Sat Feb 15 05:39:25 2020 Where in update do we check the timeouts?
Before or after computing the support?  Perhaps after?  So that we
could be.. ..should we be saying that 'still time available' is
implicitly part of the support for the current level?

So that if there's a mismatch, we're going to reset the timeouts based
on entering a new state anyway


[115:

Sat Feb 15 06:36:06 2020 Restate premises.

update:
 - Find supported level by requirements
   - If the now-supported level is below our previous level, attempt
     to enter that level.  After that attempt, the update is done,
     regardless if it succeeded or failed.

 - If our previous level is still supported, determine action:
   - If our timeout has expired, the action is our UTimeout action.
   - If not, see if their timeout has expired.  If so, the action is
     our TTimeout action.
   - If not, call .advance to see if we can advance.  If so, the
     action is DO_ADVANCE.  Otherwise the action is DO_CONTINUE.

 - After the action has been determined, do that action.  DO_CONTINUE
   means stay at the current level, otherwise compute the new level
   implied by the action and attempt to enter that level.

 - DONE


attempting to enter a level:
 - start a packet for that level
 - call the level-specific packet writer (for exchange or confirm as
   depending on the stage we're attempting to enter) to complete or
   abort it
 - if completed, attempt to send it.
 - If packet aborted or send succeeds, enter the level
 - Otherwise remain in previous level


enter a level:
 - set mUCurrentLS to the level
 - push U and T timeouts based on the level

recv packet:
 - Parse their LS from packet, store it in TLastLS

 - Call exchange or confirm parser as appropriate to TLastLS -- THEIR
   LEVEL, not ours.

 - Push our TTimeout for them based on OUR level, not theirs. (?)

 - Then call update

[116:

Sat Feb 15 14:53:33 2020 OK, after sleep.

So I'm wondering if it might not be stupid to have two full copies of
the ITCLevelState for each ITC, one representing US and one
representing THEM.  Instead of having like both UCurrentLS and TLastLS
in one struct.

Doesn't that seem like it wants to be a 'no brainer'?  The idea would
be that received level packets would just get parsed into THEM's
ITCLevelStruct no questions asked..

Could we ditch the UTimeout vs TTimeout distinction as well, and have
a single timeout per ITCLevelState?  That seems more questionable,
because we'd be using THEM.mTimeout to represent when WE'RE going to
time them out, not anything about what they're going to do.

Although I suppose possibly if we switched from notion of a stored
timeout to a stored 'last activity', setting THEM.mLastActivity based
on packet arrival time isn't that bogus.

But we still need someone to say when 'that long ago' becomes 'too
long ago'.  How would the thread runner decide who to update?[117:

Sat Feb 15 15:18:09 2020 If we're willing to callback for the timeout
inside the thread runner -- which we already are, right? -- the
previous activity is all we need?  Well, I guess we'd need to compare
both US (last and timeout) and THEM (last and timeout) to determine
whether an update is warranted.
[118:

Sat Feb 15 15:23:18 2020 Aand, do we set US 'lastActivity' based on
when we last (apparently successfully) sent a packet?  That would be
most symmetric with setting THEM lastActivity based on receiving one.

It also has the nice flavor that it's explicitly about packets and
traffic and communications.

And it makes it so that if we failed to send a packet due to buffer
exhaustion say, we won't push back our (effective) timeout by changing
lastActivity.

So.. could we do this?  Let's at least look at the structs.[119:

Sat Feb 15 16:20:03 2020 Well jeez yeah I think so.  Maybe switch to
something like:

typedef struct {
  ITCSideState mUs;
  ITCSideState mThem;
} ITCLevelState;

typedef struct {
  unsigned long mLastAnnounce;  /* Time in jiffies */
  MFMToken   mToken;            /* Physics ID from MFM */
  MFZId      mMFZId;            /* MFZId from */
  LevelStage mLevelStage;       /* Endpoint LevelStage from Them */
  bool       mCompat;           /* True if Them and Us are known compatible */
} ITCSideState;

[120:

Sat Feb 15 16:28:21 2020 What happened to the seqno in all this?  No
hits in itcmfm.[ch].  And didn't the seqno thing also suggest we were
going to stack the packet generators and parsers?  So that every level
packet at L1.0+ will have a seqno..  Do we still want to go that
route?

Time to cook.

[121:

Sat Feb 15 22:30:22 2020 So an argument against seqnos is that we're
trying to be robust in the face of packet loss, by asserting our LS in
every packet and minimizing shared state.

(If we did the packet-stacking idea we could still have the levels
append different state depending on the level of the packet they are
appending to.  That's how we wouldn't have to have the MFZId in every
L2.1+ packet, for example, and how we could have just the 'd' residue
going forward.  Just have to tell the .packetio guys what the actual
packet level is, separate from the level they are 'prime' for.)

What were the seqnos supposed to accomplish?  We were worried about
enough stuff getting dropped in transit that the recipient could miss
an entire physics bounce or something, and end up indefinitely out of
sync.  And seqnos were supposed to avoid that because we'd best-effort
know if we missed packets.  And what do we do if we miss a packet?
DO_RESTART, I guess, which will block us from going forwards until we
pick and agree on new seqnos.  That almost makes some sense.
[122:

Sat Feb 15 23:20:09 2020 Now, what good does receiving their ack of
our seqno do?  In TCP that's what allows us to dump the buffers we'd
been saving in case we needed to retransmit, but we're not talking a
retransmit/reliable stream here, are we?

We'd thought it would be handy to give cache updates confidence the
far side was indeed responding to the request we thought they were --
and as we contemplate the possibilities of doing precision
event-window locking, rather than edge and corner locking, we could
conceivably have a number of transactions in progress and not know
what order the far side was going to respond to them.  And at that
point we'd really need some kind of transaction tags to match up --
but they wouldn't be seqnos, so...

:122]
:121]

:120]
:119]

:118]
:117]

:116]

:115]

:114]
[123:

Sat Feb 15 23:41:00 2020 Well fog it let's just do along the lines of
:119: -- plus a seqno -- and see where it gets us.

:123]
[124:

Sun Feb 16 16:16:39 2020 Jeez we compiled clean.  But I'm sure there's
horrible gaps all over the place.[125:

Sun Feb 16 16:18:05 2020

RISKY BITS OFF

:125]

:124]
[126:

Mon Feb 17 09:52:05 2020 OK time to move the flag again.  We've made a
bunch of progress but there's still lots of gaps and confusion in the
code.  Current status is do like:

    # echo f00 > /sys/class/itc_pkt/debug ; sleep 10 ; echo 0 >/sys/class/itc_pkt/debug

to flash debugging, and see stuff like:

    [14054.095675] (NW) UPDATE ss->mLevelStage=L00 advance=false
    [14054.107739] diffToNext=-3499100, jifTil=-3499079
    [14054.119011] final diffToNext=-3499100
    [14054.643753] kitc=0, timeout=3438240, now=3438416
    [14054.651715] (ET) UPDATE KITC them=L10
    [14054.661984] (ET) UPDATE reqmts level=0, ops=91665ae0
    [14054.673107] (ET) UPDATE reqmts level=1, ops=86da6820
    [14054.683718] (ET) UPDATE post reqmts enterlevel=1, enterstage=0
    [14054.698782] (ET) UPDATE ss->mLevelStage=L10 decideAction=5
    [14054.711049] (ET) MORE ME UPDATE newLS=L10 nextls=L10
    [14054.722806] (ET) UPDATE ss->mLevelStage=L10 advance=false
    [14054.735310] ilsPacketIO_CONTACT recv=false startIdx=0 len=255
    [14054.747751] ilsPacketIO_COMMUNICATE recv=false startIdx=2 len=255
    [14054.762948] sendLevelPacket us=L10 them=L10, len=2
    [14054.774857] ET00000000: a2 c4                                            ..
    [14054.789850] itcSideStateSetLastAnnounceToNow: timeoutVar=100, now=3438452, nextTo=3438575
    [14054.798268] recvLevelPacket us=L10 them=L10, pkt=L10
    [14054.803309] WT00000000: a6 c4                                            ..
    [14054.810337] ilsPacketIO_CONTACT recv=true startIdx=0 len=2
    [14054.815876] itcSideStateSetLastAnnounceToNow: timeoutVar=500, now=3438459, nextTo=3438851
    [14054.824119] ilsPacketIO_COMMUNICATE recv=true startIdx=2 len=2
    [14054.830004] (WT) UPDATE KITC them=L10
    [14054.833714] (WT) UPDATE reqmts level=0, ops=91665ae0
    [14054.838743] (WT) UPDATE reqmts level=1, ops=86da6820
    [14054.843758] (WT) UPDATE post reqmts enterlevel=1, enterstage=0
    [14054.849659] (WT) UPDATE ss->mLevelStage=L10 decideAction=5
    [14054.855197] (WT) MORE ME UPDATE newLS=L10 nextls=L10
    [14054.860210] (WT) UPDATE ss->mLevelStage=L10 advance=false
    [14054.865659] ilsPacketIO_CONTACT recv=false startIdx=0 len=255
    [14054.871456] ilsPacketIO_COMMUNICATE recv=false startIdx=2 len=255
    [14054.877603] sendLevelPacket us=L10 them=L10, len=2
    [14054.882441] WT00000000: a6 c4                                            ..
    [14054.889470] itcSideStateSetLastAnnounceToNow: timeoutVar=100, now=3438477, nextTo=3438572
    [14054.897710] sendLevelPacket (pushto=T) hdr=0xa6 got 2
    [14054.902812] (WT) REANNOUNCED L10, now=3438471, uto=3438259, new=3438572
    [14054.912141] recvLevelPacket us=L10 them=L10, pkt=L10
    [14054.917243] ET00000000: a2 c4                                            ..
    [14054.924279] ilsPacketIO_CONTACT recv=true startIdx=0 len=2
    [14054.929824] itcSideStateSetLastAnnounceToNow: timeoutVar=500, now=3438487, nextTo=3438884
    [14054.938064] ilsPacketIO_COMMUNICATE recv=true startIdx=2 len=2
    [14054.943948] (ET) UPDATE KITC them=L10
    [14054.947654] (ET) UPDATE reqmts level=0, ops=91665ae0
    [14054.952667] (ET) UPDATE reqmts level=1, ops=86da6820
    [14054.957678] (ET) UPDATE post reqmts enterlevel=1, enterstage=0
    [14054.963561] (ET) UPDATE ss->mLevelStage=L10 decideAction=5
    [14054.969107] (ET) MORE ME UPDATE newLS=L10 nextls=L10
    [14054.974120] (ET) UPDATE ss->mLevelStage=L10 advance=false
    [14054.999793] sendLevelPacket (pushto=T) hdr=0xa2 got 2
    [14055.011620] (ET) REANNOUNCED L10, now=3438438, uto=3438240, new=3438575
    [14055.026905] diffToNext=0, jifTil=159
    [14055.035909] kitc=1, timeout=4294906276, now=3438416
    [14055.047735] (SE) UPDATE KITC them=L00

with an ET-WT loopback cable.

:126]
[127:

Mon Feb 17 23:12:49 2020 OK.  I really really have to be working on
OTHER STUFF but we're finally making 'progress' here and I'm loathe to
give up on the state that I am still managing to hold in my head.

So going again here.[128:

Mon Feb 17 23:14:31 2020 Changing the default timeouts to 300/1000.

:128]

:127]
[129:

Mon Feb 17 23:26:07 2020 Implementing .require default

:129]
[130:

Tue Feb 18 01:50:26 2020 So one current issue is we don't announce if
advance returns false, even if we've changed stages.

We're wondering if we really need .advance at all.  At the moment it's
only used by the limiting cases:

    #define ALL_LEVELS_MACRO()                                    \
    /*         name   cust req tmo, pio, dcd, adv, state (NOT USED) */ \
    /* 0 */ XX(CONTACT,      1,  1,   1,   0,   1,            _)       \
    /* 1 */ XX(COMMUNICATE,  1,  0,   1,   0,   0,   _/*u16 ttoken*/)  \
    /* 2 */ XX(COMPATIBILITY,0,  0,   1,   1,   0, _/*MFZId tMFZId*/)  \
    /* 3 */ XX(COMPUTATION,  0,  1,   0,   0,   1,            _)       \

..but ilsAdvance_CONTACT is where we check for packet sync, so that is
pretty important.  ilsAdvance_COMPUTATION just returns false, but it
wouldn't be so bad to automatically infer that on the last level
anyway.

But the first advance matters.  Is it that we want .advance to be ||'d
with LS change, to decide when to announce?  That seems wrong.  We
want to announce every LS change once we have packet sync.  And it
almost seems like we'd prefer to announce all LS changes, period, with
some understanding that the announcement getting tossed somewhere
below when there's no packet sync.

But in any case it seems we definitely want to decouple announcements
from advancements.

:130]
[131:

Tue Feb 18 03:14:39 2020 So we have an awful lot of fingers in the
changing-the-LS pie inside updateKITC:

 - We begin with 'prevLS' captured on entry to updateKITC.  Now, could
   that have been changed, during recvLevelPacket, since the last
   updateKITC?  Or does recvLevelPacket just manipulate other state --
   like mThem -- but leave mUs alone?[132: Seems only mThem is touched..  :132]

 - The .require loop produces a maximum supported level[133: Tue Feb
   18 03:42:06 2020  ..that's in local 'newLS' and immediately stored
   in mUs.mLevelStage.  Not sure if we want to commit that fast but
   we'll see.

 - We then run .decide JUST FOR THAT NOW-STORED newLS, and get an
   action which leads to 'nextLS'.  So now there's 'prevLS', 'newLS',
   and 'nextLS', all at least potentially different.

 - Then we run .advance based on the then-prevailing mUs (== newLS
   ATM).  If it returns true, we set 'advanceLS' by incrementing
   newLS, if there's any headroom left considering MAX_LEVEL_NUMBER.

 - Then, AND ONLY THEN, we announce, if advanceLS ends up different
   than (effectively) newLS.

So that's clearly messed up.  We won't ever announce downshifts?

We should make whatever decisions about LS we want -- and that
obviously needs to be thought through again -- but then at the end of
updateKITC we should announce based only on the final LS vs the prevLS
we captured on entering.
[134:

Tue Feb 18 06:26:20 2020 So, post walk: How should the post-updateKITC
LS be determined?  Consider the factors:

 0: prevLS: The LS we had at the beginning of the updateKITC
 1: supportLS: The LS determined by the prev LS and the current support
 2: uTimeoutLS: The LS implied by the .timeout LevelAction if mUs timeout occured
 3: tTimeoutLS: The LS implied by the .timeout LevelAction if mThem timeout occured
 4: decideLS: The LS implied by the .decide LevelAction
 5: advanceLS: The LS implied by the .advance LevelAction

Derive:
 downLS : The min of whichever 1-3 are applicable.

If downLS < prevLS, then resultLS = downLS.
else {
   compute decideLS
   if decideLS < prevLS, then result = decideLS
   else {
     compute advanceLS
     if advanceLS > prevLS, then result = advanceLS
   }
}

then if resultLS != prevLS {
  mUs.mLevelStage = resultLS
  sendLevelPacket
}
[135:

Tue Feb 18 13:59:53 2020 So could we make it a find-first-down-LS loop
and only check advance if no downs are found?  And simplify things
that way?

:135]
:134]

:133]

:131]
[136:

Tue Feb 18 17:03:06 2020 Well, building clean again.  Now updateKITC
is basically just a loop and a check and a send:

    void updateKITC(ITCMFMDeviceState * mds)
    {
 ..
      for (i = 0; i < sizeof(lsEvals)/sizeof(lsEvals[0]); ++i) {
        LSEvaluator eval = lsEvals[i];
        nextLS = (*eval)(mds,prevLS);
        if (nextLS != prevLS) break; /* found a move, stop */
      }
      if (nextLS != prevLS) {
        ss->mLevelStage = nextLS;
        sendLevelPacket(mds,false); /*pushes timeout if sent*/
      }
    }

with the idea that '.advance' is last in the lsEvals:

    static LSEvaluator lsEvals[] = {
      &lsEvaluatorSupport,
      &lsEvaluatorUTimeout,
      &lsEvaluatorTTimeout,
      &lsEvaluatorDecide,
      &lsEvaluatorAdvance
    };

..and it's the only one that might go up in LS; all the rest go down
or stay the same.

With this 'clean' scheme, we may be going to sendLevelPacket when
there isn't PS, what will happen there?  [137:

Tue Feb 18 17:09:54 2020 What will happen is ilsPacketIO_CONTACT will
detect no PS and return 0, causing sendLevelPacket to NOT attempt to
send a packet but YES TO update the utimeout as if we had.

And ilsTimeout_CONTACT appears to set everybody's timeouts to 10k
jiffies (which is probably 10s?) which seems plenty long to come back
around and check PS.[138:

Tue Feb 18 17:26:52 2020 Hmm,

    root@beaglebone:~# getconf CLK_TCK
    100
    root@beaglebone:~#

and

/usr/include/asm-generic/param.h:6

    #ifndef HZ
    #define HZ 100
    #endif

suggest on my BBG, a jiffy is 1/100s, so 10k jiffies would be 100s..

:138]

:137]

:136]
[139:

Tue Feb 18 17:42:56 2020

RISKY BITS OFF

:139]
[140:

Tue Feb 18 17:51:53 2020 Have to break for cooking; just started
debugging.  Got to where ET and WT advanced to L01, but then it seems
that WT is thinking it's still L00 and is announcing L01 again..[141:

Wed Feb 19 01:13:39 2020 Added more logging to follow along closer.

RISKY BITS OFF

:141]

:140]
[142:

Wed Feb 19 03:08:44 2020 Still tracing through.  Bug in
lsEvaluatorSupport wasn't dropping us back when level support failed.
Still fussing with timeout and timedifferences.  Going again.

RISKY BITS OFF

:142]
[143:

Wed Feb 19 03:44:33 2020 OK so the lsEvals[] iteration has the problem
that it's not (necessarily or usually) pushing expired timeouts, so
they keep happening.

We wanted to tie the timeout push to sending level announcements but
that seems unreliable at least at present.  Could we say that just
returning the mTimeoutAction is grounds enough for pushing the
timeout, then it's somebody else's problem if they didn't do a send or
whatever due to that mTimeoutAction?[144:

Wed Feb 19 03:49:19 2020 Well, trying that.  But that still won't deal
with multiple timeouts hitting in a single updateKITC

:144]

:143]
[145:

Wed Feb 19 13:27:34 2020 OK, so we've made yet another new minor for
/dev/itc/itcevents.  If we can find a useful 9 bit code for itc
events, we can back-fit them into the existing itcpktevent.h framework
with a minimum of fuss.

Things we might like to know:

LS: dir6:3 + op0:1 + LS:5
  dir6:3 bits with 6,7 reserved
  op:  2 bits
  LS:  5 bits as 3+2 for L00..L72

    op0
     0 + newus
     1 + newthem

fmt6: 110:3 + op6:3 + dir6:3
    op6
     000 ITCDN
     001 ITCUP
     010 UPBEG
     100 UPEND
     101
     110
     111

fmt7: 111:3 + spec:6
    spec
     0000 RSRV
     0001 DO_REENTER
     0010 DO_RESTART
     0011 DO_RETREAT
     0100 DO_ADVANCE
     0101 DO_CONTINUE
     0110 TIMEOUT
     0111..1111 rsrv

:145]
[146:

Wed Feb 19 14:44:08 2020 So what's the deal here?  addPktEvent very
ominously says:

    /*MUST BE CALLED ONLY AT INTERRUPT LEVEL OR WITH INTERRUPTS DISABLED*/
    void addPktEvent(ITCPktEventState* pes, u32 event) {

but then all through itcpkt.c there are calls on ADD_PKT_EVENT, and no
calls on ADD_PKT_EVENT_IRQ, but only the latter disables interrupts..

itcpkt.c:304
  if (ret == 0)
    ADD_PKT_EVENT(makePktXfrEvent(PEV_XFR_TO_PRU, ipb->mPriority, log2in3(pktlen), prudev->mTempPacketBuffer[0]&0x7));

doesn't look to be at interrupt level -- it's (indirectly) called from
itcOBPktThreadRunner.

itcpkt.c:1678
      if (ret == 0)
        ADD_PKT_EVENT(makePktXfrEvent(PEV_XFR_FROM_USR, minor != PKT_MINOR_BULK, log2in3(copied), tmp[0]&0x7));

doesn't either -- it's (indirectly) called from itc_pkt_write.

So who's wrong: All those calls, or the scary comment (or both)?
[147:

Wed Feb 19 14:50:19 2020 So in 20190901333-pkt-traceevent-notes.txt, I
see this:

    Mon Sep  2 03:32:38 2019 Hmm for one thing we need to be calling
    ADD_PKT_EVENT_IRQ not ADD_PKT_EVENT..  I doubt that's our current
    issue though.

ah but then I also see:

    Mon Sep  2 05:29:13 2019 So we really have no explanation for the
    original page fault we saw.  We don't actually think we even need to
    use ADD_PKT_EVENT_IRQ either, because we're not doing interrupt stuff
    on the itc_pkt side.

So I think it's the scary comment that's (currently) wrong.
[148:

Wed Feb 19 14:53:37 2020 Changed the scary addPktEvent comment to:

    /*WARNING: IF INTERRUPT HANDLERS ARE IN USE (which they are evidently
      NOT in itcpkt), THEN THIS MUST BE CALLED ONLY AT INTERRUPT LEVEL OR
      WITH INTERRUPTS DISABLED */

[149:

Wed Feb 19 14:54:29 2020 OK, back to trying to sprinkle around some
ADD_IT_EVENT callshere..

:149]:148]
:147]
:146]
[150:

Wed Feb 19 15:25:01 2020 OK a first cut at /dev/itc/itcevents is
building successfully.  Time for

RISKY BITS OFF

:150]
[151:

Wed Feb 19 16:16:19 2020 Yikes, apparently the itc_pkt userspace event
decoder never made it into the T2-12 repo?!  I just copied (a version
of) it off of the old 4.4.54 keymaster --- which I had carefully NOT
yet reflashed --- and will stick in the repo now, but, yow.  That
could have been significant work lost.

RISKY BITS OFF

:151]
[152:

Thu Feb 20 05:31:20 2020 OK, well we've finally gotten t2trace working
plausibly here on 4.19.79.  And now we can START modifying it to read
/dev/itc/itcevents too.  It was a pretty big hack to force two event
streams together and it will be an even bigger gross hack to force a
third in the same way, so we'll need to smooth out the
next-event-picking logic, I'd think, in this process.

:152]
[153:

Thu Feb 20 16:08:07 2020 OK, time to make install and reboot and see
how the events trace out.  Committing this stuff.

:153]
[154:

Thu Feb 20 16:25:25 2020 OK so we're starting to get plausible KITC
trace data, and it's tending to confirm a suspicion I had before.
Check this out:

    0134  8.639570sec   +0usec 19a:K (SW) UPEND: update end

..Random unconnected itc (SW) updateKITC ends

    0135  8.639570sec   +0usec 193:K (WT) UPBEG: update begin

WT updateKITC begins.  WT and ET are on loopback.

    0136  8.639570sec   +0usec 1c7:K     [TIMEOUT: timeout]

Some kind of timeout happens..  Not a super useful report. :(

    0137  8.639574sec   +4usec 0e1:K (WT) u->L01

WT announces L01 (which just means it's got packet sync).

    0138  8.644826sec   +5msec 0d6:P   <WT to PRU 2-4>

And that packet gets pushed to the PRUs immediately (!?).  Note that
the WT updateKITC is apparently still in progress.

    0139  8.644956sec +130usec 001:K (ET)  t->L01

And ET receives the packet, and updates its 'them' to L01

    0140  8.644956sec   +0usec 1c7:K     [TIMEOUT: timeout]

Another timeout.  I think this means (ET) just pushed its 't' timeout
in response to receiving the WT level packet.

    0141  8.644960sec   +4usec 190:K (ET) UPBEG: update begin

Now ET begins an updateKITC, called from recvLevelPacket

    0142  8.644960sec   +0usec 1c7:K     [TIMEOUT: timeout]
    0143  8.644964sec   +4usec 021:K (ET) u->L01

..and announces L01

    0144  8.650093sec   +5msec 198:K (ET) UPEND: update end

and its updateKITC ends.

    0145  8.650278sec +185usec 0d2:P   <ET to PRU 2-4>

and that packet ships..

    0146  8.650318sec  +40usec 19b:K (WT) UPEND: update end

and ONLY NOW the original? WT updateKITC FINALLY ends

    0147  8.650387sec  +69usec 0c1:K (WT)  t->L01

and the ET LP is received

    0148  8.650387sec   +0usec 1c7:K     [TIMEOUT: timeout]

and the WT t timeout is pushed.

    0149  8.650392sec   +4usec 193:K (WT) UPBEG: update begin

and WT begins another updateKITC..

[155:

Thu Feb 20 16:46:49 2020 So the surprising part of that for me is that
we didn't get (WT) UPEND before 0138 or 0139 at the latest.

:155]
:154]
[156:

Fri Feb 21 01:06:29 2020 OK so we're trying to understand the timeout
code we wrote in itcLevelThreadRunner, but we're not getting very far.
Can we review our intentions here?

 - We want to find the nearest future timeout over all the KITCs,

 - Taking into consideration that when we updateKITC one, that may
   change its timeout, and we want to consider its post-update
   timeout.

But waaaait.  Just back in :154: we were complaining about apparent
recursive entries into updateKITC, and we changed code like this:

      /* handle the packet */
      recvLevelPacket(ds,packet,len);

      /* then update their state machine*/
      updateKITC(ds);

to code like this:

      /* handle the packet */
      recvLevelPacket(ds,packet,len);

      /* then update their state machine*/
      wakeITCLevelRunner(); /*by waking the level runner?*/

but that doesn't make much sense: The level runner is only calling
updateKITC when the KITC timeout has expired.  Receiving a level
packet desires consideration of an immediate response, but just waking
the backstop timeout thread won't do that.

We either want to accept recursive entry to updateKITC, or explicitly
expire the timeout before calling wakeITCLevelRunner.

But we don't really want to expire the timeout, because we have
semantics associated with handling expired timeouts that we don't want
to do.

No, we kind of must want to call updateKITC directly when we have new
information for a KITC to consider.

We still don't understand how we ended up reentering updateKITC.  We
have like:

 updateKITC ->
   sendLevelPacket ->
     trySendUrgentRoutedKernelPacket ->
       kfifo_in to buffer
       wakeOBPktShipper ->
         wake_up_process
       <-
     <-
   <-
 <-

but we really think that path should end there and we'd exit
updateKITC before seeing any packets handled..

And we have:

 itc_pkt_cb ->
   handleKITCPacket ->
     recvLevelPacket
     updateKITC ->
       (as above)

Although.. rpmsg does interrupt us, doesn't it, when there's a buffer
to deliver.  Is that somehow what's going on?  Does itc_pkt_cb really
run at interrupt level?  I don't think so?  [157:

Fri Feb 21 03:17:44 2020 Or yes?  There's some random user process,
say, running when the PRU signals a packet incoming to linux.  That
causes an interrupt, which traps to the kernel (which is mapped into
all address spaces), and itc_pkt_cb runs?  But the interrupt has
already been dismissed by that point?  If so, what process or thread
or whatever got context-switched to to 'own' the callback processing?
I really don't understand this stuff.

:157]

:156]
[158:

Fri Feb 21 06:45:22 2020 OK but we have to do SOMETHING about the
timeout handling in the level runner; currently, we're instantly
blowing out our KITC buffer with as many of these as needed:

    2028  0.001372sec   +0usec 1cb:K             [LATE: going again]
    2029  0.001374sec   +2usec 1c9:K             [BITR: begin iteration]
    2030  0.001374sec   +0usec 1cb:K             [LATE: going again]
    2031  0.001374sec   +0usec 1c9:K             [BITR: begin iteration]
    2032  0.001376sec   +2usec 1cb:K             [LATE: going again]
    2033  0.001376sec   +0usec 1c9:K             [BITR: begin iteration]

:158]
[159:

Fri Feb 21 14:04:27 2020 Try again.  High-level timeout-related
functions of updateKITC:

 - ..

What if we got more explicit about being like a priority queue?  That
would mean we could simplify the loop to just 'sleep until nearest
timeout, pull off soonest thing, update it, reinsert it'.  But mainly
I'm thinking we probably really need to be thinking about locking
access to the (however real) priority queue, so that callbacks at
interrupt level can't step on in-progress pq ops.

I guess that was part of the rationale to want to have receiving
packets just kick the level runner rather than calling updateKITC
directly.  If the idea is that we understand the 'them' state is ONLY
modified at interrupt level by packet reception (modulo init and
timeout), but the level runner is the only place that calls
updateKITC..  And we have 'them' include a 'last modified' time, and
the us include a 'last examined' time, and updateKITC begins by
checking if the former is newer than the latter, and ends by setting
the latter to 'now'.

Then we can have the level runner call updateKITC on everybody at any
time, and then go to sleep for a say fixed amount of time, counting on
packet receptions and status changes to wake us early.

[160:

Fri Feb 21 14:41:00 2020 And this is a THIRD time-related field in the
KITC structs??  Or it's somehow a reinterpretation of what we have?

 mThem.mModTime  last time Them status was written
 mThem.mTimeout  when we'll act for them being overdue

   mUs.mModTime  last time Us status was checked
   mUs.mTimeout  when we'll act for us being overdue

and level runner iterates over the kitcs, and calls updateKITC on each
one whose mThem.mModTime is newer than them mUs.mModTime, and sets the
mUs.mModTime to now after each updateKITC is done.

[161:

Fri Feb 21 15:43:49 2020 But how does that deal with the timeouts?  It
seems like it doesn't at all.  And maybe it's not supposed to,
somehow?  After the level runner iterates over the KITCs, how long
does it sleep?

It does seem like it must be the level runner's job to ALSO deal with
noticing the timeouts, since really nobody else can.  But it would be
nice if we could at least pull that apart from the 'modtime'
considerations.

Could we 'just' also run the updateKITC if mModTime is older than
mTimeout, for either mUs or mThem? [162: Well that doesn't make sense
assuming the mTimeout is mostly supposed to be in the future and
mModtime is always <= now..  :162]

level runner:
  PHASE 1: REACT
  kitc iterator:
    if mThem.mModTime > mUs.mModtime  // world changed
       || mThem.mTimeout < now        // or world isn't going to change
       || mUs.mTimeout < now          // time for us to try again
      updateKITC
      mUs.mModtime = now

  PHASE 2:
  kitc iterator:
    find nearest future mThem.mTimeout or mUs.mTimeout

  PHASE 3:
  if negative, warn and pick 100ms
  if >1s pick 1s
  schedule_timeout(forthattime);


:161]

:160]

:159]
[163:

Fri Feb 21 16:53:31 2020 Looking around the web, this seems like a
potentially explanatory factoid:

    wake_up_sync and wake_up_interruptible_sync

    wake_up_sync(&wq);

    wake_up_interruptible_sync(&wq);

    Normally, a wake_up call can cause an immediate reschedule to
    happen, meaning that other processes might run before wake_up
    returns. The “synchronous” variants instead make any awakened
    processes runnable, but do not reschedule the CPU. This is used to
    avoid rescheduling when the current process is known to be going
    to sleep, thus forcing a reschedule anyway.

Now, I can't find a wake_up_sync identifier in bootlin 4.19, though
wake_up_interruptible_sync is there.. but I'm currently using
wake_up_process and I don't understand the relationship there.

:163]
[164:

Fri Feb 21 17:38:49 2020 But also, suppose we reinterpret mTimeout as
an offset rather than an absolute time.  So the absolute timeout is
mModTime+mTimeout.  But then when do we rerandomize the
mTimeoutOffset?  If we do it whenever mModTime changes what have we
gained?  If we only do it when it expires aren't we risking long-term
dirt-at-the-edge-of-the-road bias for lucky long time outs?

:164]
[165:

Sat Feb 22 03:55:28 2020 So ITCSideState already has:

  unsigned long mLastAnnounce;  /* Time in jiffies (by local clock) */

which is currently declared, initted, updated by
'itcSideStateSetLastAnnounceToNow':

    ./itcmfm.h 71:  unsigned long mLastAnnounce;  /* Time in jiffies (by local clock) */
    ./itcmfm.c 497:  ss->mLastAnnounce = now - (prandom_u32_max(50)+(isUs ? 100 : 10));
    ./itcmfm.c 69:  ss->mLastAnnounce = now;

and never otherwise referenced.  Could we rename/use that as mModTime?

:165]
[166:

Sat Feb 22 04:53:36 2020 Well, renamed mLastAnnounce to mModTime and
did a cut at :161: above.

RISKY BITS OFF

:166]
[167:

Sat Feb 22 05:18:39 2020 Well have to travel today, so committing all
this as a WIP.  Starting to get there..

:167]
[168:

Mon Feb 24 14:58:22 2020 All right, so back from Denver trip and
trying to figure out where we are.

For example, we are recording an 'INCOMPLETE CODE' event at
itcmfm.c:246, and we're really unsure what is supposed to go there.

Let's recap.

 - We are in recvLevelPacket <- handleKITCPacket <- itc_pkt_cb.

 - We have just gone through the levels calling .packetio, letting
   each applicable level have a(n incremental) crack at parsing the
   packet.

 - After recvLevelPacket returns we are going to wake the level runner
   and then call the processing of that packet done.

 - The level runner will always call updateKITC if 'them' have a more
   recent mModtime than 'us', so if recvLevelPacket updated
   mThem.mModtime, then we should get updated on the next level runner
   opportunity.

So, questions:

 - Who guarantees that mThem.mModTime gets touched by that process?

 - What if anything else needs to happen at packet reception time?

We're increasingly leaning to thinking the answer to the latter
question is: Nothing.  That the purpose of packet reception time is
just to parse info from the packet into itcSideState mThem, update
mThem.mModTime, and kick the level runner.

So maybe there's nothing more to do there?

Maybe.

And who does guarantee mThem gets touched?[169:

Mon Feb 24 15:17:00 2020 Right now that's happening in
ilsPacketIO_CONTACT:

itcmfm.c:389
    /* Pick up their info*/
    ss = &ds->mLevelState.mThem;
    ss->mLevelStage = byte1 & 0x1f;

    ADD_ITC_EVENT(makeItcLSEvent(ds->mDir6,IEV_LST,ss->mLevelStage));
    itcSideStateTouch(ss);

So from one point of view that's a pretty random place, but it kind of
makes sense too.. and with the 'accumulating levels' approach to
packet generation and parsing, we're pretty much guaranteed to pass
through that sequence.

So, way back in :59: we show the COMMUNICATION layer sending and
receiving 'seqno's.  Are we still going to do that?  What was the
intended semantics?[170:

Mon Feb 24 16:10:19 2020 So from :57: it seems like seqno is the
randomized MFZid write count, used to reduce the risk of missing a
mfm restart of the same physics.  It seems we could maybe go ahead and
give that a try..

One thing about it, though, we were planning on send a 'confirm' level
packet containing both our seqno and our belief about theirs.  How
would that work with this recv-just-dumps-to-mThem strategy?  It would
seem like the confirmation would have to happen at parse time rather
than during updateKITC?  But at this point we're pretty scared of
making any decisions outside of updateKITC, since we see the level
runner getting suspended in the middle of one updateKITC pretty often.

I guess we could just send u.seqno on both exchange and confirm.

We also need to understand how the exchange vs confirm idea interacts
with the 'accumulating packets' idea.  It seems like we'd send the
exchange info for a level only when we're below .2 on that level..
[171:

Mon Feb 24 16:31:38 2020 So, wait, isn't the sender's level part of
every level packet?  Where does that fact appear in :59:?  [172:

Mon Feb 24 16:34:24 2020 Contrary to :59:, itcmfm.c is currently
exchanging LS in ilsPacketIO_CONTACT..  Not quite sure how that
interacts advancing on packet sync, though..[173:

Mon Feb 24 16:41:03 2020 Maybe we should ditch the exchange/confirm
thing, and use moving-on-to-next-level as a confirm.  The next level
obviously has a different packet format, so that's all okay.

Ah and the reason ilsPacketIO_CONTACT can send LS is because it gets
called for EVERY level packet, not just when we are at level CONTACT.
[174:

Mon Feb 24 16:57:26 2020 So let's try a :59: redo with our 'more
modrun' thinking and see what it looks like.
[175:

Mon Feb 24 16:58:04 2020

 - KITCs are updated ONLY from the level runner.
   = External triggers (ITCCHANGE, L rcvd) only store state in mThem
     and wake the level runner.

 - Level packet generation and parsing is cumulative, however, the
   CONTENTS of the per-level data can change depending on the current
   actual level at the time of packet generation.  .packetio parsers
   must consider the LS supplied in the packet when determining how to
   parse.[176: Mon Feb 24 22:19:58 2020 Call it the 'active' content
   vs the 'residual' content.  [177: Tue Feb 25 06:44:43 2020

 - Most recently received peer level info is stored in 't', and 't's
   mModTime is then set to jiffies iff the peer level info ACTUALLY
   CHANGED.  mModTime is NOT CHANGED IF packet 't' data is the same as
   currently stored.  We're taking this as an invariant to get the
   system to settle SO DON'T FOG THIS UP during debugging scrambles.

 - 't' data is reset on restart or [MAYBE?] if T timeout expires.

 - update phases are:
   = Check REQUIREMENTS from 0 to current level.  If currently
     supported level < previous level, enter at currently supported
     level, stage 0.  Otherwise enter at previous level, previous
     stage.
   = If mThem.mModTime is newer than mUs.mModTime, REACT at current
     level.  Reaction involves examining level-appropriate mThem data,
     making computations and decisions based on that, and yielding a
     new LS for mUs.
   = Otherwise (mThem.mModTime is not newer than mUs.mModTime), check
     timeouts.

     - If mUs.mTimeout has expired, we think maybe there was a lost
       packet, and we resend our current LS, and push our timeout

     - If mThem.mTimeout has expired, we think they're dead and we
       restart (drop to L00).

       [178: Tue Feb 25 10:52:11 2020 Now it does kind of seem like if
       we're saying that's the meaning of the two timeouts, we could
       fold that down to like one timeout plus a count.  Which isn't
       really less state so much as it is less flexible state, which
       is of course good if it's enough.[179:

       Tue Feb 25 16:02:01 2020 So this line is suggesting that
       there's only two underlying causes of timeouts -- transient
       packet loss and durable peer loss -- and we're trying to
       distinguish those two cases and respond differentially.

       Do we believe that framing of the issue?  What else could it
       be?  [180: Tue Feb 25 16:09:03 2020 Well, not immediately
       coming up with other possibilities...  Peer is temporarily
       delayed?  But we'd handle that but setting these timeouts
       fairly generously anyway?[184: Tue Feb 25 17:08:49 2020 What
       about the case "Everything seems fine but (I believe,
       apparently) I have the initiative so I should advance"?  If
       that is NOT determined by a timeout, what IS it determined
       by?[186:

       Wed Feb 26 06:40:08 2020 I guess the point is, except for the
       very beginning, in the error-free case it should all be
       ping-pong, with nobody needing to decide to spontaneously 'do
       something'.  So maybe it is the timeout error case..  Which
       would mean we do need custom timeout code grrr? :186]

       (Urgh time to cook.) :184]

       I'm thinking we should go with mTimeout + mRetries as part of
       this round's redo..  And could we please get rid of the
       .timeout callback and make it two per-level constants -- a
       timeout and a retry count? :180]

       :179] :178]


 mThem.mTimeout has expired, drop back
     level packet after possibly changing LS.

     jiffies is later than mUs.mTimeout, then resend current level
     packet, and push our timeout.

:177]  :176]

:175]

:174]

:173]

:172]

:171]

:170]

:169]

:168]
[181:

Tue Feb 25 16:40:08 2020 So let's take a run at the tables again.

ALL_LEVELS_MACRO args:
  name
  timeoutms
  retrycount
  customreq
  customactive   ? implies ilsActivePacketWrite_LEVEL and ilsActivePacketRead_LEVEL
  customresidual ? implies ilsResidualPacketWrite_LEVEL and ilsResidualPacketRead_LEVEL
  customreact    run when mThem is newer than mUs
  customact      [183: hmm.  :183]

[182: Tue Feb 25 16:50:34 2020 Or how about just

  custompacket   implies ilsPacketWrite_LEVEL(bool act) and ilsPacketRead_LEVEL(bool act)

for active and residual.

:182]

:181]
[185: Wed Feb 26 06:38:06 2020 Go again.

ALL_LEVELS_MACRO args:
  name
  timeoutms
  retrycount
  customreq
  custompacket   implies ilsPacketWrite_LEVEL(bool active) and ilsPacketRead_LEVEL(bool active)
  customreact    run when mThem.mod is newer than mUs.mod
  customact      run when mUs.timeout*retrycount expires?

:185]
[187: Wed Feb 26 13:52:10 2020 Again.

ALL_LEVELS_MACRO args:
  name
  customreq
  customtalk     implies ilsPacketWrite_LEVEL(bool active) and ilsPacketRead_LEVEL(bool active)
  customreact    run when mThem.mod is newer than mUs.mod
  customact      run when mUs.timeout expires; may originate, retry, ...
  timeoutms
  retrycount

ACTIONS:
 ENTER:   S = 0
 ENGAGE:  S = 1
 EXIT:    S = 2
 INIT:    LS = 0.0
 CONTINUE: nothing
 DEFAULT: call default processing

DEFAULT LEVEL VALUES:
  Requires:      t>=(L-1).1
  Talk:          nothing
  React:         (1) L++,S=0 if t>=L.1 && u==L.2; (2) S++ if u <= L.2 && t>=L.0; CONTINUE
  Act:           ENTER if retries-- > 0, else INIT
  TimeoutMS:     500ms
  RetryCount:    3

Level 0 CONTACT
  Requires:      t>=0.0 (always true)
  Talk:          write u.LS, read t.LS
  React:         DEFAULT
  Act:           ENGAGE if S==0 && PacketSync; START if !PacketSync
  TimeoutMS:     1000ms
  RetryCount:    1

Level 1 COMMUNICATION
  Requires:      PacketSync
  Talk:          write u.seqno+u.oseqno, read t.seqno+t.oseqno
  React:         INIT if u.oseqno != t.seqno || u.seqno != t.oseqno, else DEFAULT
  Act:           DEFAULT

Level 2 COMPATIBILITY
  Requires:      DEFAULT
  Talk:          if active, write u.MFZId, read t.MFZId, else write u.d, read t.d
  React:         INIT if u.oseqno != t.seqno || u.seqno != t.oseqno, else DEFAULT
  Act:           DEFAULT


:187]
[188:

Fri Feb 28 04:46:02 2020 Results of fresh thinking yesterday
afternoon: Instead of focusing on turn-taking, avoiding races, and
using rare large timeouts, suppose we should focus on synchronization,
CAUSING races, and using frequent small timeouts.

Ideally you'd like to always have matching packets passing each other
mid-flight; both sides would send and then receive the matching
packet, in that order.

Elaboration: Instead of having arbitrary timeouts with random
variation to avoid races, have fixed timeouts with adaptive phase
shifting to cause races.

So, let's do a synchronization spike.

s1: On PS, pick a random # and send it once a second.  Agree who got
    the bigger number, and have the smaller sync to the larger.

s2: Add a /sys/class/itc/syncstats or something to show recent sync
    accuracy

[189:

Fri Feb 28 13:07:14 2020 So how would kitc sync work?  When we detect
packet sync we pick a non-zero 8 bit random #, and store it in mUs
ITCSideState.  We send a (level) packet containing that # plus a 0,
indicating that we haven't learned the other side's # yet.

When we get such a packet, we check if its number is different than
ours.  If it happens to be the same we start over and repick ours.  If
it's different we store it in mThem ITCSideState.

Then we decide who wins based on wraparound distance between the
numbers -- the one that's 'forward' from the other is the leader.  If
we're the leader we send a 'leader announcement' packet and then set a
timeout in the future by the full period for this interaction.  If
we're the follower we wait to receive one.

When we receive a leader announcement packet we note the time and
schedule a timeout at half the fixed period for this interaction.  At
that time we reply with the matching follower announcement packet of our
own.  When the leader

:189]

:188]
[190:

Fri Feb 28 13:36:35 2020

LRru         reset.  r=my reset generation; u=my rnd byte.  reset in reply
LLrusv       I am leader given r=us resgen, u=us rnd byte; sv=them
Lxrusv       I am x=L:leader|F:follower given rusv (== your svru)
LIsmfz       I am on seqno s and running mfzid mfz
LCsr

:190][191:

Fri Feb 28 14:07:30 2020 Ah, so one advantage of just setting a
timeout and replying in tempo, rather than replying immediately, is
that you get a chance to soak up repeated packets that may have ended
up delayed in the channel somewhere.  If the other guy is repeatedly
sending a reset then timing out and sending another, because we're
still booting or something, then we might get a pile of those resets
in a row, but we'll likely only reply to the last one, because the
the previous ones will just keep pushing back our timeout.[192:

Fri Feb 28 14:31:12 2020 So come on.  How could we set up to implement
this real quick.  The point of it is to agree as quickly as possible
on a half-period spread based on Leader/Follower, and then expect that
for all subsequent interactions, the follower's reply to the leader's
previous packet will have arrived before the leader runs again.

So the level runner loop is:

 - While stop not requested,

   = Pick nearest timeout.

   = If that's now or past, do it, then continue.

   = Otherwise, sleep til the nearer of when it's due or for some max
     sleep, then continue.

and the packet receive handler is:

 - Call packet-specific processing

 - Packet-specific processing generally updates internal state, but it
   does not send packets.  It may adjust the timeout (and it wakes the
   level runner if it shortens any timeout).

Packet-specific processing:

 o On asynchronous reset condition:
   (1) Clear urnd and trnd
   (2) set state to RESET
   (3) set timeout to random small

 = timeout in state RESET
   (1) (Tie do-over)
       if urnd!=0 && trnd!=0 && urnd == trnd then
         async reset, end
   (2) (Election)
       if urnd!=0 && trnd!=0 && urnd != trnd
          && urnd == turnd then
         LEADER = beats(urnd,trnd)
         set state to CONFIG
         clear tmfzid
         push timeout a whole period, end
   (3) (Vote)
       if urnd==0 then
         pick urnd
   (4) send RESET urnd trnd
   (5) push timeout a full period

                                                 - recv RESET trnd turnd:
                                                   (1) captures trnd and turnd
                                                   (2) sets state to RESET
                                                   (3) if turnd==0 then
                                                         clear urnd
                                                   (4) push timeout half-period


                                                  = timeout in state RESET
                                                       ..as above..


 = timeout in state CONFIG
   (1) (Compatibility)
       if LEADER && tmfzid == mfzid
   (2) ()

   (3) send CONFIG mfzid

 - recv CONFIG mfzid
   (1) captures tmfzid = mfzid
   (2)




         if LEADER then
           send CONFIG mfzid



                      async reset->s==?
                         urnd = trnd = 0
                         s = RESET
            +small                             0.0
                      to RESET
                         urnd=3
                         send LR30
                         wait whole     +small    LR30->s==?
                                                    trnd=3, turnd=0
                                                    s=RESET
                                                    urnd=0
                                                    wait half

                                         +half  0.5
                                                    to RESET
                                                       urnd=4
                                                       send LR43
                                                       wait whole
                                         +small

                      LR43->
                        trnd=4, turnd=3
                        s=RESET
                        wait half

                                         +half  1.0
                      to RESET
                         LEADER=beats(3,4)=false
                         s=CONFIG
                         wait whole
                                         +half  1.5 to RESET
                                                       LEADER=beats(4,3)=true
                                                       s=CONFIG
                                         +small        wait whole
                       LCdreg3->



:192]

:191]
[193:

Sat Feb 29 01:58:46 2020

reset
   go LEAD
   randomwait

to LEAD
   send
   go WLEAD                    rc LEAD
   fullwait                       if in(WLEAD) and onein(2) then
                                    reset
to (WLEAD,WCONFIG)                go FOLLOW; halfwait
   reset


                               to FOLLOW
                                  send
                                  go WFOLLOW
                                  fullwait

rc FOLLOW                      to WFOLLOW
   if !in(WLEAD) then             reset
     reset
   else
     go CONFIG; halfwait

to CONFIG
   send config                 rc CONFIG config
   go WCONFIG                     if !in(WFOLLOW) then
   fullwait                         reset
                                  tconfig = config
                                  go CHECK
                                  halfwait


                                to CHECK
to WCONFIG                         send uconfig
   reset                           if uconfig == tconfig then
                                     go COMPATIBLE
                                   else
                                     go INCOMPATIBLE
                                   fullwait


rc CHECK config
   if !in(WCONFIG) then reset
   tconfig = config
   if uconfig == tconfig then
     go COMPATIBLE
   else
     go INCOMPATIBLE
   fullwait

                        to (COMPATIBLE,INCOMPATIBLE)
                          send
                          longwait

rc COMPATIBLE
  if !in(COMPATIBLE) then reset

rc INCOMPATIBLE
  if !in(INCOMPATIBLE) then reset

rc MFMTRAFFIC
  if !in(COMPATIBLE) then drop
  else forward

[194:

Sat Feb 29 03:28:03 2020 OK, well, could that trace actually imply a
pretty heavily simplified but possibly actually workable complete
scheme?  Key ideas are:

 - Whoever resets first tries to be the leader.

 - If a leader race is detected, half the time we accept the later one
   and half the time we re-reset.  Hmm if we both accept the later one
   couldn't we have a FOLLOW-FOLLOW stalemate and lose the reset?[195:
   Sat Feb 29 03:33:38 2020  Well we'll still re-reset a little bit
   later, when 'to FOLLOW' sends, leading to 'rc FOLLOW' when not in
   WLEAD.  "So maybe it's okay?" [196: Sat Feb 29 03:37:25 2020

 - Leader and follower have nearly disjoint sets of states, up until
   COMPATIBLE and INCOMPATIBLE.  That seems a handy way to keep things
   separate, and since the simplified path is so short, the state
   duplication isn't so so much.

 - There's several 'transient' states (at least WLEAD,WFOLLOW,WCONFIG)
   that aren't expected to timeout, so they all just reset if timeout
   does occur.  But they want to be different states to detect
   sequence problems while receiving packets.

:196]:195]


:194]
:193]
[197:

Sat Feb 29 04:15:32 2020 OK so let's try infrastructure to implement
the :193: approach.

 XX(NAME,DESC,CUSTO,CUSRC)

enum StateNumber {
  S_##NAME,
};

enum StateMask {
  M_##NAME = 1<<S_##NAME,
};

const char * stateNames[] = {
 #NAME,
};

const char * stateDesc[] = {
 #DESC,
};

 YY0 void timeoutDefault_KITC(ITCMFMDeviceState * mds) ;
 YY1 void timeout_##NAME##_KITC(ITCMFMDeviceState * mds) ;

 YY##CUSTO(NAME)

 YY0 void receiveDefault_KITC(ITCMFMDeviceState * mds, const u8 * packet, u32 len) ;
 YY1 void receive_##NAME##_KITC(ITCMFMDeviceState * mds, const u8 * packet, u32 len) ;

 YY##CUSRC(NAME)



Default TO: reset
Default TC: reset

Packet format:
 byte[0] 1010SDR  3 bit source/dest dir
 byte[1] 110STNM  5 bit state number
 byte[2]+ optarg

Wait codes
  WC_RANDOM    -> 10..1000ms
  WC_HALF      -> 150ms
  WC_FULL      -> 300ms
  WC_LONG      -> 10000ms

Helper functions:

 void goToStateKITC(ITCMFMDeviceState * mds, StateNumber sn, WaitCode wc) ;
 u32 initPacketKITC(ITCMFMDeviceState * mds, const char * pb) ;
 void resetKITC(ITCMFMDeviceState *mds) ;
 void pushTimeoutKITC(ITCMFMDeviceState * mds, u32 msFromNow) ;

 bool passingMFMTrafficKITC(ITCMFMDeviceState * mds) ;

:197]
[198:

Sun Mar  1 03:55:59 2020 OK, back after diverting to push the Michael
Frank Computing Up.  I have MAYBE one more day I can spend on this.
Based on :193: and :197: we should be able to get to passing MFM
packets only when compatible.  Let's get foggen kraken:

TODO

[199: Sun Mar  1 04:53:38 2020
DONE :199] - Redo XX macros based on :197:

[200: Sun Mar  1 04:57:27 2020
DONE :200] - Redo side struct

[201: Sun Mar  1 04:57:40 2020
DONE :201] - Redo state ops struct

[202: Sun Mar  1 05:34:20 2020
DONE, first cut :202] - Redo level runner.

[204: Sun Mar  1 16:06:11 2020
DONE :204] - Implement default behaviors

[205:
DONE :205] - Implement custom behaviors

 - Redo event tracing

[226: Mon Mar  2 04:30:37 2020
DONE :226] - See loopback events to compatibility

:198]
[203:

Sun Mar  1 16:05:58 2020 Well, it built..[206: Sun Mar  1 16:06:32
2020  Next up is pull bits off and trying it, but about it's time to
cook so that'll be after the evening.  :206]

:203]
[207:

Mon Mar  2 00:48:31 2020 'Real quick' let's add a state at the
beginning that waits for PS.

reset
   go WAITPS
   randomwait

to WAITPS
   if PS go LEAD
   longwait

[208:

Mon Mar  2 01:26:05 2020 OK well did that.

Left it so the 'if PS go LEAD' doesn't actually push the timeout, so
it'll (race to) retimeout and do 'to LEAD' immediately.  Seems
inefficient but rare.

Well, I think we're at

RISKY BITS OFF

:208]
:207]
[209:

Mon Mar  2 01:31:37 2020 OK trying make install.[210:

Mon Mar  2 01:34:24 2020 Well, modprobe itc_pkt blew up with

    Mar  2 01:33:49 beaglebone kernel: [582362.953671] kernel BUG at /home/t2/T2-12/pru/itcio/module/itcpkt.c:2126!

I think because we still have issues with minor devices not getting
cleaned up quite right, or something..

..so rebooting.. we shall see.

:210]

:209]
[211:

Mon Mar  2 01:38:27 2020 Well we're alive..  Not sure what if anything
we'll be able to see, here, before we redo the kitc event
tracing.. but about to try plugging in the loopback..[212:

Mon Mar  2 01:39:39 2020 Well that was a bit of an anticlimax:

    Mar  2 01:39:22 beaglebone mfm.sh[1767]: ITCSPIKE-92103199200283: MSG: Tile Level 2: Accepting events
    Mar  2 01:39:22 beaglebone kernel: [  190.884393] ITCCHANGE:UP:WT
    Mar  2 01:39:22 beaglebone kernel: [  190.887379] ITCCHANGE:UP:ET
    Mar  2 01:39:25 beaglebone mfm.sh[1767]: ITCSPIKE-92103199200284: MSG: Tile Level 0: Quitting
    Mar  2 01:39:25 beaglebone mfm.sh[1767]: ITCSPIKE-92103199200285: MSG: Tile Level 1: Starting MFZ1
    Mar  2 01:39:26 beaglebone mfm.sh[1767]: ITCSPIKE-92103199200286: MSG: Tile Level 2: Accepting events
    Mar  2 01:39:28 beaglebone cdm.sh[1768]: WT is alive
    Mar  2 01:39:31 beaglebone kernel: [  199.643244] ITCCHANGE:DOWN:ET
    Mar  2 01:39:32 beaglebone kernel: [  200.065467] ITCCHANGE:DOWN:WT
    Mar  2 01:39:42 beaglebone mfm.sh[1767]: ITCSPIKE-92103199200287: MSG: Tile Level 0: Quitting

[213:

Mon Mar  2 01:43:31 2020 OK!  This is more like it:

    root@beaglebone:~# echo f00 > /sys/class/itc_pkt/debug ; sleep 10; echo 0 > /sys/class/itc_pkt/debug
    Mar  2 01:43:01 beaglebone kernel: [  409.703717] set debug f00
    Mar  2 01:43:05 beaglebone kernel: [  413.731031] ITCCHANGE:UP:WT
    Mar  2 01:43:05 beaglebone kernel: [  413.733950] recvLevelPacket us=WAITPS pkt=CHECK+3
    Mar  2 01:43:05 beaglebone kernel: [  413.738857] ITCCHANGE:UP:ET
    Mar  2 01:43:05 beaglebone kernel: [  413.741684] recvLevelPacket us=WAITPS pkt=LEAD+2
    Mar  2 01:43:05 beaglebone kernel: [  413.746414] ====================
    Mar  2 01:43:05 beaglebone kernel: [  413.898190] ====================
    Mar  2 01:43:05 beaglebone kernel: [  413.901718] recvLevelPacket us=WAITPS pkt=FOLLOW+2
    Mar  2 01:43:05 beaglebone kernel: [  413.916777] ====================
    Mar  2 01:43:05 beaglebone kernel: [  413.962188] ====================
    Mar  2 01:43:05 beaglebone kernel: [  413.965505] ====================
    Mar  2 01:43:05 beaglebone kernel: [  413.979559] ====================
    Mar  2 01:43:05 beaglebone kernel: [  413.983064] recvLevelPacket us=WFOLLOW pkt=LEAD+2
    Mar  2 01:43:06 beaglebone kernel: [  414.138215] ====================
    Mar  2 01:43:06 beaglebone kernel: [  414.141727] recvLevelPacket us=WLEAD pkt=FOLLOW+2
    Mar  2 01:43:06 beaglebone kernel: [  414.155589] ====================
    Mar  2 01:43:06 beaglebone cdm.sh[1768]: ET is alive
    Mar  2 01:43:06 beaglebone kernel: [  414.298356] ====================
    Mar  2 01:43:06 beaglebone kernel: [  414.301886] recvLevelPacket us=WFOLLOW pkt=CONFIG+3
    Mar  2 01:43:06 beaglebone kernel: [  414.312771] ====================
    Mar  2 01:43:06 beaglebone kernel: [  414.458326] ====================
    Mar  2 01:43:06 beaglebone kernel: [  414.461871] recvLevelPacket us=WCONFIG pkt=CHECK+3
    Mar  2 01:43:06 beaglebone kernel: [  414.470568] ====================
    Mar  2 01:43:06 beaglebone kernel: [  414.618371] ====================
    Mar  2 01:43:06 beaglebone kernel: [  414.621929] recvLevelPacket us=COMPATIBLE pkt=COMPATIBLE+2
    Mar  2 01:43:06 beaglebone kernel: [  414.635653] ====================
    Mar  2 01:43:07 beaglebone kernel: [  415.250604] ====================
    Mar  2 01:43:07 beaglebone kernel: [  415.253913] ====================
    Mar  2 01:43:07 beaglebone kernel: [  415.270779] ====================
    Mar  2 01:43:07 beaglebone kernel: [  415.286664] ====================
    Mar  2 01:43:07 beaglebone kernel: [  415.289939] ====================
    Mar  2 01:43:09 beaglebone kernel: [  417.696325] recvLevelPacket us=COMPATIBLE pkt=INIT+2
    Mar  2 01:43:09 beaglebone kernel: [  417.701777] ====================
    Mar  2 01:43:09 beaglebone kernel: [  417.878615] ITCCHANGE:DOWN:ET
    Mar  2 01:43:09 beaglebone kernel: [  417.881780] ====================
    Mar  2 01:43:10 beaglebone kernel: [  418.227540] ====================
    Mar  2 01:43:10 beaglebone kernel: [  418.230850] ====================
    Mar  2 01:43:10 beaglebone kernel: [  418.304749] ITCCHANGE:DOWN:WT
    Mar  2 01:43:10 beaglebone kernel: [  418.931750] ====================
    Mar  2 01:43:11 beaglebone kernel: [  419.115792] ====================
    Mar  2 01:43:11 beaglebone kernel: [  419.119101] ====================
    root@beaglebone:~# Mar  2 01:43:11 beaglebone kernel: [  419.740930] set debug 0


:213]
:212]

:211]
[214:

Mon Mar  2 02:16:13 2020 Buncha quick tweaks

RISKY BITS OFF[215:

Mon Mar  2 02:17:26 2020 No good, minor blow-up again..  Rebooting.

:215]

:214]
[216:

Mon Mar  2 02:23:13 2020 OK, this is more interesting:

    root@beaglebone:~# echo f00 > /sys/class/itc_pkt/debug ; sleep 10; echo 0 > /sys/class/itc_pkt/debug
    Mar  2 02:20:59 beaglebone kernel: [  182.866584] set debug f00
    Mar  2 02:21:02 beaglebone kernel: [  185.064507] ITCCHANGE:UP:WT
    Mar  2 02:21:02 beaglebone kernel: [  185.067449] ITCCHANGE:DOWN:WT
    Mar  2 02:21:02 beaglebone kernel: [  185.070445] ITCCHANGE:UP:WT
    Mar  2 02:21:02 beaglebone kernel: [  185.073386] ITCCHANGE:UP:ET
    Mar  2 02:21:02 beaglebone kernel: [  185.076247] ITCCHANGE:DOWN:ET

I bobbled plugging the loopback connection creating some realistic
chatter..

    Mar  2 02:21:02 beaglebone kernel: [  185.079237] ITCCHANGE:UP:ET
    Mar  2 02:21:02 beaglebone kernel: [  185.082116] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.090002] ITC ET i11 -> i01

..lock stuff is happening as well..

    Mar  2 02:21:02 beaglebone kernel: [  185.167550] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.173910] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.187595] sendKITCPacket pkt=LEAD len=2 (to=WT)

WT reached 'to LEAD' first.  (That should be '(src=WT)' rather than
'to').

    Mar  2 02:21:02 beaglebone kernel: [  185.199410] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.511405] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.517749] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.548236] recvKITCPacket pkt=LEAD len=2 (us=[ET]WAITPS)

Packet arrives via loopback.  It took (- 185.548236 185.187595) ==
360ms, but hoping that's somehow got to do with 'WC_FULL_MS = 300,'...

Note that ET is in the 'new, last minute' WAITPS state -- it hasn't
even noticed the '[ 185.079237] ITCCHANGE:UP:ET' yet..

    Mar  2 02:21:02 beaglebone kernel: [  185.553866] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.619470] ITC ET i11 -> i01
    Mar  2 02:21:02 beaglebone kernel: [  185.703457] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.709836] sendKITCPacket pkt=FOLLOW len=2 (to=ET)

ET agrees it's the follower.

    Mar  2 02:21:02 beaglebone kernel: [  185.714890] recvKITCPacket pkt=FOLLOW len=2 (us=[WT]WAITPS)

This packet arrives a bit faster:  (- 185.714890 185.709836) == 5ms.

But why is WT in WAITPS?  It sent 'LEAD': We expect it to be in
WLEAD.  Not sure what's going on there -- WAITPS is now entered
asynchronously through resetKITC(), but what caused the reset?

    Mar  2 02:21:02 beaglebone kernel: [  185.727470] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.055463] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.063535] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.179476] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.185812] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.203717] recvKITCPacket pkt=LEAD len=2 (us=[WT]WAITPS)

That's confusing too.  ET now thinking it's the cheese?

    Mar  2 02:21:03 beaglebone kernel: [  186.209285] sendKITCPacket pkt=LEAD len=2 (to=ET)

And are we having a race or something?

    Mar  2 02:21:03 beaglebone kernel: [  186.229741] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.359494] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.365897] sendKITCPacket pkt=FOLLOW len=2 (to=WT)
    Mar  2 02:21:03 beaglebone kernel: [  186.370957] recvKITCPacket pkt=FOLLOW len=2 (us=[ET]WLEAD)

ET was in WLEAD this time, seems like some sanity is coming..

    Mar  2 02:21:03 beaglebone kernel: [  186.389138] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.527493] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.533878] sendKITCPacket pkt=CONFIG len=3 (to=ET)
    Mar  2 02:21:03 beaglebone kernel: [  186.538932] recvKITCPacket pkt=CONFIG len=3 (us=[WT]WFOLLOW)

We've gotten to CONFIG!  (Note the 'len=3' means userspace never
actually wrote us a config, so we're just sending the null byte after
the header.. so this really should fail, but..)

    Mar  2 02:21:03 beaglebone kernel: [  186.561834] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone mfm.sh[1770]: ITCSPIKE-92103199826940: MSG: Tile Level 0: Quitting
    Mar  2 02:21:03 beaglebone kernel: [  186.695534] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.703682] sendKITCPacket pkt=CHECK len=3 (to=WT)

WT has gotten to CHECK!  It's sending the empty config too!

    Mar  2 02:21:03 beaglebone kernel: [  186.708670] recvKITCPacket pkt=CHECK len=3 (us=[ET]WCONFIG)
    Mar  2 02:21:03 beaglebone kernel: [  186.730005] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.863525] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.869654] sendKITCPacket pkt=COMPATIBLE len=2 (to=ET)

ET has gotten to COMPATIBLE!  Neither of us has a config?  Let's rock!

    Mar  2 02:21:03 beaglebone kernel: [  186.875116] recvKITCPacket pkt=COMPATIBLE len=2 (us=[WT]COMPATIBLE)
    Mar  2 02:21:03 beaglebone kernel: [  186.890726] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:04 beaglebone kernel: [  187.209416] ITCCHANGE:DOWN:ET

And I apparently yanked the cable before longwait had passed for west..

    Mar  2 02:21:04 beaglebone kernel: [  187.212613] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:04 beaglebone mfm.sh[1770]: ITCSPIKE-92103199826941: MSG: Tile Level 1: Starting MFZ2
    Mar  2 02:21:04 beaglebone mfm.sh[1770]: ITCSPIKE-92103199826942: MSG: Tile Level 2: Accepting events
    Mar  2 02:21:04 beaglebone kernel: [  187.610711] ITCCHANGE:DOWN:WT
    Mar  2 02:21:04 beaglebone kernel: [  187.613950] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:05 beaglebone kernel: [  188.327645] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:05 beaglebone kernel: [  188.333930] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:05 beaglebone kernel: [  188.839689] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:05 beaglebone kernel: [  188.845978] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:07 beaglebone kernel: [  190.247923] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:07 beaglebone kernel: [  190.254410] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:07 beaglebone kernel: [  190.271865] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:07 beaglebone kernel: [  190.287912] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:07 beaglebone kernel: [  190.299931] ===kitcTimeoutThreadRunner===
    root@beaglebone:~# Mar  2 02:21:09 beaglebone kernel: [  192.901094] set debug 0
    Mar  2 02:21:22 beaglebone mfm.sh[1770]: ITCSPIKE-92103199826943: MSG: Tile Level 0: Quitting

[217:

Mon Mar  2 02:47:34 2020 So this is all very promising.  Lots to fix
up; first up we mostly need better state machine transition logging.

But only a couple more scant hours on this before we have to switch to
science for the next two weeks!

:217]
:216]
[218:

Mon Mar  2 02:59:12 2020 RISKY BITS OFF

:218]
[219:

Mon Mar  2 03:04:50 2020 OK now this:

    Mar  2 03:04:09 beaglebone mfm.sh[1751]: ITCSPIKE-92103197045749: MSG: Tile Level 2: Accepting events
    Mar  2 03:04:13 beaglebone kernel: [  124.060426] ITCCHANGE:UP:WT
    Mar  2 03:04:13 beaglebone kernel: [  124.063410] ITCCHANGE:UP:ET
    Mar  2 03:04:13 beaglebone kernel: [  124.068769] ITC ET i11 -> i01
    Mar  2 03:04:15 beaglebone kernel: [  125.209753] kitcTimeoutThreadRunner: [ET] to WAITPS

ET gets timeout while in WAITPS.

    Mar  2 03:04:15 beaglebone kernel: [  125.217975] setStateKITC: [ET] WAITPS->LEAD

ET advances to LEAD (without pushing the timeout.)

    Mar  2 03:04:15 beaglebone kernel: [  125.237827] kitcTimeoutThreadRunner: [ET] to LEAD

So 'to LEAD' hits after 'only' (- 125.237827 125.217975) ~20ms..

    Mar  2 03:04:15 beaglebone kernel: [  125.253980] sendKITCPacket pkt=LEAD len=2 (src=ET)

ET ships LEAD.

    Mar  2 03:04:15 beaglebone kernel: [  125.258990] recvKITCPacket rc LEAD len=2 (us=[WT]WAITPS)

WT gets it 5ms later.

    Mar  2 03:04:15 beaglebone kernel: [  125.264371] setStateKITC: [WT] WAITPS->FOLLOW

And decides to follow.

    Mar  2 03:04:15 beaglebone kernel: [  125.281238] setStateKITC: [ET] LEAD->WLEAD

This is coming from the same 'to LEAD' that did the send!  The
previous two [WT] events happened at 'interrupt level' via the packet
callback?

Maybe we should updates states and timeouts first, and send packets
last?  Could we do that?  Just for sanity?[220: Mon Mar  2 03:17:40
2020 No, we can't cleanly, because we pack our current state in during
the send.  Could we have a shipCurrentStateAndSwitchToNewState?  [221:

Mon Mar  2 03:21:10 2020 No actually we can do it as is -- our state
ON ENTRY TO THE TIMEOUT is what's in the PacketHandler.  It IS okay to
change our state and timeout and then ship the packet.[222:

Mon Mar  2 03:24:27 2020 Although it will be kind of confusing, since
we'll now see the state change to some new state, while broadcasting
its previous state.  So be it, though, for a test anyway.

:222]

:221]:220]

    Mar  2 03:04:15 beaglebone kernel: [  125.417800] kitcTimeoutThreadRunner: [WT] to FOLLOW
    Mar  2 03:04:15 beaglebone kernel: [  125.426123] sendKITCPacket pkt=FOLLOW len=2 (src=WT)
    Mar  2 03:04:15 beaglebone kernel: [  125.431301] recvKITCPacket rc FOLLOW len=2 (us=[ET]WLEAD)
    Mar  2 03:04:15 beaglebone kernel: [  125.436772] setStateKITC: [ET] WLEAD->CONFIG
    Mar  2 03:04:15 beaglebone kernel: [  125.453958] setStateKITC: [WT] FOLLOW->WFOLLOW
    Mar  2 03:04:15 beaglebone kernel: [  125.589892] kitcTimeoutThreadRunner: [ET] to CONFIG
    Mar  2 03:04:15 beaglebone kernel: [  125.597969] sendKITCPacket pkt=CONFIG len=3 (src=ET)
    Mar  2 03:04:15 beaglebone kernel: [  125.603130] recvKITCPacket rc CONFIG len=3 (us=[WT]WFOLLOW)
    Mar  2 03:04:15 beaglebone kernel: [  125.608773] setStateKITC: [WT] WFOLLOW->CHECK
    Mar  2 03:04:15 beaglebone kernel: [  125.625987] setStateKITC: [ET] CONFIG->WCONFIG
    Mar  2 03:04:15 beaglebone kernel: [  125.761876] kitcTimeoutThreadRunner: [WT] to CHECK
    Mar  2 03:04:15 beaglebone kernel: [  125.769932] sendKITCPacket pkt=CHECK len=3 (src=WT)
    Mar  2 03:04:15 beaglebone kernel: [  125.774996] recvKITCPacket rc CHECK len=3 (us=[ET]WCONFIG)
    Mar  2 03:04:15 beaglebone kernel: [  125.780552] setStateKITC: [ET] WCONFIG->COMPATIBLE
    Mar  2 03:04:15 beaglebone kernel: [  125.793901] setStateKITC: [WT] CHECK->COMPATIBLE
    Mar  2 03:04:15 beaglebone kernel: [  125.933963] kitcTimeoutThreadRunner: [ET] to COMPATIBLE
    Mar  2 03:04:15 beaglebone kernel: [  125.941985] sendKITCPacket pkt=COMPATIBLE len=2 (src=ET)
    Mar  2 03:04:15 beaglebone kernel: [  125.947484] recvKITCPacket rc COMPATIBLE len=2 (us=[WT]COMPATIBLE)


:219]
[223:

Mon Mar  2 03:43:59 2020 RISKY BITS OFF

:223]
[224:

Mon Mar  2 03:49:02 2020 Now it looks like this:

    echo f00 > /sys/class/itc_pkt/debug ; sleep 10; echo 0 > /sys/class/itc_pkt/debug
    Mar  2 03:48:26 beaglebone kernel: [  170.300188] set debug f00
    Mar  2 03:48:29 beaglebone kernel: [  173.076623] ITCCHANGE:UP:WT
    Mar  2 03:48:29 beaglebone kernel: [  173.079592] ITCCHANGE:UP:ET
    Mar  2 03:48:29 beaglebone kernel: [  173.127075] ITC ET i11 -> i01
    Mar  2 03:48:29 beaglebone kernel: [  173.283083] kitcTimeoutThreadRunner: [ET] to WAITPS
    Mar  2 03:48:29 beaglebone kernel: [  173.291328] setStateKITC: [ET] WAITPS->LEAD

ET times out and heads for LEAD.

    Mar  2 03:48:29 beaglebone kernel: [  173.307756] kitcTimeoutThreadRunner: [ET] to LEAD
    Mar  2 03:48:29 beaglebone kernel: [  173.327076] setStateKITC: [ET] LEAD->WLEAD
    Mar  2 03:48:29 beaglebone kernel: [  173.341528] sendKITCPacket pkt=LEAD len=2 (src=ET)

ET heads for WLEAD while sending LEAD.

    Mar  2 03:48:29 beaglebone kernel: [  173.346599] recvKITCPacket rc LEAD len=2 (us=[WT]WAITPS)
    Mar  2 03:48:29 beaglebone kernel: [  173.351996] setStateKITC: [WT] WAITPS->FOLLOW

WT receives ET's LEAD, heads for follow.

    Mar  2 03:48:29 beaglebone mfm.sh[1788]: ITCSPIKE-92103196894224: MSG: Tile Level 0: Quitting
    Mar  2 03:48:29 beaglebone mfm.sh[1788]: ITCSPIKE-92103196894225: MSG: Tile Level 1: Starting MFZ1

    Mar  2 03:48:29 beaglebone kernel: [  173.507069] kitcTimeoutThreadRunner: [WT] to FOLLOW
    Mar  2 03:48:29 beaglebone kernel: [  173.519151] setStateKITC: [WT] FOLLOW->WFOLLOW
    Mar  2 03:48:29 beaglebone kernel: [  173.535187] sendKITCPacket pkt=FOLLOW len=2 (src=WT)

WT times out and heads for WFOLLOW, while sending FOLLOW

    Mar  2 03:48:29 beaglebone kernel: [  173.540366] recvKITCPacket rc FOLLOW len=2 (us=[ET]WLEAD)
    Mar  2 03:48:29 beaglebone kernel: [  173.545854] setStateKITC: [ET] WLEAD->CONFIG

ET sees the follow and heads for CONFIG.

    Mar  2 03:48:29 beaglebone mfm.sh[1788]: ITCSPIKE-92103196894226: MSG: Tile Level 2: Accepting events
    Mar  2 03:48:29 beaglebone kernel: [  173.699093] kitcTimeoutThreadRunner: [ET] to CONFIG
    Mar  2 03:48:29 beaglebone kernel: [  173.707174] setStateKITC: [ET] CONFIG->WCONFIG
    Mar  2 03:48:29 beaglebone kernel: [  173.719198] sendKITCPacket pkt=CONFIG len=3 (src=ET)

ET times out and heads for WCONFIG, while sending its (still
non-existent) CONFIG.

    Mar  2 03:48:29 beaglebone kernel: [  173.724385] recvKITCPacket rc CONFIG len=3 (us=[WT]WFOLLOW)
    Mar  2 03:48:29 beaglebone kernel: [  173.730041] setStateKITC: [WT] WFOLLOW->CHECK

WT sees the CONFIG and heads for CHECK.

    Mar  2 03:48:29 beaglebone kernel: [  173.883075] kitcTimeoutThreadRunner: [WT] to CHECK
    Mar  2 03:48:29 beaglebone kernel: [  173.891053] setStateKITC: [WT] CHECK->COMPATIBLE
    Mar  2 03:48:29 beaglebone kernel: [  173.913417] sendKITCPacket pkt=CHECK len=3 (src=WT)

WT times out and heads for COMPATIBLE, while sending its non-existent
config in a CHECK packet.

    Mar  2 03:48:29 beaglebone kernel: [  173.918517] recvKITCPacket rc CHECK len=3 (us=[ET]WCONFIG)
    Mar  2 03:48:29 beaglebone kernel: [  173.924078] setStateKITC: [ET] WCONFIG->COMPATIBLE

ET sees the CHECK and heads for COMPATIBLE.

    Mar  2 03:48:30 beaglebone kernel: [  174.079151] kitcTimeoutThreadRunner: [ET] to COMPATIBLE
    Mar  2 03:48:30 beaglebone kernel: [  174.087220] sendKITCPacket pkt=COMPATIBLE len=2 (src=ET)

ET times out and sends COMPATIBLE, remaining in that state.

    Mar  2 03:48:30 beaglebone kernel: [  174.092712] recvKITCPacket rc COMPATIBLE len=2 (us=[WT]COMPATIBLE)

WT sees the COMPATIBLE, and remains in that state too.

 ..
    Mar  2 03:48:32 beaglebone mfm.sh[1788]: ITCSPIKE-92103196894241: MSG: Tile EVENT INPUT?
    Mar  2 03:48:33 beaglebone kernel: [  177.271330] ITCCHANGE:DOWN:ET

I pull the loopback and ET goes down..

    Mar  2 03:48:33 beaglebone kernel: [  177.274375] setStateKITC: [ET] COMPATIBLE->WAITPS

..and ET goes back to WAITPS

    Mar  2 03:48:33 beaglebone kernel: [  177.595304] kitcTimeoutThreadRunner: [ET] to WAITPS

ET times out in WAITPS, but just remains there.

    Mar  2 03:48:33 beaglebone kernel: [  177.636014] ITCCHANGE:DOWN:WT
    Mar  2 03:48:33 beaglebone kernel: [  177.639036] setStateKITC: [WT] COMPATIBLE->WAITPS

WT goes down and heads for WAITPS

    Mar  2 03:48:33 beaglebone kernel: [  177.687386] kitcTimeoutThreadRunner: [WT] to WAITPS

WT times out, remains in WAITPS.

    Mar  2 03:48:36 beaglebone kernel: [  180.219495] kitcTimeoutThreadRunner: [NW] to WAITPS
    Mar  2 03:48:36 beaglebone kernel: [  180.227764] kitcTimeoutThreadRunner: [SW] to WAITPS
    Mar  2 03:48:36 beaglebone kernel: [  180.249677] kitcTimeoutThreadRunner: [NE] to WAITPS
    Mar  2 03:48:36 beaglebone kernel: [  180.265854] kitcTimeoutThreadRunner: [SE] to WAITPS

Then, we see the other dirs timing out too -- making their first and
only appearances since we turned on debug output.

    root@beaglebone:~# Mar  2 03:48:36 beaglebone kernel: [  180.331808] set debug 0

Which we then turned off, 10 seconds after we started..

:224]
[225:

Mon Mar  2 04:03:22 2020 Well, so that's all pretty damn satisfying.
I think we can leave it there for a while without undue shame.

Cleaning up for commit.  Actually, committing dirty and then cleaning
up.

:225]
[227:

Mon Mar  2 04:54:11 2020 Randomizing WC_LONG.. Seeing repeated
patterns in the 'to WAITPS' that I don't like just on principle.

:227]
[228:

Mon Mar  2 04:56:40 2020 OK, I have to let this go.  For when we get
back, let's now do some

TODO

 - t2trace is rotted

[240: Sat Mar 21 10:48:59 2020
DONE, simplified :240] - There's a design question about the whole sidestate mUs/mThem
   thing.  We're using hardly any of it.  Do we really want to keep
   it?  If so can we simplify it.

[241: Sat Mar 21 10:49:12 2020
DONE, ditched :241] - There's a lot of 'level' nomenclature that mostly doesn't make
   sense now that we've simplified the protocol.

 - The MFMToken is not being used at all.  Should we exchange it in
   CONFIG/CHECK or some other packet?

 - Should we have a randomized-on-reset one byte nonce for all
   packets, to help ensure we're on the same page regardless of huge
   packet losses or whatever?

Committing and switching to science.

:228]
[229:

Sat Mar 21 04:18:10 2020 OK, well, now it's 19 days later.  It's
COVID-19 days later, and we're in a different world.  The ALIFE2020
conference has become an online-only 'virtual' conference, and the
paper deadline has been pushed back to May 1, so we're back on
intertile events here for the next few days anyway.

Right now I'd like to see a clean up in itc_pkt and then a userspace
spike that demonstrates event locking.  And in particular I'd like to
see userspace design heading towards having multiple events in
progress with fine-grained locks.

Rule is once itc_pkt opens the gate, we can no longer touch any
visible sites without having an event window lock covering that site.
We can try to grab non-overlapping event window locks--even intertile
ones perhaps involving other tiles with which we already have active
locks.
[230:

Sat Mar 21 09:59:51 2020 OK, mini-

TODO

[231: Sat Mar 21 10:08:05 2020
DONE :231] - Merge ITCSideState into ITCLevelState, ditching unused fields

[232: Sat Mar 21 10:11:13 2020
DONE :232] - Get that building

[233: Sat Mar 21 10:18:43 2020
DONE :233] - Rename ITCLevelState to (just) ITCState?

[237: Sat Mar 21 10:44:00 2020
DONE :237] - Get that working

[238: Sat Mar 21 10:46:55 2020
DONE :238] - Commit

[242: Sat Mar 21 11:00:02 2020
DONE :242] - Make more to-do

:230]
:229]
[234:

Sat Mar 21 10:23:15 2020 OK so I guess we need to test this, so it's
time once again to set up for our checklist-mandated procedure:

RISKY BITS OFF
[235:

Sat Mar 21 10:26:39 2020 Installing..

:235]
:234]
[236:

Sat Mar 21 10:43:18 2020 Seems okay after rebooting.

:236]
[239:

Sat Mar 21 10:47:05 2020 OK, so after that palate cleanser, more

TODO

[251: Sat Mar 21 14:20:07 2020
DONE :251] - Unrot t2trace

[252: Sat Mar 21 14:20:11 2020
DONE :252] - Observe successful ITC negotiation with it

 - Observe failed ITC negotiation with it

[291: Mon Mar 23 16:38:02 2020
DONE :291] - Refresh brain on state of userspace spike

[292:
DONE :292] - Commit

[293:
DONE :293] - Make more todo

:239]
[243:

Sat Mar 21 11:04:05 2020 OK digging into t2trace.  Looks like the
events for KITC are pretty limited and incomplete, so a first task
here might be to list what sort of stuff we want, exactly.

But first, blunch.
[244:

Sat Mar 21 11:40:27 2020 OK, so we want timeout-in-state and
type-of-packet-received events at the least.  Let's just get that
going and see what else if anything we might want.[245:

Sat Mar 21 11:52:18 2020 OK, at the moment so we have

    static inline __u32 makeItcLSEvent(__u32 dir6, __u32 usNotThem, __u32 ls) {
      return ((dir6&0x7)<<6) | ((usNotThem&0x1)<<5) | ((ls&0x1f)<<0);
    }

    static inline __u32 makeItcDirEvent(__u32 dir6, __u32 op) {
      return ((6&0x7)<<6) | ((op&0x7)<<3) | ((dir6&0x7)<<0);
    }

    static inline __u32 makeItcSpecEvent(__u32 spec) {
      return ((7&0x7)<<6) | ((spec&0x3f)<<0);
    }

but since level-stage has gone away we get to repurpose those states.
So I guess it's really a full 6 bits (==64) of KITC-specific events,
plus 2 * 6 bits (==128) of non-spatial 'special' events.

Seems like super-overkill sitting here now.  We'll see.
[246:

Sat Mar 21 12:13:53 2020 Given that we've got 11 states, let's go with
4 bits for state and have 2 bits for op-within-state -- although
beyond just 'ENTER' I'm not sure what we'll have for 'op'.

:246]
:245]

:244]
:243]
[247:

Sat Mar 21 13:10:29 2020 Well, now perhaps generating some new-style
KITC state events for ENTER, TIMEOUT, and RECEIVE...  Let's push on
t2trace.cpp some.[248:

Sat Mar 21 13:29:38 2020 OK, going for a try.

RISKY BITS OFF

:248]

:247]
[249:

Sat Mar 21 14:00:54 2020 Tweaking events.  Getting there.

RISKY BITS OFF

:249]
[250:

So okay, getting plausible traces:

    0009 5.691466sec   +3msec 18b:K (WT) ITCUP: packet sync acquired
    0010 5.694419sec   +2msec 188:K (ET) ITCUP: packet sync acquired

Plugged in the loopback..

    0011 5.717148sec  +22msec 037:L     [WT sSYNC01]
    0012 5.717148sec   +0usec 0b8:L         WT_ORQLK-
    0013 5.717152sec   +4usec 18e:L LALST: all locks settled
    0014 5.717176sec  +24usec 080:L -ET_IRQLK
    0015 5.717176sec   +0usec 007:L     [ET sSYNC01]
    0016 5.717176sec   +0usec 088:L         ET_ORQLK-
    0017 5.717176sec   +0usec 18e:L LALST: all locks settled
    0018 5.717185sec   +8usec 0b0:L -WT_IRQLK
    0019 5.717189sec   +4usec 033:L     [WT sIDLE]
    0020 5.717189sec   +0usec 0bc:L         WT_OGRLK-
    0021 5.717189sec   +0usec 18e:L LALST: all locks settled
    0022 5.717197sec   +8usec 084:L -ET_IGRLK
    0023 5.717197sec   +0usec 003:L     [ET sIDLE]
    0024 5.717197sec   +0usec 08c:L         ET_OGRLK-
    0025 5.717197sec   +0usec 18e:L LALST: all locks settled
    0026 5.717209sec  +12usec 0b4:L -WT_IGRLK

Lock negotiation happened next..

    0027 6.977343sec   +1secs 0d1:K [WT:WAITPS] TIMEOUT

A whole second later West KITC finally timed out..

    0028 6.977348sec   +4usec 0c2:K [WT:LEAD] ENTER
    0029 6.977348sec   +0usec 0d2:K [WT:LEAD] TIMEOUT

..entered LEAD and timed out again immediately..

    0030 6.977352sec   +4usec 0c3:K [WT:WLEAD] ENTER

..and entered WLEAD (waiting after lead)..

    0031 6.977368sec  +16usec 0f2:K [WT:LEAD] SEND

..after (?) announcing its LEAD state.

    0032 6.977421sec  +53usec 0d6:P   <WT to PRU 2-4>

..that packet ships..

    0033 6.977581sec +159usec 021:K [ET:WAITPS] RECEIVE

..East KITC gets notified..

    0034 6.977585sec   +4usec 004:K [ET:FOLLOW] ENTER
    0035 7.129379sec +151msec 014:K [ET:FOLLOW] TIMEOUT

..enters FOLLOW and times out again..

    0036 7.129383sec   +4usec 005:K [ET:WFOLLOW] ENTER
    0037 7.129399sec  +16usec 034:K [ET:FOLLOW] SEND

..and enters waiting after follow while announcing follow.

    0038 7.129457sec  +57usec 0d2:P   <ET to PRU 2-4>

..the packet ships..

    0039 7.129616sec +159usec 0e3:K [WT:WLEAD] RECEIVE

Same deal.  West, waiting after lead, receives it

    0040 7.129620sec   +4usec 0c6:K [WT:CONFIG] ENTER
    0041 7.281406sec +151msec 0d6:K [WT:CONFIG] TIMEOUT
    0042 7.281410sec   +4usec 0c7:K [WT:WCONFIG] ENTER
    0043 7.281426sec  +16usec 0f6:K [WT:CONFIG] SEND
    0044 7.281480sec  +53usec 0d6:P   <WT to PRU 2-4>

..and enters waiting after config while announcing config.

    0045 7.281619sec +139usec 025:K [ET:WFOLLOW] RECEIVE
    0046 7.281623sec   +4usec 008:K [ET:CHECK] ENTER
    0047 7.433462sec +151msec 018:K [ET:CHECK] TIMEOUT
    0048 7.433466sec   +4usec 009:K [ET:COMPATIBLE] ENTER
    0049 7.433474sec   +8usec 038:K [ET:CHECK] SEND
    0050 7.433507sec  +32usec 0d2:P   <ET to PRU 2-4>

..receiving the config, East determines we have compatibility, while
announcing CHECK.

    0051 7.433613sec +106usec 0e7:K [WT:WCONFIG] RECEIVE
    0052 7.433617sec   +4usec 0c9:K [WT:COMPATIBLE] ENTER
    0053 7.585563sec +151msec 0d9:K [WT:COMPATIBLE] TIMEOUT
    0054 7.585579sec  +16usec 0f9:K [WT:COMPATIBLE] SEND
    0055 7.585649sec  +69usec 0d6:P   <WT to PRU 2-4>

..West receives check, determines we have compatibility, and announces
compatibility..

    0056 7.585780sec +131usec 029:K [ET:COMPATIBLE] RECEIVE

..East notices West noticed we have compatibility.

    0057 8.194359sec +608msec 111:K [NW:WAITPS] TIMEOUT
    0058 8.599642sec +405msec 086:L +ET_IGRLK
    0059 8.599654sec  +12usec 082:L +ET_IRQLK
    0060 8.599654sec   +0usec 00b:L     [ET sFAILED]
    0061 8.599658sec   +4usec 08a:L         ET_ORQLK+
    0062 8.599658sec   +0usec 08e:L         ET_OGRLK+
    0063 8.599658sec   +0usec 18e:L LALST: all locks settled
    0064 8.629645sec  +29msec 000:L     [ET sRESET]
    0065 8.629649sec   +4usec 18e:L LALST: all locks settled
    0066 8.664035sec  +34msec 180:K (ET) ITCDN: packet sync lost

Oh no, packet sync has failed (I pulled the loopback cable.)

    0067 8.664035sec   +0usec 001:K [ET:WAITPS] ENTER

..and East resets

    0068 9.245925sec +581msec 183:K (WT) ITCDN: packet sync lost
    0069 9.245929sec   +4usec 0c1:K [WT:WAITPS] ENTER

..so does West

    0070 9.465790sec +219msec 011:K [ET:WAITPS] TIMEOUT
    0071 10.369974sec +904msec 0d1:K [WT:WAITPS] TIMEOUT

..and so the story ends, we're told.

:250]
[253:

Sat Mar 21 14:20:54 2020 OK, to observe a satisfyingly failed
negotiation, we really ought to jump ahead to a/the userspace spike,
so that there'd be a natural way for things to fail.

So committing this now, then switching to userspace.

:253]
[254:

Sat Mar 21 14:37:08 2020 OK, so at the moment, mfm.sh is launching
MFM/bin/itcSpike11.  So that's where we should look first..

:254]
[255:

Sat Mar 21 15:07:50 2020 So I think the plan should be to start
itcSpike12 rather than hack on itcSpike11, which has a whole UI
section and stuff already.  I want to focus just on intertile stuff
and design for having multiple event windows in flight.

So,

TODO

[287: Mon Mar 23 16:36:28 2020
DONE :287] - Create empty itcSpike12

[288:
DONE :288] - Take command line arg for MFZId

[289: Mon Mar 23 16:37:21 2020
DONE made 'SYN'thetic packets:289] - Define some kind of gate-open/gate-closed messages to send to
   userspace

[290: Mon Mar 23 16:37:43 2020
NOT GOING TO IMPLEMENT SELECT, POLL INSTEAD :290] - Have userspace do a select on /dev/itc/mfm/*?

Tell me again why we wanted to demux the dirs in LKM?  We were going
to poll the dirs and they wanted to ask for just their own packets?

[256:

Sat Mar 21 15:43:29 2020 I guess so.  In the new revised view, though,
it seems like the important state machine should be in the
EventWindow, not in the ITC, which could be dishing off packets to a
variety of EWs interleaved.

[257:

Sat Mar 21 16:36:49 2020 Maybe let's explicitly work on an EW state
machine, aiming at demoing it in spike12?

:257]

:256]

:255]
[258:

Sun Mar 22 07:56:50 2020 Oops looks like we never actually exposed
/sys/class/itc_pkt/mfzid? [259:

Sun Mar 22 07:59:42 2020 Going again

RISKY BITS OFF

:259]

:258]
[260:

Sun Mar 22 08:02:56 2020 That's more like it:

    root@beaglebone:~# ls -l /sys/class/itc_pkt/mfzid
    -rw-r--r-- 1 root root 4096 Mar 22 08:01 /sys/class/itc_pkt/mfzid
    root@beaglebone:~#

and

    root@beaglebone:~# echo foo > /sys/class/itc_pkt/mfzid

gets

    [  163.809782] mfzid set; len=4, token=182, written by 2252
and
    root@beaglebone:~# cat /sys/class/itc_pkt/mfzid
    2252 182 foo

    root@beaglebone:~#

(with an extra \n in there; should've done 'echo -n')

and

    root@beaglebone:~# ps
      PID TTY          TIME CMD
     2249 pts/1    00:00:00 sudo
     2252 pts/1    00:00:00 bash
     2434 pts/1    00:00:00 ps
    root@beaglebone:~#

    root@beaglebone:~# echo -n bar > /sys/class/itc_pkt/mfzid
    root@beaglebone:~# cat /sys/class/itc_pkt/mfzid
    2252 183 bar
    root@beaglebone:~#

[261:

Sun Mar 22 08:08:34 2020 Is there any way to discard an mfzid without
establishing a new one?[262:

Sun Mar 22 08:11:48 2020 Apparently there isn't, currently, because
apparently (and I do think I knew this) writing 0 bytes to sysfs never
actually invokes the _store handler..  Would have to add an extra
write-only target /sys/class/itc_pkt/mfzid_reset or mfzidctl or
something.

But I do think we should ship this MFMTileState.mToken along with the
mfzid and with the in/compatibility packets.  We accept it
unconditionally whenver compatibility is established, and check it
from then on.  userspace should capture it after setting the mfzid,
..and check it every so often?  I thought we had some scheme were the
ITC fd was going to fail on read, forcing userspace to reopen it, did
we do that?  That's the 'stale' thing, right?[263:

Sun Mar 22 08:32:26 2020 It appears all ITCs are marked stale when
/sys/class/itc_pkt/mfzid is written.  And when they are stale, an
attempt to open /dev/itc/mfm/DIR will fail with ESTALE?  What good
does that do if we already had them open?  Shouldn't we be making
reads and writes fail too?
[264:

Sun Mar 22 08:50:20 2020 OK we think we've reorged so read and write
fail after the itcs go stale, but a successful itc open clears it, but
only the pid that wrote the mfzid is allowed to open it.

So the userspace startup sequence should morally amount to:

  first write MFZID to /sys/class/itc_pkt/mfzid
  then the same process opens /dev/itc/mfm/*

:264]
:263]

:262]

:261]

:260]
[265:

Sun Mar 22 09:05:20 2020 OK need to try this reorg, so

RISKY BITS OFF

:265]
[266:

Sun Mar 22 09:15:15 2020 OK that seems okay.  We're getting to be
needing itcmfm to start passing packets; is that already done?  Then
very soon we're going to be needing some packets to pass..[267:

Sun Mar 22 09:18:28 2020 So the point is KITC-internal packets never
get put onto the UserIB kfifo, so we don't have to worry about
userspace ever seeing them.  That happens at the call to
handleKITCPacket at itcpkt.c:2189.

But we also think we should not pass non-KITC packets unless we are at
COMPATIBLE, and the code isn't doing that..  How do we know we're good
to go, in itcpkt-land?[268:

Sun Mar 22 09:31:40 2020 OK, make isKITCCompatible(mds*) and are now
claiming to not deliver (aka 'silently drop') mfm traffic unless it's
true. [269:

Sun Mar 22 09:34:40 2020 That builds.

RISKY BITS OFF

:269]

:268]

:267]

:266]
[270:

Sun Mar 22 09:37:22 2020 Back up.[271:

Sun Mar 22 09:39:30 2020 OK, so I think we're really about up to
designing event-level packet format.

Though I'd like a synthetic 'gate open' packet that LKM just locally
stuffs in the mUserIB when we enter SN_COMPATIBLE.

[272:

Sun Mar 22 09:41:08 2020 EVENT PACKET LEVEL: DESIGN DISCUSSION

So, according to T2-Packet-Header-Formats-12.pdf, MFM event packets
have a minimum size of two bytes, with byte[0] in the range

  0xa0..0xa7

depending on dir8, and byte[1] being 10xxxxxx, so there's six bits
available in byte[1].  Suppose we take the top bit as 'synthetic',
meaning it's from (or possibly to) the itcmfm LKM, rather than
an actual neighbor.  Suppose we reserve the next two bits on general
principles, and take the bottom three bits for event-level use:

byte[1]

   MFM ITC SYN
  +---+---+---+---+---+---+---+---+
  | 1 | 0 | 1 |RV1|RV2|RV3|RV4|SC0|
  +---+---+---+---+---+---+---+---+

SC 0..1
SC == 0 GATE CLOSED
SC == 1 GATE OPEN

   MFM ITC SYN
  +---+---+---+---+---+---+---+---+
  | 1 | 0 | 0 |EC1|EC0|RV1|RD1|RD0|
  +---+---+---+---+---+---+---+---+

EC 0..3  RD 0..3
EC == 0 Non-EventWindow command (RV1,RD1,RD0 unused)
EC == 1 EventWindow lock req + RD radius-1 + u8:YLSeqno + u8:myewslotno + s8:atx + s8:aty
EC == 2 EventWindow lock ack + RD radius-1 + u8:YLSeqno + u8:yourewslotno
EC == 3 EventWindow lock rej + RD radius-1 + u8:YLSeqno + u8:yourewslotno

   MFM ITC SYN
  +---+---+---+---+---+---+---+---+
  | 1 | 0 | 0 | 0 | 0 |CM2|CM1|CM0|
  +---+---+---+---+---+---+---+---+

CM 0..7
CM == 0 UPDATES + u8:YLSeqno + u8:myewslotno + updates*
CM == 1 UPDACK  + u8:YLSeqno + u8:yourewslotno
CM == 2 UPDEND  + u8:YLSeqno + u8:myewslotno
CM == 3 ENDACK  + u8:YLSeqno + u8:yourewslotno
CM == 4 RSV1
CM == 5 RSV2
CM == 6 RSV3
CM == 7 RSV4

CACHE UPDATE FORMAT

  +---+---+---+---+---+---+---+---+
  |CHG|EMP|SN5|SN4|SN3|SN2|SN1|SN0|
  +---+---+---+---+---+---+---+---+

CHG 0..1
CHG == 0 Site value is being checked (not changing)
CHG == 1 Site value is changing

EMP 0..1
EMP == 0 Site contains atom + 12*u8
EMP == 1 Site is empty

[273:

Sun Mar 22 12:06:24 2020 OK so some or most of that might be
plausible.  Let's talk about the state machine for an EventWindow.

Suppose we have a max of like 31 EventWindows, 1..31.  We could have a
u8 siteLockStatus[SITE_WIDTH][SITE_HEIGHT] indicating that site's
current lock status:

  +---+---+---+---+---+---+---+---+
  |IT2|IT1|IT0|EW4|EW3|EW2|EW1|EW0|
  +---+---+---+---+---+---+---+---+

IT 0..7 Modified Dir8 of lock holder

IT == 0  site is unlocked (and EW == 0)
IT == 1  DIR8_NE
IT == 2  DIR8_ET
IT == 3  DIR8_SE
IT == 4  We hold the lock
IT == 5  DIR8_SW
IT == 6  DIR8_WT
IT == 7  DIR8_NW

EW 1..31 EventWindow slot number in lock holder's space.

Now, there are some subtleties to 'holding the lock' -- in particular,
there's the state where we're requesting locks but have not yet
acquired them.  During that time we have to mark the sites 'locked' so
nobody else tries to use them, even though they're not really
'lock-locked' yet.  But that level of locking detail goes with the
EventWindow slot, not with the individual site, so we deal with all
that there.

I wonder if we could track seqnos or something of the last ew -- by
anybody -- that modified a given site.  So we could do some kind of
max operation or whatever to come up with a claim about 'THIS is the
state of the event window I wish to lock'.

So far we've been imagining that we're going to send the receiver's
last seqno with us as a marker in the timeline of changes specifying
what we're asking to lock against.  But we don't have much confidence
in that.[274:

Sun Mar 22 14:46:08 2020 We could include a nonce in the ew lock req
packet, so that if a race occurs, the recipient could choose to
abandon their own attempt and accept the other, rather than
necessarily rejecting it and forcing both sides to try again.

Like we apparently have working in itcmfm?

No actually we just flip a coin there.  Could that be good enough?
The other side needs to wait to hear from us no matter what.

Maybe.

[275:

Sun Mar 22 14:53:20 2020 So, some EW states:

  IDLE
  LOCKREQ
  WLOCKREQ
 ..
  LOCKED
  BEHAVE
  CACHESEND
  WCACHEACK
  COMMIT

and we note that we are NOT talking about EW to EW interactions.  The
far side entity is an ITC (or two), that handles applying cache
updates and acking packets.

[276:

Sun Mar 22 16:19:08 2020 We'll keep a free list and an active list of
EWs at the Tile level, and doubly-link the EWs so they can switch
lists, or at least retire themselves, on their own.

We are NOT going to multithread userspace -- right?? -- except perhaps
for opportunistic display purposes.

[277:

Sun Mar 22 16:27:33 2020 So the main loop is a select on the ITCs with
a zero timeout, followed by ..  advancing any 'ready' EWs, followed
..[278:

Sun Mar 22 16:38:18 2020 So, yes.  'select' is a completely separate
file_operations function pointer that we would have to implement if we
want to provide it.  And we're not actually sure how we would provide
it, on the write side, since the outbound-to-PRU buffers are shared in
fairly non-trivial ways.

So I guess we just poll all the entities over and over, beating the
cache to death in the process?  Who exactly do we poll?  We need to
poll the ITCs to read and respond to inbound cache traffic.  If a read
packet is active side, the ITCs apply it directly; if it's passive
side, the ITCs dispatch it to the relevant EW.

Ah, so wait: How does the passive side know where the event window
center is?  That has to be stored when passive side decides to ack an
ew lock request.  So we do need to allocate a passive side EW and the
dynamic really is more like EW to EW.  (I guess a potential passive
side could reject a lock request if it had no free EWs?)

Do we want to use a 'full' EW on the passive side?  From one point of
view all we need is the event center + radius, plus the
siteLockStatus[][] array, right?

Is there any reason to apply EW cache upds TO AN EW, instead of to
actual tile memory?  That would let us commit or dump an update
late..  We could opportunistically be sending stuff to one guy before
we even knew if we got the lock from the other guy?  That seems likely
to be pretty wasteful of bandwidth if not CPU also..[279:

Sun Mar 22 16:59:57 2020 Seems like it would be good if the passive
side could commit and unlock the sites as soon as the cache upd end is
received and the ack sent, without waiting for the active side to
receive that ack.  That gives an advantage to the passive side to have
a better chance at grabbing a window using those sites, so the (old)
active side might well see a new ew lock request hard on the heels of
the old upd end ack.

:279]

:278]

:277]

:276]


:275]

:274]


:273]
:272]

:271]

:270]
[280:

Sun Mar 22 17:06:20 2020 Well, so say an EW might be IDLE, ACTIVE, or
PASSIVE.  When we get a lock req, we try to allocate an EW to
represent it on the passive side.  If the allocation succeeds, we load
it up out to the requested radius, and mark the involved sites as
controlled by the allocated EW.  Everything else then proceeds EW<->EW
until we commit on our respective sides.

And so I guess this means we don't need to remember the ITC/dir8 of
the lock holder, because the ITC won't be involved.  We just stick in
one of our own EW slotnums, whether it's active or passive.  Something
more like:

  typedef u8 EWSlotNum;
  EWSlotNum lockedSites[SITE_WIDTH][SITE_HEIGHT]; // 0 means unlocked

[281:

Sun Mar 22 17:51:58 2020 Time to cook dinner.[282:

Sun Mar 22 18:17:09 2020 OK so sauce in the oven and we have a little
more time to think.

Let's just whack up some EW allocation and manipulation stuff, without
even knowing or worrying what-all's in them.

:282]

:281]

:280]
[283:

Mon Mar 23 10:38:55 2020 OK, getting to be time to move the flag again
-- who knows how long that will be possible? -- but we've made some
progress.  We have multiple (currently 32) EWs getting made and put on
lists where they can be allocated and freed and so forth.  And the
lists are given ownership of the EWs they contain and clean them up,
so valgrind tells us:

    ==6042== HEAP SUMMARY:
    ==6042==     in use at exit: 0 bytes in 0 blocks
    ==6042==   total heap usage: 35 allocs, 35 frees, 22,536 bytes allocated
    ==6042==
    ==6042== All heap blocks were freed -- no leaks are possible

I don't like that I'm using heap memory at all, but statically
constructing arrays of non-POD objects in C++ is still pretty much a
pain if you want to compute ctor parms on the fly..

[284:

Mon Mar 23 11:02:27 2020 So anyway, I think we should checkpoint
commit all this stuff and get going.

:284]
:283]
[285:

Mon Mar 23 14:27:22 2020 OK, back in the city.  Gotsta say,
Albuquerque, you didn't look very shut down..
[286:

Mon Mar 23 16:35:16 2020 Do you think we could try to grab a(n
all-packet) lock?  Probably need too much code, right?  Yeah no we're
not even reading packets yet.

:286]
:285]
[294:

Mon Mar 23 16:43:43 2020 Well in any case we need more

TODO

[299: Wed Mar 25 15:26:40 2020
DONE :299] - Add the siteLockStatus[][] array to Tile

[300: Wed Mar 25 16:48:58 2020
DONE :300] - Add functions to test if loc+radius is allocatable and return an
   initialized EW* if so

[302: Wed Mar 25 16:49:22 2020
DONE, not used yet though :302] - Make an EW state machine state enum

[303: Wed Mar 25 16:49:32 2020
DONE :303] - Add state machine state to EW

[301: Wed Mar 25 16:49:10 2020
DONE, first cut anyway :301] - Create a Tile::tryEvent() interface that considers a random spot,
   determines if its radius seems available, and tries to launch an EW
   if so

:294]
[295:

Wed Mar 25 08:11:26 2020 OK T2sup #272 is out and I got a little
sleep.  Have to sleep more and do some emails and what-not today, but
I really want to push through to fake events with real intertile
behavior!

:295]
[296:

Wed Mar 25 12:19:28 2020 Well, I'm changing the names of key
structures (starting with 'Tile') to be like 'T2Tile', so that
potentially at least they could interact with e.g., Tile<EC> code down
the road.  Seems very unlikely to work in the end but seeing these
naked 'Tile' references creeps me out.[297:

Wed Mar 25 12:49:33 2020 OK well did that.

:297]

:296]
[298:

Wed Mar 25 13:23:06 2020 So, the siteLockStatus array is really an
ownedByEventWindow array, now, isn't it?

:298]
[304:

Wed Mar 25 16:49:43 2020 OK, so current status is we have first cuts
at 'acquiring' and 'releasing' an EventWindow.  main.cpp is currently
screwing up because it calls 'tile.releaseEW(ew)' while ew is still on
the 'active' list.  We need to get more squeaky about the event window
life cycle.

:304]
[305:

Thu Mar 26 05:12:30 2020 So I'm worrying ahead about the EW state
machine, in particular how it's going to resolve potentially three-way
races.

Let's suppose for sake of discussion that we're going to do the kind
of slot-time-windows we did in itcmfm to tame the synchronization
beast.  Suppose we had a somewhat slower fundamental period at user
level, which we're plannning on masking by having lots of EWs in
progress at once.

So a tile allocates an EW, and happens to get #8.  It initializes EW#8
for location (20,2) with a radius of 3.  EW#8 realizes it needs locks,
enters state EWLEAD(20,2,3,#8), and sends that state via both his NW
and NE ITCs.  EW#8 then goes into state WEWLEAD -- waiting after an
EWLEAD -- and gives itself a FULL timeout.

NW receives the EWLEAD(#8) and tries to allocate a passive EW for it,
which happens to work fine, getting its EW#3.  So EW#3 enters state
EWFOLLOW (SE,#8) and gives itself a HALF timeout, without sending
anything.

At about the same time, NE also receives the EWLEAD #8.  But unlike
NW, it fails trying to allocate a passive EW for it, because it just
recently allocated its an active EW#22 which overlaps with the given
window.  In fact just a moment ago it had sent an EWLEAD(1,0,4,#22) to
its SW, but it hasn't yet heard back.  And its EW#22, in state
WEWLEAD, turns up when trying to allocate the passive for SW#8.

Now if we follow the itcmfm style, at this point NE would flip a coin
to decide between accepting SW#8 vs pushing on with its own #22.
Let's say it decides to go with its own #22.  In itcmfm terms, it
needs to reset SW#8.  And

[306:

Thu Mar 26 05:54:01 2020 It seems like we need a construct prior to
the EW, something to manage a given attempted EW interaction even
before (and perhaps after?) the actual EW exists.  Like a 'virtual
circuit' or something, that could be reset when an EW can't be
allocated.  Or retired for a fallow period after an interaction has
completed for any reason, to let its 'circuit number' wash out of the
system.

:306]

:305]
[307:

Thu Mar 26 06:12:58 2020 OK so an intertile event is like a phone
call, now?  Or a conference call really, I guess.  There's setting up
the circuit, ringing the line, making the call, ending the call, and
tearing down the circuit.

If we view sites as phones, it's really like a conference call of
conference calls or something -- a bunch of sites here interacting
with a bunch of sites on up to two other tiles..  Site-as-phone isn't
a bad model if we're imagining it back in the day before multiple
lines and 'please hold'..  So a given passive site on some tile can be
listening to only one active site on some other tile.  But multiple
passive sites can be listening to the same active site.

So it's like we're sending back a 'busy signal' when we can't allocate
the EW.  And we want to do that pretty much until the caller hangs up,
which I guess either means some kind of ack, or some kind of timeout?

[308:

Thu Mar 26 07:10:56 2020 So, when the ITC receives an EWREQ, that's a
request to set up a circuit.  It should allocate some 'circuit state'
that will persist for the duration of the call.  That allocation
should mostly not fail, although I guess an 'all circuits busy'
response has to be designed in.

Then somebody, the ITC I guess, tries to allocate a passive EW to
match up with this EWREQ.  If that succeeds the ITC 'completes the
circuit' and gets out of the way, and the EWs talk to each other,
until both sides 'hang up'.  I guess we could do the 'half-closed'
channel like unix does; when we get a cache-upd-end from the active
side, that could imply closing the inbound side of the circuit; then
when we ship the cache-upd-end-ack, that would imply closing the
outbound side of the circuit, and the circuit would then be torn
down.

So there'd be some variety of ways to end a call, unless we did
explicit call-init/call-end packets to bracket the cache-upd traffic.

[309:

Thu Mar 26 07:58:46 2020 Well, it's not like we have an event-level
packet format yet.  And we have I guess six bits still available in an
event packet byte[1].  Could that perhaps be like two bits of call
status and four bits of circuit number, for a max of sixteen circuits
per ITC pair?  Or maybe one bit for a 'control' flag plus five bits of
circuit number?  With some scheme like control==0 means this is
continuing traffic on established channel NUM, and control==1 means
this is starting or ending a call on channel NUM -- with like some
other way of distinguishing which that is.  Packet length or something
perhaps.

Nooooow, we also have the possibility, I guess, of using the two
reserved bits in the 'ITC' packet format, which currently looks like
this, according to T2-Packet-Header-Formats-12.pdf:

                                         ITC
  +---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+
  | 1 | 0 | 1 |OVR|ERR|SD2|SD1|SD0| | 1 | 1 |RS1|RS0|SN3|SN2|SN1|SN0|
  +---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+

We could, for example go to something like this:

                                         ITC RNG
  +---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+
  | 1 | 0 | 1 |OVR|ERR|SD2|SD1|SD0| | 1 | 1 | 0 |RS0|SN3|SN2|SN1|SN0|
  +---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+

vs
                                         ITC RNG
  +---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+
  | 1 | 0 | 1 |OVR|ERR|SD2|SD1|SD0| | 1 | 1 | 1 |CT4|CT3|CT2|CT1|CT0|
  +---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+

where RNG==0 means do the existing LKM protocol, while RNG==1 means
'ring' on a new circuit CT.  Then with:

                                         ITC HNG
  +---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+
  | 1 | 0 | 1 |OVR|ERR|SD2|SD1|SD0| | 1 | 0 | 1 |CT4|CT3|CT2|CT1|CT0|
  +---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+

vs
                                         ITC HNG
  +---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+
  | 1 | 0 | 1 |OVR|ERR|SD2|SD1|SD0| | 1 | 0 | 0 |CT4|CT3|CT2|CT1|CT0|
  +---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+

where HNG==1 means 'hang up' an established circuit CT, and HNG==0
means continuing traffic on CT.

Now I suppose in addition one could say that byte[2]+ could contain
cache traffic on top of any of these cases, with the 'ringing'
implicitly coming before processing any such, and 'hanging up'
implicitly coming afterwards.[310:

Thu Mar 26 08:36:37 2020 Now, a couple questions about this: Do we
really need to allocate and deallocate circuits locally?  Are we
saying NE circuit #3 might connect to our circuit #22?  And we need to
do that mapping for every packet?

I guess the point is that each side may try to take the initiative, so
each side needs to pick an available circuit without knowing what the
other side is doing?  But except for racing on the ringing, each ITC
really does know what circuits its mate has allocated, because it's
the counterparty to all of them.

So if we detected and handled the races during ringing and circuit
setup, it seems we could then have a 1-1 mapping between circuits
across an ITC pair.
[311:

Thu Mar 26 08:45:20 2020 Could we move the ringing into itcmfm also,
and deal with the racing there?  Does that help, much or at all?

I guess maybe it narrows the race window a bit, but doesn't change
much fundamentally.  KITC could notice RNG and allocate the channel,
if it's available, or somehow reject it as a race if it isn't.  Once
it's done that, it could errno EBUSY any userspace write that attempts
to ring the same channel.  But if two RNGs cross in the fabric, both
sides will see the channel as already in use, and they'll flip their
coins or whatever, same as they're doing now for the config state
machine.

[312:

Thu Mar 26 08:56:46 2020 Getting to be nap time, but again why
couldn't a nonce help there?  We generate and store it when we send
out a RNG, and when we receive a racing RNG we have both nonces
available to compare.  Modulo nonce ties, both sides will make the
same decision about who wins the race, and 'things can proceed' with
fewer double-blowups or re-races.

In fact, we could avoid ties by having the gingers always use nonce
LSB 1 and the freds always use nonce LSB 0.  With the rest of the bits
random there's no way for either side to game the choice without
seeing the other side's nonce, in which case they are surely cheating,
since in fact there really was no race at all.

Actually actually, doesn't a one-bit nonce work equally well, then?
If the nonces match, ginger wins, otherwise fred wins..[313:

Thu Mar 26 12:22:29 2020 Unfortunately we don't have even one bit, if
we're trying to be tight while supporting 32 channels.

But since we're not assuming any direct mapping from ew center to itc
circuit, this one bit nonce can't really go with the circuit; it has
to be EW level, right?  So we could have six bits of circuit#, taking
the whole rest of byte[1], right?[315:

Thu Mar 26 15:21:24 2020 So then in byte[2] we'd start with the EW
info, and the EWREQ could include a 1 bit nonce.

So then how do the circuits work?  We separated circuit number from EW
number so we could have mapped communications before EW was assigned
on the passive side, and after it was released on the passive side as
well.. [316:

Fri Mar 27 01:06:32 2020 Would it help to say instead of 32 circuits
we have 16 active fred and 16 active ginger channels?  And then it
would be a direct mapping?  Each side would have assignment control
over half the numbers, and the non-controlling side would just use the
corresponding slot.[317:

Fri Mar 27 01:15:32 2020 It wouldn't even have to be fred and ginger?
It could be a 'sender' vs 'receiver' bit -- saying in effect 'My#3' vs
'Your#3' with ownership==active side.  Since cache traffic is all
point to point you just complement the 'sender' bit to get the
receiver's index for it.

Both sides could have 0x00..0xf for inbound calls and 0x10..0x1f for
outbound calls, with a ^0x10 to switch between them..  So then bit
0x10 of byte[1] is the 'active' bit, with 1 meaning sender initiated
and 0 meaning receiver initiated.[318:

Fri Mar 27 01:23:13 2020 Umm am I crazy or do we have six bits
currenly available in byte[1]?  That's 64 values.  Yeah but then you
have no 'control' bits, okay.  32 divided 16+16 includes room for one
control bit..  Could 'control' mean 'ring' on sender-owned circuits
and 'hang up' on receiver-owned?[319:

Fri Mar 27 02:15:21 2020 That could be in keeping with the 'receiver
finishes first' theory of race fairness.  Or rather than control + 5
bits of circuit, I guess it's equivalent to control + active + 4 bits
of circuit, with control+active == 11 meaning 'ring' and
control+active == 10 meaning 'hang up'.

Now does that means we lose the 'half-closed channel' option?  There's
no way for the active side to indicate that it's done after
cache-upd-end.. but I thought we're saying it's not done until it sees
cache-upd-end-ack...  But half-closed just means it's not going to
send anymore on this circuit, which is true even as it waits for the
ack.

If we have net two bits to play with:

  00   Passive, ongoing
  01   Passive, final
  10   Active, ongoing
  11   Active, initial

..right so there's no 'Active, final'..

So do we care about half-closed channels?  What does that do for us?
In the bad old CS351 Java days it got us cleaner channel tear-down in
our client-server game communications.
[320:

Fri Mar 27 02:32:44 2020 On a slightly different topic, what if we did
try to use our H/W lock bits, so that you can't send an EWREQ unless
you're holding all the locks you'll need?  And the idea is the lock is
released as soon as the receiver replies yes or no to the EWREQ.  So
all the 'heavy lifting' of actually shipping and receiving the event
happens after the locks are released.

Now, why would a receiver need to say no to an EWREQ, especially if we
say we're circuit-limited rather than EW limited?  Because even with
ITC-pair locks we could still be racing against another ITC-pair lock
whose EW overlaps with ours.  Right?

Right??
[321:

Fri Mar 27 04:10:11 2020 I don't know.  [322:

Fri Mar 27 05:24:41 2020 Working back and forth here between hask and
this..

Restate premises.

 o Many EWs in progress, even between the same ITC pair.

 o Cache traffic must identify the EW session involved

 o Cache traffic both precedes and follows the assignment of the (at
   least passive) EW:

   . The EWREQ initiation packet arrives when no EW is yet assigned.

   . The passive EW can be freed as soon as the upd-end-ack is sent,
     since no further acknowledgment is coming from the active side.

 o So rather than exposing EW numbers on the wire, we expose 'circuit
   numbers', and associate circuits with EWs only locally.  That way,
   circuits can be assigned and used before an EW is allocated, or
   after the EW is freed.

 o But that means the circuit level needs to know when a new circuit
   is being initiated, and when a circuit can be torn down.  Which is
   referring to the acquisition and disposition of the local EW.  And
   also to the circuit-circuit mapping?  But not if that's 1-1.

[323:

Fri Mar 27 13:48:02 2020 So perhaps there's no need to break
circuit-circuit mapping even if the EWs come and go.  If that was the
case maybe we could indeed get away with just a single 'control' bit,
which is really mostly a synchronization check, and means 'there
should be no existing EW on this channel, and now I want you to try to
allocate one here.'  Whereas an existing passive EW on a channel would
disconnect itself somehow after sending cache-upd-end-ack, and the
active EW would do so after it receives cache-upd-end-ack (from the
last paired EW).

If traffic without the control bit -- the 'RING' bit -- arrives on a
circuit without an associated EW, that's an inconsistency that should
trigger whatever appropriate level of scram.

:323]


:322]

:321]
:320]

:319]

:318]

:317]

:316]

:315][314:

Thu Mar 26 15:20:31 2020 OK did the 2020 census so that's a check
mark.

:314]

:313]

:312]

:311]
:310]

:309]

:308]

:307]
[324:

Fri Mar 27 15:27:28 2020 OK, so let's try to implement circuits.  One
bit control, one bit active, four bits circuit number.  Active bit is
automatically toggled on ITC receipt to find the packet recipient
(assuming consistency).  Active+control => ring (allocate EW if
possible); !active+control => hangup (free existing EW after
processing.)
[325:

Sun Mar 29 09:25:17 2020 Jeez hask ate up a day and a half.

[326:

Sun Mar 29 09:25:42 2020 So circuits belong to T2ITC.  How does it go?
circuit struct has its own number, an EW pointer or s32index, anything
else?

:326]

:325]
:324]
[327:

Mon Mar 30 01:30:36 2020 OK well I made the data structures for
circuits, and reorged EWSet so that the T2Tile owns all the EWs,
instead of any particular EWSet.  So how exactly do we USE these
circuits?  Let's try to gin up some

TODO

[328: Mon Mar 30 04:54:21 2020
DONE :328] - Routine to allocate any available active side, for use when setting
   up an active-side EW.  Probably prefer FIFO if we have an
   allocation order choice?

[329: Mon Mar 30 04:54:26 2020
DONE, probably.. :329] - Routine to free

:327]
[330:

Mon Mar 30 04:54:55 2020 So let's have an event cycle

main loop
 - just cycles over a master list of state machines, updating them

 - There is a common base class for all such machines
   = Handling stuff like setting and clearing timeouts on machines,
     and interacting with the master list / priority queue of
     the state machines.

One of those state machines is the EVENT INITIATOR.  It picks a random
location and tries to initiate an event there.  Initiation fails if:

 - No free EW is available
 - Anything in the chosen neighborhood is already in use by another
   EW.
 - No free active circuit is available on any necessary ITC.

:330]
[331:

Mon Mar 30 14:57:21 2020 OK well we're working our way down from the
top and now generating code at great velocity here, and we have
arrived at T2EventWindow::update().  I want to follow the basic
pattern of the KITC state machine, so we need to get our XX states in
some kind of better order here.

Did we already start XX for eventwindows somewhere?  Kind of think we
did.
[332:

Mon Mar 30 15:00:05 2020 Not seeing it in itcSpike12 anyway..
Starting fresh.[333:

Mon Mar 30 15:40:01 2020 OK we're at:

    INITIATING ew 0x457268 at (7,18)+4
    update: 0x457268 IDLE: idle active or passive
    src/T2EventWindow.cpp:38: (update) XXX IMPLEMENT ME

Now what?  Well, we have to find out if we need locks or not.  How
shall we do that in our brave new world.

:333]

:332]

:331]
[334:

Wed Apr  1 14:15:16 2020 OK, so we got past T2sday and now we have to
sort out wtf we actually are in this redesign.  In particular, are we
going to try for a VO-ish like base class for all objects that want to
get turns on the main loop?  We've started building
ActiveObjects.h/cpp but so far we're not using it anywhere.

Q1: What would be our categories/subclasses of AO?

 - EventWindows wanting to time out

 - ITCs wanting to time out..  I guess 'wanting to time out' is
   redundant?  That's what 'being an AO' fundamentally means?

 - An EventInitiator

 - A Display driver

 - Possible stats collectors and log generators

 - A touch screen driver

 - Other UI elements

[335:

Wed Apr  1 14:20:12 2020 Well okay that's a good smattering of cases.

Q2: How much emphasis on EW/ITC performance do we want in the design?

 - Could have separate loops for different speeds of updates?  So we
   could beat on the EW/ITC/EWINIT guys as fast as we can, while we
   wouldn't even dereference the pointer to logging generator more
   than once a minute or whatever?

 - Could pull the timeouts forward into a single array for better
   cache performance.

(BTW:

    TI AM3352, AM3354, AM3356, AM3357, AM3358, AM3359 (15x15 mm, 0.8-mm ball pitch, ZCZ package)
 .. - 32KB/32KB of L1 Instruction/Data Cache with Single-Error Detection (parity)
    - 256KB of L2 Cache with Error Correcting Code (ECC)

so that L1 is ta-EYE-knee.  I wonder what the structure of L2 is
like?[336: Wed Apr  1 14:39:50 2020 Well, for the Cortex A8,
https://developer.arm.com/docs/ddi0344/b/level-2-memory-system/cache-organization
says:

  The L2 cache is 8-way set associative of configurable size. The
  cache is physically addressed. The cache sizes are configurable with
  sizes in the range of 0KB, 64KB, 128KB, 256KB, 512KB, 1MB, and 2MB.

so that's not too terrible.
[337:

Wed Apr  1 15:00:12 2020 Additional details from the Cortex A8 ARM
manual:

    fixed line length of 64 bytes

    physically indexed and tagged

    8-way set associative cache structure

    support for lockdown format C

    configurable 64-bit or 128-bit wide AXI system bus interface with support for multiple outstanding requests

    random replacement policy

(*random* replacement?  How do we think that's really implemented?)

not to mention:

    The L2 memory system does not support hardware cache coherency,
    therefore software intervention is required to maintain coherency
    in the system.

So Anyway.
[338:

Wed Apr  1 15:13:35 2020 64 byte cache lines; that's only four u32s
per line, if we're imagining a u32 for a timeout.  But at some level
we'd like to focus on the 32KB L1 cache..[339:

Wed Apr  1 15:28:06 2020 And by the way, for the story on the Cortex
A8 L1 I+D caches:

    Each cache is 4-way set associative of configurable size. They are
    virtually indexed and physically tagged. The cache sizes are
    configurable with sizes of 16KB or 32KB. Both the instruction
    cache and the data cache are capable of providing two words per
    cycle for all requesting sources. Data cache can provide four
    words per cycle for NEON or VFP-Lite memory accesses.

:339]

How many entries are we really imagining?  32 EWs, six ITCs..  Are we
including the circuits as separate AOs, or are they active only via
their ITC?

Perhaps like a hundred max?

:338]
:337]
:336]
)

:335]

:334]
[340:

Wed Apr  1 15:39:46 2020 Also, there's the issue that came up at the
last minute while crushing for T2sday: How do we do the random
iteration without replacement?  We ended up double buffering the
active EWSet so we could move the active EWLinks between sets, but
that doubles the cache pressure right there.  It would be better if we
had like a 'drain pointer' or something, so we could move things to
the end of the array as we pulled them out of the front of the array,
until the last thing was pulled out of the front:

    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | a | b | c | d | e | f | g | h |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 8    waitingCount = 0

Pull random (got 4/e), step 1 (empty selected active):
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | a | b | c | d | - | f | g | h |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 7    waitingCount = 0

Pull random (got 4/e), step 2 (move down last active):
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | a | b | c | d | h | f | g | - |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 7    waitingCount = 0

Pull random (got 4/e), step 3 (move down last waiting):
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | a | b | c | d | h | f | g |   |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 7    waitingCount = 0

Reinsert e:
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | a | b | c | d | h | f | g | E |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 7    waitingCount = 1

Pull random (got 2/c), step 1 (empty selected active):
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | a | b | - | d | h | f | g | E |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 6    waitingCount = 1

Pull random (got 2/c), step 2 (move down last active):
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | a | b | g | d | h | f | - | E |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 6    waitingCount = 1

Pull random (got 2/c), step 3 (move down last waiting):
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | a | b | g | d | h | f | E |   |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 6    waitingCount = 1

Reinsert c
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | a | b | g | d | h | f | E | C |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 6    waitingCount = 2

Pull random (got 5/f), step 1 (empty selected active):
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | a | b | g | d | h | - | E | C |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 5    waitingCount = 2

Pull random (got 5/f), step 2 (move down last active):
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | a | b | g | d | h | - | E | C |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 5    waitingCount = 2

Pull random (got 5/f), step 3 (move down last waiting):
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | a | b | g | d | h | C | E |   |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 5    waitingCount = 2

Insert new AO (named 'i'):
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | a | b | g | d | h | C | E | I |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 5    waitingCount = 3

Reinsert f
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | a | b | g | d | h | C | E | I | F |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 5    waitingCount = 4

Pull random (got 0/a):
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | h | b | g | d | F | C | E | I |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 4    waitingCount = 4

Pull random (got 0/h):
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | d | b | g | I | F | C | E |   |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 3    waitingCount = 4

Reinsert h
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | d | b | g | I | F | C | E | H |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 3    waitingCount = 5

Reinsert a
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | d | b | g | I | F | C | E | H | A |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 3    waitingCount = 6

Pull random (got 1/b):
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | d | g | A | I | F | C | E | H |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 2    waitingCount = 6

Reinsert b:
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | d | g | A | I | F | C | E | H | B |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 2    waitingCount = 7

Pull random (got 1/g):
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | d | B | A | I | F | C | E | H |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 1    waitingCount = 7

Reinsert g:
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | d | B | A | I | F | C | E | H | G |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 1    waitingCount = 8

Pull random (got 0/d):
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | G | B | A | I | F | C | E | H |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 0    waitingCount = 8

Reinsert d:
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | G | B | A | I | F | C | E | H | D |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 0    waitingCount = 9

Random queue is empty.

Flip queue:
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | g | b | a | i | f | c | e | h | d |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  activeCount = 9    waitingCount = 0

[341:

Wed Apr  1 16:31:03 2020 Well, that seems reasonably nifty but are we
sure we have a real place and need for it?  And do we really believe
we can call for random numbers (from Mersenne twister, if we use
Random.h) without enough I+D cache pressure to render all this
niftyness moot?

:341]
:340]
[342:

Thu Apr  2 01:00:24 2020 OK have a few hours here.  I want some ROUGH
CONSENSUS AND RUNNING CODE.

 - So I think a general AO framework is probably NOT indicated here.
   Why?  Because a main purpose of it is to increase flexibility and
   ease extension later.  We don't REALLY need either.

 - But :334: already listed six types PLUS a catch-all for possible
   future GUI elements!  And having extensibility could also,
   possibly, conceivably, open the way to exposing some kind of
   low-frequency, tile-scale, API to ulam and beyond in the future.

 - Well if we did it, is our innermost loop really going to just beat
   a list of all AOs, no matter that most of them will be sleeping?

 - Aand do we need to allocate each concrete instance of an AO as a
   full-fledged object, so it can be deleted?  The whole VO/AO idea is
   VERY Java-esque, since it depends on everything being glued
   together with pointers.  It doesn't really play well with C++,
   where we want to do HAS-A via direct embedding of objects inside
   other objects.  An entry on the 'master AO list' might be pointing
   at a data member of some other object?

 - Well, that's kind of a compelling argument there.  Perhaps we
   should just take the seven :334: types, boil them down a bit, and
   implement them as special cases?

 - Related point: Basically we're talking about the event loop, here.
   And eventually we're going to need to play along with SDL's event
   loop, right?  And when we get there we'd like that to be
   considerably snappier than it currently is.[343:

Thu Apr  2 02:39:18 2020 I guess the approach there is the 'Display
driver' of :334: would actually have two parts (1) updating the
display, and (2) processing the SDL event queue.  Draining it?  Or
processing up to some number of events?  But let's pretend we can
control the event loop and deal with SDL events when we want to, and
we'll just try to want to often enough that input events don't lag too
horribly.
[344:

Thu Apr  2 02:46:08 2020 So, we could still implement the random
iterator, but we wouldn't apply it to all-active-objects-at-once.  We
could have one for all-active-event-windows, all-ITCs (or
circuits?)..  But where's our lovely cache behavior then?  The one
true array is shattered into pieces.

Review event types.

 - Event window updates.  As currently envisioned, local event windows
   complete over a minimum of two updates: After the event initiator
   creates them they have to wait for their own proper update before
   they can even realize they don't need any locks.  So, such an event
   window wants an 'effectively immediate' timeout.

   = We could rejigger that so that event initiator transfers control
     to the newly-created EW, and it runs as far as it can, possibly
     to completion, unless it discovers it needs to block.

   = But then we're basically implementing threads by hand?

 - ITCs need to poll for packets, since we're not like interrupting on
   input ready or something.  And packets, in turn are what trigger
   EW updates without a timeout.

 - Well screw it.  Suppose we did a real priority queue based on u32
   time and time_before in the wrap-around style.  We assert that
   anything we insert into the pq has a timeout soon enough that
   wrapping won't be a problem.  We randomize update order by
   randomizing timeouts.

 - Innermost loop:
         while (!done) {
           pollForITCPackets();
           callEventInitiator();
           checkTimeouts();
         }

    where checkTimeouts() runs everything that's expired on the main
    pq, and includes input event polling at perhaps 10Hz, redisplay at
    perhaps 3-7Hz, and error timeouts for EWs, ITCs/circuits, and
    whatever.

 - We make a TimeoutAble base class, that has a u32 timeoutMs (or
   whatever the half-decent C++ time unit is), plus a perhaps u8
   nonce, set at random at insert time to break ties.

 - The pq comparator will compare the timeoutMS, then compare the
   nonce if tied, then finally compare the 'this' if still tied.

 - We use a Set<TimeoutAble*> with that custom comparator, which
   guarantees keys are unique so we can erase ourselves from the
   middle of the set precisely.

[345:

Thu Apr  2 07:02:37 2020 OK post e-chat.  Push a little more before
nap.

TODO

[346: Thu Apr  2 10:57:15 2020
DONE :346] - Make TimeoutAble.h/cpp
   = Has u32 ms + u8 nonce + TimeQueue* ptr
   = Implements whatever C++ calls Comparable
   = Implements insert(TimeQueue & ontq, u32 atTimefromNow)
   = Implements remove()
   = Declares pure virtual onTimeout();

[347: Thu Apr  2 10:57:19 2020
DONE :347] - Make TimeQueue.h/cpp
   = Has a Set<TimeoutAble*>
   = Implements insertRaw(TimeoutAble& ta)
   = Implements TimeoutAble * getEarliestExpired()

[348:
Done :348] - Make a demo main in TimeQueue

:345]
:344]

:343]

:342]
[349:

Thu Apr  2 10:57:32 2020 OK, nap time.

:349]
[350:

Thu Apr  2 16:19:34 2020 Well that was a good nap.  Now we need more

TODO

[351: Thu Apr  2 21:22:03 2020
DONE :351] - Make an SDL framework for the spike

[421: Wed Apr 15 02:37:16 2020
DONE :421] - Get simple animations and touch inputs working using TimeoutAbles
   plus existing Panel stuff, following t2viz

[422: Wed Apr 15 04:32:11 2020
DONE :422] - Make a TimeQueue status display in a panel, to demo the tech.

 - Come back and make more to-do

:350]
[352:

Thu Apr  2 23:38:52 2020 OK, well, I'm apparently now (re)building the
SDL interface for this (rapidly less tiny) 'spike'.  And I'm intending
to fold t2viz functionality into this, and get rid of the horrible
signalling that mfmt2 and t2viz were doing to each other -- so we need
a scheme for supporting multiple major views in the interface, and be
able to switch between them, and hopefully even post pop-up menus that
go away appropriately when switching views and so forth.

So I REALLY think we want some kind of little textual config file to
direct setting up the window hierarchy -- something like a .oio file
from VIDEX2018, except much simpler -- so that we can diddle with this
crap A LOT without always recompiling the world.

'Keep It Super Simple'.  A panel name, a panel type name, a parent
panel name, and x y w h.  One line per entry.  Scanf with "%s %s %s %d
%d %d %d\n"

:352]
[353:

Fri Apr  3 12:07:32 2020 OK I'm completely confusing myself with all
these broad container classes at the top.  We need to sort it all out
before going further.

 - main.cpp: MainDispatch declares
   = T2Tile as the top container for all tile operations
   = SDLI as the interface to SDL

 - But in addition we have
   = T2Viz, which currently holds panels and general what-not for
     t2viz operations, and
   = Engine, an abstract base of T2Viz

So how about something like this:

 - Let's tie displays and 'engine' together, so t2viz-ish panels and
   t2viz-ish implementations would go together.. really?

Q: Do we put t2viz timeouts in the same TimeQueue as EW stuff?

Seems like we mostly should, I think.  Everything ever active goes in
the TimeQueue.  And everything that might ever display goes under some
master root panel thing.  Question is: Should(n't) we use the existing
save/load stuff to get panels configured?  Instead of starting a whole
new thing?  I guess we should check.

And we really do need to maintain as much compatibility in .mfz files
between mfms and mfmt2/itcSpike12..  That doesn't necessarily mean we
have to support .mfs though.  Worrying that the panel deserialization
stuff is going to be waay-too-tightly coupled into the whole existing
mfms template-madness codebase.[354:

Fri Apr  3 16:03:26 2020 It really is.  We have to get our fledgling
spike up on its own feet first, even though it means signficant redo.
[355:

Fri Apr  3 16:22:39 2020 So.  Even if we put 'everything' in T2Tile,
we need to have some structure within that.  Separating the event
system from the t2viz system, for example.[356:

Fri Apr  3 16:56:22 2020 Well, have to move the flag again.

:356]

:355]
:354]

:353]
[357:

Sat Apr  4 12:32:17 2020 So like a genius I left behind the tile that
all this was on, and somehow sshd had died on the workstation so I
couldn't get into that to get the backup files.  So I drove back and
got the missed tiles grrr.  So where TF are we here?

:357]
[358:

Sun Apr  5 04:55:31 2020 OK so we've just been working from the front
here.  Did a bit of command line arguments stuff; just XX'd it up to
implement '-h'..  Now how do we go forward?  Back to window config.

:358]
[359:

Sun Apr  5 08:53:45 2020 Well we have a first cut at a window config
file and we want to see the windows getting drawn.  But right now
we're dying unimplemented in trying to initiate an EW.

So that kind of forces us back to the whole event pacing / time queue
business and so on.  Where did we leave ourselves on that?[360:

Sun Apr  5 09:00:52 2020 Well, :353: was saying everything goes in the
same TQ.  If so, then the current notion of:

  void T2Tile::main() {
    initEverything();
    while (!isDone()) onePass();
    shutdownEverything();
  }

  void T2Tile::onePass() {
    maybeInitiateEW();
    updateActiveEWs();
    advanceITCs();
    maybeDisplay();
  }

doesn't seem to follow.  Seems like it should be more like:

  void T2Tile::main() {
    initEverything();
    while (!isDone()) {
      TimeoutAble * ta = mTimeQueue.getEarliestExpired();
      if (!ta) msleep(1); // Or ??
      else ta->onTimeout(mTimeQueue);
    }
    shutdownEverything();
  }

and everything else happens down under onTimeout.  After getting
stuffed into the TQ during initEverything().[361:

Sun Apr  5 09:14:22 2020 Well let's give that a shot.

:361]

:360]

:359]
[362:

Mon Apr  6 13:48:13 2020 OK, well, we have a bunch of windows up, and
we're using a wconfig.pl perl script to generate the wconfig.txt file
so we can do arithmetic to derive window positions, and we really
should've just bit the bullet and hardcoded the window setup instead
of parsing it at runtime.  But we'll see.

In any case, we have (to become) ITC panels at plausible locations on
the screen, and a log panel that updates when the log does, and some
scattered test windows.  And we can detect mouse hits, and dispatch
them into the Panel tree plausibly, but we are currently not doing
much with them.

And it's like a deep deep rat hole to go down trying to figure out how
to remap 'mfms-like' UI behaviors without a keyboard.

[363:

Mon Apr  6 14:09:11 2020 Could we make a tracker for the user button?
Is CDM or somebody currently watching that?

..yeah, it's currently launching t2viz.  Well, let's try to import the
semantic guts of t2vis into itcSpike12 so we could ditch t2viz and
free up the user button..

:363]

:362]
[364:

Mon Apr  6 15:56:10 2020 Well, generated a lot of code here; taking a
break.  The corner lights are rotating again, and we're basically at
the 'porting T2viz update guts to itcSpike12' stage.

Pick up in T2InfoPanel::onTimeout.

:364]
[365:

Tue Apr  7 04:56:02 2020 So, relaxed for a while.

TODO

[416: Wed Apr 15 02:34:44 2020 SCRAPPED FOR MANUAL CONFIG
NOT DONE :416] - Build a popup menu that autoconfigures from an underlying Panel
   that inherits from PopupMenuAble or whatever.  Make it 3x3 with
   center always 'Cancel'.  If necessary make the lower right always
   'More..' more than eight total menu items are encountered.

[417:
NOT DONE :417] - Have super classes able to contribute menu items?  And they fill
   the menu in most-abstract-first order so they will appear in the
   same positions across (potentially) many menus

 - Make a 'ViewChooser' window that supports having just one of its
   children visible at any given time.  Have ViewChooser contribute a
   'View..' menu item.

[418: Wed Apr 15 02:36:12 2020 Manually, but
DONE :418] - Have a Chooser be the first child of Root.  Have Grid and T2Viz be
   children of the Chooser

[419:
NOT DONE, DITCHED :419] - PopupMenuable supplies methods
   = Say how many entries it contributes
   = Configure a given MenuButton (subtype of Label?) for its entry #n
   = Respond to a hit on its entry #n

[420:
DONE MANUALLY :420] - One possible response to a hit should be to post a different popup
   menu.   And how would such a submenu be populated?

:365]
[366:

Wed Apr  8 17:18:16 2020 So we've been trying to run down an erratic
framerate for an hour or so here, and the suspicion is increasingly
falling on the interaction between itcSpike12's desired fps and the
fbtft configured 'fps'.[367:

Thu Apr  9 02:05:54 2020 Well so the long and the short of that was
that fbtft is currently set to 15FPS -- but that doesn't actually set
the display rate, it just sets how long the fbtft LKM waits, after the
first write to display memory, before it locks the pages and starts
squirting them off to the display (via SPI in our case).

That delay wants to be long enough that userspace can finish writing
its changes to display memory before fbtft comes in and locks the
pages.  But that delay also wants to be short enough that, after the
delay expires, fbtft will finish writing the SPI transactions and free
up the pages before userspace calls SDL_Flip again.

So with fbtft set to 15FPS, if I try to do more that about 6.5FPS in
userspace, I start getting uneven timing across SDL_Flip calls.  If I
set userspace to 10FPS, I end up observing like 8.5FPS and seeing half
the frames missed.

I don't have any really good sense how long a full-screen-dirty
SDL_Flip takes, but it might be we could push to 16 or 18 or 25FPS or
whatever, and still reliably finish the SDL_Flip before fbtft times
out.  The fantasy is we could then up our userspace FPS a bit will
maintaining a smooth tempo, because fbtft would start and thus finish
the SPI transaction earlier, before our next SDL_Flip hits.

I am tempted to try setting fbtft to 20FPS, since that appears to be
the default that I decided to modify somewhere along the way.[368:

Thu Apr  9 03:21:30 2020 Well, trying 20.  Did RISKY BITS OFF.  Rebooting.

[374:

Thu Apr  9 05:49:06 2020 Not liking 20 so much.  Seems like I miss
frames every so often anyway?  Perhaps it's a 'front end' failure,
where SDL_Flip is still going when the pages get locked?  We had been
at fbtft fps=15 which means (/ 100 15) -> 6 jiffies delay; let's go
back to that and see if our apparent vanished frames all reappear.

Or we could go to (/ 100 14) for 7 jiffies and see if that slows us
down as far as getting 6 or 6.5HZ userspace..  Let's try 14.

:374]

:368]

:367]

:366]
[369:

Thu Apr  9 03:25:46 2020 OK, so:

    root@beaglebone:/home/t2/MFM/src/drivers/itcSpike12# grep fbtft /var/log/syslog
    Apr  9 03:22:26 beaglebone kernel: [   48.095839] fbtft: module is from the staging directory, the quality is unknown, you have been warned.
    Apr  9 03:22:27 beaglebone kernel: [   48.941817] fbtft_of_value: regwidth = 16
    Apr  9 03:22:27 beaglebone kernel: [   49.082551] fbtft_of_value: buswidth = 8
    Apr  9 03:22:27 beaglebone kernel: [   49.173713] fbtft_of_value: debug = 2
    Apr  9 03:22:27 beaglebone kernel: [   49.287892] fbtft_of_value: rotate = 270
    Apr  9 03:22:27 beaglebone kernel: [   49.388062] fbtft_of_value: fps = 20
    Apr  9 03:22:27 beaglebone kernel: [   49.473773] fbtft_of_value: txbuflen = 32768
    Apr  9 03:22:27 beaglebone kernel: [   49.616957] fb_ili9486 spi0.0: fbtft_request_one_gpio: 'reset-gpios' = GPIO30
    Apr  9 03:22:27 beaglebone kernel: [   49.762539] fb_ili9486 spi0.0: fbtft_request_one_gpio: 'dc-gpios' = GPIO48
    root@beaglebone:/home/t2/MFM/src/drivers/itcSpike12#

Let's see if it makes any difference..[370:

Thu Apr  9 03:27:16 2020 Well now it looks like userspace 10HZ gets us
about 9.25HZ -- which is definitely more -- but I'm still losing half
the frames.  Let's try 8HZ..[371:

Thu Apr  9 03:31:38 2020 Looks like 8HZ requested is getting us about
7.6HZ actual, with definitely fewer dropped frames.  7.5HZ might be
pretty solid?[372:

Thu Apr  9 03:34:15 2020 Nope, still losing some frames at 7.5HZ;
getting like 6.9HZ, hmm.  Trying 7HZ?[373:

Thu Apr  9 03:37:07 2020 Looks pretty solid.  Seems to be getting like
6.930HZ-6.955HZ with no signs of dropped frames.

Note also we are currently compiled at -g2.  But we're also running at
our toasty 1GHZ:

      current CPU frequency is 1000 MHz (asserted by call to hardware).

With this combo so far, we seem to be eating under 20% of the machine:

      PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
     2476 root      20   0   63176  47696   4016 D  16.5   9.6   0:48.50 itcSpike12
     2480 root      20   0       0      0      0 D   2.0   0.0   0:01.45 kworker/0+
 ..

for userspace plus the kernel SPI writer (we believe), 'leaving 80% of
the machine' to use for events.

Yah.

Once we can do events.

:373]

:372]

:371]

:370]

:369]
[375:

Thu Apr  9 07:41:15 2020 Well, it starts to seem like the 32MHz SPI
setting was a limitation of the display rather than the AM335X McSPI
hardware.  It appears the OMAP2 McSPI will go up to 48MHz.

And we've cranked it up that high and things mostly work but it seems
like the colors are a bit off.  Which seems quite odd for a digital
device, unless it's due to the display initialization -- setting up
its gamma and who knows what else -- is getting messed up at 48MHz.

But reading the internet and using the force makes me think we might
be able to leave the device tree speed at 32MHz, but then use an ioctl
in a C program to crank it up to 48MHz long after the display has been
initialized.

:375]
[376:

Fri Apr 10 00:44:04 2020 Well not sure if that Hz and MHz sideshow
really bought me much of anything, but targeting 6Hz userspace updates
for now in any case.

And WE HAVE TO GET SOME KIND OF MENU WORKING.  SO MAKE SOME FOGGEN

TODO

[378: Fri Apr 10 01:02:47 2020
DONE :378] - Figure out how to activate the Menu / MenuItem / MenuMaker code
   that's currently written but untested.

[414: Wed Apr 15 02:34:25 2020
DONE, I think :414] - Activate it for the parent of T2InfoPanel, whatever that is.

[415: Wed Apr 15 02:34:34 2020
DONE :415] - Watch it explode, then fix it as minimally and expeditously as
   possible.

:376]
[377:

Fri Apr 10 01:02:18 2020 OK our menu code doesn't even build once we
actually try to use it.  Get to work.
:377]
[379:

Fri Apr 10 01:29:29 2020 OK so we're tracing through touch (mouse)
event dispatching.  To recap:

We go down via

  Panel::Dispatch(MouseButtonEvent&)

until we find the panel that contains the hit, at which point we
switch to Event::Handle(Panel&), which (in the current case) dishes
back

  Panel::Handle(MouseButtonEvent&)

In this particular case we hit a TextPanel (SimLog), and its
Handle(MBE&) does some random stuff like adjust its elevators and so
on.  Where is the 'activate pop up menu' function supposed to come in?

[380:

Fri Apr 10 02:25:21 2020 What if we used the user button to trigger
(and cancel) the top-level pop-up menu, and then fold into normal
event handling once the menu is onscreen?  How do we gin up a
synthetic SDL_Event for that button?  (Not that we really need to be
that systematic, since we control the top-level anyway.  But let's
freshen up our user button brain.)

[381:

Fri Apr 10 02:31:28 2020 The TNV code which we imported (or at least
started to) for the t2viz view includes the user button.[382:

Fri Apr 10 02:33:48 2020 But that code (in T2InfoPanel.cpp) is only
getting run once a second.  And That Certainly Won't Do for the User
Button.  We want to poll the user button every redisplay, I'd think,
so like 6Hz.[383:

Fri Apr 10 02:39:05 2020 Right now all the ADCs are updated by
T2ADCs::update() which is getting called no-where, in itcSpike12, as
far as I can tell.  (T2ADCs::update -- which lives in
/home/t2/T2-12/apps/tnv, by the way -- is getting called by tnv.cpp in
that same directory.)

So there's no significant performance advantage to doing them all at
once, since they've reading independent FILE*s, so we could break out
like updateChannel(ADCChannel) and have update() just loop through
them.  Then on the itcSpike12 side we could wrap each individually and
launch them into the TimeQueue.  Voltages and temperatures could be
updated every second or even less, the light sensor at maybe 2Hz or
so, and the user button at 6Hz or even more.  We could even flow its
readings into synthetic SDL_Events and let them percolate up that
way.  [384:

Fri Apr 10 02:45:57 2020 Now, at the moment, checkInput gets called
only during redisplay, so going much faster than that doesn't seem
critical?  Well, it is if we want to pick up a quick click, I guess.

Kind of a drag though, to eat any noticeable chunk of the machine for
something that will happen so rarely across spacetime.  I think we
should say you need 'a firm press' on the user button, not just a
minimal click, and then 6Hz polling should be plenty reliable enough.

:384]

:383]

:382]

:381]

:380]

:379]
[385:

Fri Apr 10 14:55:45 2020 So, current issue is I'm generating an
SDLK_MENU KeyboardEvent and injecting it into the SDL event queue, and
it's getting pulled off and propagated.. but that propagation still
depends on having a 'last known mouse position', which is (0,0) by
default and therefore (it seems) doesn't much the ChooserPanel which
is inset by its border.

:385]
[386:

Fri Apr 10 23:32:01 2020 Well so now we're having the root panel be a
MenuMakerPanel, and it does catch the KEYDOWN events we're generating
on the user button.  Reacting on DOWN rather than UP makes it feel
quite a lot snappier.  It's possible to miss a very short click, but
most satsifying clicks get noticed and reasonably promptly.

So now though, what next?  How do we check if the (toplevel, or any?)
popup menu is posted?  We want to post top-level if no popup menu is
posted by anybody, and otherwise we want to popdown (via its cancel)
whatever popup menu is up.

How do we know if a popup menu is posted?[387:

Fri Apr 10 23:47:14 2020 Make a global singleton -- like stashed in
SDLI -- and keep the popup menu state there.  We'll reconfigure the
same menu on the fly as we 'enter submenus', and there'll be no nested
'Back' functionality unless we keep a menu stack in the singleton
somehow.  I guess that could be like just a stack of MenuMakerPanel*'s
as one possibility... Or could it?  Couldn't the grid display, say,
want several submenus all its own?  How would that be handled?

We're gradually moving toward a centralized menu system, here, so do
we really need to associate menus strictly with panels?  Vs what
exactly?  [388:

Sat Apr 11 00:10:29 2020 I'd sort of like to have the central menu
system able to handle 'boring ordinary menu items' directly, plus have
a way for MenuMakerPanels to contribute custom panels to a menu as
desired.

So the central menu system would keep around say nine 'default'
buttons, which would be used in each of the 3x3 spots that didn't have
a custom Panel* supplied.  Each of those default buttons could be
configured on a per menu basis, in a light-weight declarative way, to
be 'empty' or 'cancel' or whatever other basic functions we end up
with.

So, what is the outcome of a popup menu navigation interaction?  An
event should be generated, I guess.  But we don't want the event to
propagate, or else we'll need to have a screen location for it.  So we
need to know who to deliver the message to.

Could we just say each button contains an event + a panel, and
clicking the button means send the former to the latter?  And fold all
of submenu navigation and so forth into that?

Could we further just say each pop-up menu design has a name, so we
can refer between menus by name?  So we can say 'POST SUB6', as a
configuration string somewhere perhaps, and have that mean deliver a
POST event to the menu named SUB6?

So then we could configure menus in wconfig?  If we had some little
action language like that.

That could at least get us fogging going here.

[389:

Sat Apr 11 00:57:49 2020 So let's try to summarize.. we've got some
conflicting notions right there..  Latest thoughts:

 - Popup menu is just a kind of panel

 - It gets configured in wconfig, with some little custom language to
   describe button text and whatever.

 - That language can say things like 'pop up FOO menu' and 'dismiss
   this menu',

 - And things like 'pop-down the entire menu system', and ..?

 - Some special menu is recognized as to be popped up by the user
   button.

 - The popup menu state is tile-wide and stored in SDLI unless there's
   some better place.

[390:

Sat Apr 11 01:07:05 2020 Of course as I write that I start swinging
back towards less-centralized approaches.  If we're laying this stuff
out via wconfig, we could be using it for the element palettes and so
forth.. Where a 'menu' might not cover the entire screen, and
interactions with other windows could take place while a menu is
posted.  And there could be multiple simple menus posted in various
windows at the same time.

The actual 'centralization' really doesn't need to be any more
invasive then having one privileged menu name that gets raised or
lowered when the user button is hit.

[391:

Sat Apr 11 01:33:58 2020 So maybe let's make some wconfig/.pl assist
to help make and layout buttons for menus (and etc)?

MENU ACTIONS:

 - ENTER MENUNAME: Raise MENUNAME to top of its container and make it
   visible

 - LEAVE MENUNAME: Lower MENUNAME to bottom of its container and make
   it invisible

 - PUSH MENUNAME: Do ENTER MENUNAME and push MENUNAME on top of
   mPostedStack

 - POP: If mPostedStack is non-empty, pop top MENUNAME and do LEAVE
   MENUNAME

 - DISMISS: While mPostedStack is non-empty do POP



[ModeMenu Menu Modes GEOM]
   layout=3x3
   button3="Grid":ENTER Grid
   button4="Tile":ENTER T2Viz
   button5="Data":ENTER Stats
   button7="X":DISMISS

[392:

Sat Apr 11 01:56:36 2020 Might be nice if we could define buttons by
name at top level, and then just invoke them, rather than trying to
fold all the properties into a one-liner.

How committed is the wconfig code to having top-level entities all be
Panels?[393:

Sat Apr 11 01:58:15 2020 Well,

(1) If we see a '[' we go to parsePanelDecl, and
(2) we attach subsequent properties to 'Panel * prevPanel'.

So that's non-trivially committed to Panels, I'd say..

Well and why again do we want buttons NOT to be panels?  It just seems
too heavyweight to type it all in?

FOG IT LET'S JUST TYPE IT ALL IN.

We still need to have a menu stack somewhere, if we're going to
distinguish 'back' from 'dismiss'.

:393]

:392]

:391]

:390]

:389]

:388]

:387]

:386]
[394:

Sat Apr 11 11:23:49 2020 OK once again, moving the flag.

RISKY BITS OFF.

:394]
[395:

Sat Apr 11 13:44:48 2020 OK we're set up again, and we've gotten the
latest wconfig-based partial whack at menu stuff kind of running.  Now
we need to hook the user button's SDLK_MENU KEYDOWN to the GlobalMenu
somehow, and we need a place for the menu stack to exist, if indeed
it's going to.

:395]
[396:

Sat Apr 11 15:52:53 2020 OK so the user button is posting and
unposting the 'GlobalMenu', and we can touch a menu button and get

    17: ERR: include/Menu.h:40: (OnClick) XXX IMPLEMENT ME

so that's progress.

But now we have to implement the oh-so-vaguely implemented 'action
language'..

:396]
[397:

Sun Apr 12 07:16:16 2020 OK screw it.  On the 'What Am I Actually
Saving It Up For?' principle, I'm making T2Tile a singleton.

And May The Lord Have Mercy On My Soul.

:397]
[398:

Sun Apr 12 17:43:53 2020 Well, progress but still struggling to get
the menu button plumbing actually working.  Have to go cook now.

Status

 - Confused about who to deliver menu actions to.  How do we get it so
   raising one 'view' or 'mode' window automatically sets its other
   siblings to not visible?  (So we don't waste time updating them
   just to be overwritten.)

 - Seems like we want some explicit 'full-screen single child view'
   kind of panel, and we ask that thing to raise and dismiss its
   kids.  We had moves towards 'ChooserPanel' to be such a thing, but
   aren't sure what state that's currently in.

 -


:398]
[399:

Mon Apr 13 00:29:43 2020 Let's make a single foggen MenuManager thing,
and let it execute all the menu actions.  Do the stuff we have, but at
the bottom dish to the MenuManager with the 'hit window' that we're
in, plus the MenuAction that is to be done.  Put the MenuManager in
SDLI probably.  Just do it.  Go go go go go.[400:

Mon Apr 13 00:41:04 2020 Maybe even move the parsing of wconfig action
properties from strings to MenuActions into the MenuManager?  Then it
can represent them any foggen way it likes, since it's going to be the
ones executing them.[401:

Mon Apr 13 00:47:21 2020 Nah leave it.  It's being handled by
MenuItem, which dishes to MenuAction, which is all pretty reasonable
as far as the crazy mess we currently have.

(Jeez we're into the :400s:.  Maybe time for a new notes file soon?)
[402:

Mon Apr 13 00:56:25 2020 Note the current MenuAction is using an
SDLKey to represent the 'action', which seems flexible, kind of, but
also pretty indirect and arbitrary.  The main advantage of doing so is
that it uses the SDL event queue to decouple the call stack that
generates the MenuAction from the call stack that executes it.

If MenuActions are limited to causing immediate panel property changes
and restacking, it feels natural to execute them immediately, and
talking to ourselves through SDLKeys seems silly.  But if MenuActions
are supposed to be able to simulate general clicks on buttons, we
really want end the call stack ASAP and have the click happen as a
result of standard event processing later.

:402]
:401]

:400]

:399]
[403:

Mon Apr 13 02:23:44 2020 OK, we're down to implementing
MenuManager::execute(MenuAction&, Panel *).  Review our intended
semantics.  From Menu.h:148

    // Commands understood:
    // CALL PANEL -- SDLK_RIGHT -- Deactivate/push current and raise/activate PANEL
    // RETURN     -- SDLK_LEFT  -- Pop stack and raise/activate previous.
    // GO PANEL   -- SDLK_DOWN  -- Clear stack and raise/activate PANEL
    // DISMISS    -- SDLK_UP    -- Do POP until stack empty

Points:

 - GlobalMenu posting should put the global menu at the bottom of the
   stack -- make it equivalent to DISMISS + CALL GlobalMenu[404: Mon
   Apr 13 03:19:44 2020 No, better would be to put whatever 'single
   visible' is visible on the bottom of the stack, so that DISMISS
   will automatically take us back to that.  So it's more like DISMISS
   + CALL <current> + CALL GlobalMenu :404]

 - GlobalMenu unposting should be equivalent to a DISMISS

 - We should have a semantics wherein some particular type of panel
   can say that only its uppermost kid should be visible at any given
   time, so we don't even try to draw the others.  Are we intending
   'Root' to be that?  Let's say so for now -- but we should abstract
   this part of the RootPanel behavior into a SingleVisibleChildPanel
   or something.

What is our initial intended window layout for all this?

Root [Root]
|-> GlobalMenu [ChooserPanel]
|   |-> GlobalMenu_Button_PhysicsViz [MenuItem] {GO PhysicsViz}
|   |-> GlobalMenu_Button_T2Viz [MenuItem]      {GO T2Viz}
|   |-> GlobalMenu_Button_Control [MenuItem]    {GO Control}
|   |-> GlobalMenu_Button_X [MenuItem]          {DISMISS}
|
|-> PhysicsViz
|
|-> Control
|   |-> CPU speed, flash traffic, etc
|   |-> T2Viz_Button_X       [MenuItem]        {GO PhysicsViz}
|
|-> T2Viz
    |-> T2Info [T2Info]
    |-> StaticInfo [StaticPanel] // tag#s, mfzid
    |-> StatusInfo [StatusPanel] // ADCs etc
    |-> SimLog [SimLog]
    |-> ITC_NE,_ET,_SE,_SW,_WT,_NW [ITC]
    |-> Corner_NW, _NE, _SE, _SW [Panel]
    |-> T2Viz_Button_Control [MenuItem]        {GO Control}
    |-> T2Viz_Button_X       [MenuItem]        {GO PhysicsViz}

:403]
[405:

Mon Apr 13 11:32:02 2020 OK, so the menu stacking is finally starting
to seem plausible; moving on to a few more issues before we totally
start running out of time ahead of the T2sup.

 - T2InfoPanel is currently doing

  void T2InfoPanel::onTimeout(TimeQueue& srcTQ) {
    if (!IsVisibleFrom(0)) {
      sleepOn(srcTQ);           // Long timeout if not visible
      return;
    }

with the result that after posting and dismissing the global menu, the
corner lights have apparently died (because T2InfoPanel is now
sleeping for an hour.)

We'd prefer to let this happen, but have the 'makeSingleVisible'
functionality somehow jump the panel's timeout forward.. if the panel
has a timeout..[406:

Mon Apr 13 11:42:47 2020 Well, that LOOKED easy, like just this:

 ..
        if (kid==panel) {
          kid->SetVisible(true);
          TimeoutAble * ta = dynamic_cast<TimeoutAble*>(kid);
          if (ta != 0) ta->bump(); // wake dis mofo
 ..

but of course it's NOT THAT EASY.. Because kid, there is T2Viz, but
the panel that went to sleep is T2Info, which is a kid of T2Viz.

Not that T2Info, up there, is using
 ..
    if (!IsVisibleFrom(0)) {
 ..

which searches up to the root -- and figures out that since T2Viz is
invisible, then T2Info should sleep for an hour.

That means, if we're going to preserve this nice behavior, that
makeSingleVisible() -- and any similar visibility-changing routines --
is going to have to recursively bump() all the TimeoutAble's among the
children of the Panel becoming visible.

And that could be a problem if some TimeoutAble's down in there were
trying to use their timeout for some kind of, you know, ACTUAL TIMING.

Perhaps we should make 'sleeping' be a distinguishable state from
'having a long timeout'.  Then we could recursively wake sleepers
while leaving everybody else alone regardless of their timeouts.

How hard would that be?
[407:

Mon Apr 13 12:01:13 2020 Well, we could add a bool mSleeping to
TimeoutAble, but that would push it from 12 to 16 bytes and we'd kind
of wanted to keep TimeoutAble small..  It would also increase the
complexity of its operator<, which is a relatively inner-loop
operation in this area.

Or we could extend TimeQueue to have a different place to stash
sleeping TimeoutAbles.  But they'd still just have a single onTQ ptr
-- so we'd have to search two places to find them?

[408:

Mon Apr 13 12:05:22 2020 Given the limited time here, maybe we
shouldn't go down this road?  Maybe we should have T2InfoPanel still
be updating in the background, even though it's not visible?  Or have
it slow its updates only a little bit, like a few seconds rather than
an hour?

You could claim that we should keep updating it visible or no, since
other things could care about the information that it's gathering?
And it could be backwards averaging crap across time and who knows
what?  Now, I think none of that is currently true, buuuuut.[409:

Mon Apr 13 12:12:24 2020 Screw it, say T2Info will maintain its
update cadence and so be it.[410:

Mon Apr 13 12:31:20 2020 OK that's done.  Time to start spiffing up
these windows a bit..

:410]

:409]

:408]

:407]
:406]

:405]
[411:

Mon Apr 13 12:44:53 2020 OK so we have T2GridPanel now.  It's not
doing anything special but there it is.[412:

Mon Apr 13 12:56:06 2020 Let's try to get a bit more of T2Info's info
actually displaying..

:412]

:411]
[413:

Wed Apr 15 02:24:12 2020 OK so we shipped t2sup#274.  There are still
problems with the menu stack getting confused so that 'X' in the
global menu does nothing, so that's embarrassing anyway, but at least
Here Comes The External User Button To Save The Day, so for now,
whatever.

LET'S GET TO SITE DISPLAY AND EVENT WINDOWS!

:413]
[423:

Wed Apr 15 04:32:36 2020 OK so we can display the TQ.  Now I'm looking
back to :330:.

TODO

 - Make an EventWindowInitiator.

 - See it initiate some windows.

 - See it initiate EventWindows

 - Frame out the EW state structure.

 - Support multiple state advances in a single update.  I guess that
   means having states explicitly request blocking.  Well if we go
   with the 'kind of timeout' code, we can have NONE in addition to
   HALF, STANDARD, LONG, whatever..

:423]
[424:

Wed Apr 15 06:57:36 2020 So we want to have a checkbox for running
events or not.  How do we do that in wconfig land?  (Note that our
apparent checkbox in the Tile display is fake -- it's just a Label
with a checkbox checked icon.)[425:

Wed Apr 15 07:05:10 2020 Well, we subclass AbstractCheckbox, it looks
like.  A different subclass for each checkbox.  And we register its
type with SDLI.  And we can have multiple instances of that checkbox
scattered around the interface, and they'll all stay in sync, if the
class properly punches through to some shared state for SetChecked and
IsChecked..

[426:

Wed Apr 15 07:13:26 2020 Maybe, after nap, we should think about
checking in all this crab??

:426]

:425]

:424]
[427:

Wed Apr 15 14:25:04 2020 So we're initiating EWs now, but we're never
updating them, because we have this conflict between the old 'EWSet'
idea and the new 'TimeQueue' idea.  Right now the initiated EWs are
put onto the mActive EWSet and then then never considered again.
updateActiveEWs() is never called.

updateActiveEWs will flail all the actives in a random order, but
that's really a highly related take to what TimeQueue is doing also.

The difference is that updateActiveEWs is built on the premise that
EWs need to have multiple 'goes' with no external state changes,
whereas TimeQueue expects TimeoutAbles to do everything they need to
and then sleep for a while.  If they reschedule themselves to go
immediately, they shouldn't care what order they go with respect to
other timed-out entities.

updateActiveEWs is definitely an older way of 'cellular automata
thinking', and TimeQueue is a newer 'Movable Feast thinking' or
something.

So perhaps we could split the difference, and just use EWSet mFree to
allocate from, but then have the allocated EWs run to completion or
until they need to block on the tile master TimeQueue, and then get
returned to mFree whenever they're done.

So T2Tile::mActive[2] goes away, which I'm fine with.  What about
T2Tile::mPassive and T2Tile::mActiveBuffer?  Ditch them too?

[428:

Wed Apr 15 14:53:45 2020 Well, let's finally finally checkpoint all
this and then tear out that stuff.

:428]

:427]
[429:

Thu Apr 16 00:39:21 2020 OK so we need an update/advance/transition
function for T2EventWindow.  The thing that will actually examine the
state table.  I think we want it to be something like:

  do { ew.transition(); } while (!ew.blocked());
  if (ew.isDone()) ew.release();
  else ew.insert(srcTq, ew.timeout());

Let's do call the state machine update 'transition' -- that's
relatively unused in the code base so far.

:429]
[430:

Thu Apr 16 01:06:40 2020 So,

TODO:

 - Figure out where we are in the T2EventWindow state machine

 - Make a state transition framework to call

 - Make a advanceUntilBlocked access point, as above.

 - Call it from maybeInitiateEW

 - Also call it from T2EventWindow::onTimeout

 - Make more to-do.

:430]
[431:

Thu Apr 16 01:12:36 2020 Hey here's a thing: It seems like in the
current scheme, what's to stop us from allocating all our (active) EWs
to in-progress intertile events, and thereby have NO EWs left to run
any local events?

What happens then?  Is that a way to implement 'warp factors' to limit
how much more heavily the hidden sites get sampled?  But that'd really
warped, wouldn't it?  Hidden sites in edge and corner tiles would
really run away with everything, and central tiles would slog.

It kind of seems like we should have a single separate or reserved
T2EventWindow to use for hidden sites, and we'll do hidden site events
atomically?

:431]
[432:

Thu Apr 16 03:03:51 2020 Argh got pulled off task.  Refocus.

I think we should think about doing hidden events atomically, so they
don't even directly use allocated EWs.

T2Tile::maybeInitiateEW()

  (0) Change this signature to bool so we can call on return
  (1) Pick random candidate center
  (2) Examine center atom.  (Clear it if insane, once we get back to that.)
  (3) If radius 0 (only for empty?), return false
  (4) If anything in neighborhood isn't available, return false
  (5) Compute if hidden based on center and radius
  (6) If hidden, return tryHiddenEvent(ctr, rad), which runs event atomically
  (7) Otherwise, return tryVisibleEvent()


T2Tile::tryHiddenEvent(UPoint ctr, u32 radius)

  (1) Init a stack-local EW via ctr
  (2) Call ew.advanceUntilBlocked();
  (3) If !ew.isDone(), fail somehow.
  (4) Return true

T2Tile::tryVisibleEvent(UPint ctr, u32 radius)

  (1) Try to allocate a persistent ew
  (2) If none, return false
  (3) Init ew via ctr
  (4) Do insertOnMasterTimeQueue(ew,0)
  (5) Return true

T2EventWindow::onTimeout
  (1) Deliver timeout to state machine, however that works (but it
      involves advanceUntilBlocked or something like it)
  (2) If isDone, mTile.releaseEW(this)
  (3) Otherwise, reschedule based on timeout

T2EventWindow state machine notes
  Load the neighborhood.  Note we do not ourselves as siteOwner
  (4) Run the event
  (4) Write back the (changed portion of the) neighborhood

:432]
[433:

Thu Apr 16 05:00:23 2020 Well there's a lot of good stuff in :432: but
all fingers point to getting more serious about the ew state machine.
Let's review where we are:

 - ALL_EW_STATES_MACRO() at the top of T2EventWindow.h has the goods

 - ATM we're saying custom timeout and custom packet receive, like the
   ITC state machines, but we don't really yet know.

 - What's the active/passive deal finally anyway?  Are we saying a
   neighbor might ask for a lock that we could grant them but we say
   no because we have no passive ews to match up with it?  If not
   where do all the passive EWs come from?

 - It's a tangent but I guess do we want an ITCPacketAdvancer on the
   master TQ, kind of analogous to the EWInitiator?  Or do we just
   want the ITCs themselves on the master queue, and they each poll
   just their own channel on timeout.

:433]
[434:

Thu Apr 16 05:51:16 2020 ..we've put the individual ITCs onto the
master TQ..

:434]
[435:

Thu Apr 16 07:10:24 2020 After morning walk.

:435]
[436:

Thu Apr 16 07:10:42 2020 So, I can connect a loopback cable but nobody
speaks, as yet, so nobody hears..  I had sort of thought that maybe
itcmfm sent up some kind pseudopacket when the connection opened but I
guess I never implemented that.

So how does userspace know a compatible-physics connection is
  open?[437:

Fri Apr 17 00:38:04 2020 Yikes, lost a lot of time Thursday.

:437]

:436]
[438:

Fri Apr 17 00:58:46 2020 So what should a 'synthetic HELO pkt' look
like?  I guess the obvious idea is to send a packet with the ITC bit
set in byte[1], since those are normally filtered out at LKM level.

So, make the packet something like this maybe:

 byte[0]: 0xa0|

[439: Fri Apr 17 01:11:56 2020 ..so wait a second.  Now that we've
split the traffic -- bulk vs flash vs mfm -- into separate devices,
and also split up the mfm traffic across the ITCs, is there any reason
to include packet byte[0] in what we deliver to user space?[440:

Fri Apr 17 01:27:09 2020 Maybe for flash traffic to know its source,
to avoid sending it back that way?  But flash traffic has some kind of
wrapcounter index or something anyway to limit repropagation.

[441:

Fri Apr 17 01:46:06 2020 But we've gone down this road before and I
think once again even if it's true it's not worth doing right now.
Just ignore byte[0] in userspace if it doesn't matter

:441]

:440]

:439]

:438]
[442:

Fri Apr 17 01:47:18 2020 So again damnit again.  How about sending a
STD+LOC packet up to userspace?  STD+LOC from the PRUs is all handled
by LKM; none of them currently get to userspace.  How about like:

byte[0]: 0xc01

understood in userspace as like:

   STD LCL RSV TP4 TP3 TP2 TP1 TP0
  +---+---+---+---+---+---+---+---+
  | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 1 |
  +---+---+---+---+---+---+---+---+

with TP4..0 meaning "Userspace local packet type 1", meaning
"Compatible ITC open".

Who knows.  But call it good enough to go for now.[443:

Fri Apr 17 02:50:48 2020 Fog it let's also say type 2 means
"Incompatible ITC blocked", and send it to userspace on itcmfm
entering SN_INCOMPATIBLE.[444:

Fri Apr 17 07:36:05 2020 Well, it seems to be time to try this
modified itcmfm.  For which we need to reboot after

    root@beaglebone:~# uptime
     07:37:32 up 5 days, 18:07,  2 users,  load average: 2.04, 2.12, 2.11
    root@beaglebone:~#

yow.

So maybe we should checkpoint commit some stuff here, first?[445:

Fri Apr 17 07:50:45 2020 Yeah, doing that.

:445]

:444]

:443]

:442]
[446:

Fri Apr 17 08:51:53 2020 Well, everything seems to be committed and
pushed.

RISKY BITS OFF.

:446]
[447:

Fri Apr 17 08:59:01 2020 Well we seem to be back up.  Let's get gdb
back up and see what happens when we make a loopback connection.

:447]
[448:

Fri Apr 17 09:24:00 2020 Hmm, with a loopback cable between our ET and
our WT, our first 'synthetic HELO' packet reached userspace.. and it
claimed INCOMPATIBLE!  And with this:

    root@beaglebone:~# echo ff0 > /sys/class/itc_pkt/debug

we see this:

    Apr 17 09:23:49 beaglebone kernel: [ 1615.702706] kitcTimeoutThreadRunner: [SW] to WAITPS
    Apr 17 09:23:51 beaglebone kernel: [ 1617.590897] kitcTimeoutThreadRunner: [ET] to INCOMPATIBLE
    Apr 17 09:23:51 beaglebone kernel: [ 1617.596616] sendKITCPacket pkt=INCOMPATIBLE len=2 (src=ET)
    Apr 17 09:23:51 beaglebone kernel: [ 1617.602284] recvKITCPacket rc INCOMPATIBLE len=2 (us=[WT]INCOMPATIBLE)
    Apr 17 09:23:53 beaglebone kernel: [ 1619.287052] kitcTimeoutThreadRunner: [NW] to WAITPS
    Apr 17 09:23:55 beaglebone kernel: [ 1621.303102] kitcTimeoutThreadRunner: [NE] to WAITPS
    Apr 17 09:23:59 beaglebone kernel: [ 1625.431314] kitcTimeoutThreadRunner: [SE] to WAITPS
    Apr 17 09:24:00 beaglebone kernel: [ 1625.879568] kitcTimeoutThreadRunner: [SW] to WAITPS
    Apr 17 09:24:02 beaglebone kernel: [ 1628.503549] kitcTimeoutThreadRunner: [ET] to INCOMPATIBLE
    Apr 17 09:24:02 beaglebone kernel: [ 1628.514136] sendKITCPacket pkt=INCOMPATIBLE len=2 (src=ET)
    Apr 17 09:24:02 beaglebone kernel: [ 1628.519825] recvKITCPacket rc INCOMPATIBLE len=2 (us=[WT]INCOMPATIBLE)

so perhaps we should understand why we seem to be incompatible with
ourselves.  So we're back to kernel debugging here for a bit.[449:

Fri Apr 17 09:57:37 2020 Well, not sure what's going on yet, but from
this:

    Apr 17 09:57:00 beaglebone kernel: [ 3606.619954] recvKITCPacket rc INCOMPATIBLE len=2 (us=[WT]INCOMPATIBLE)
    Apr 17 09:57:00 beaglebone kernel: [ 3606.629217] sendKITCPacket pkt=INCOMPATIBLE len=2 (src=ET)

OK we were incompatible for whatever reason.

    Apr 17 09:57:00 beaglebone kernel: [ 3606.636299] >pru: a2 ca                                            ..
    Apr 17 09:57:01 beaglebone kernel: [ 3607.290155] mfzid set; len=5, token=158, MFM pid is 2653

But then userspace set a new mfzid.  That should trigger a KITC reset.

    Apr 17 09:57:07 beaglebone kernel: [ 3613.152766] kitcTimeoutThreadRunner: [SE] to WAITPS
    Apr 17 09:57:09 beaglebone kernel: [ 3615.104735] kitcTimeoutThreadRunner: [NE] to WAITPS
    Apr 17 09:57:11 beaglebone kernel: [ 3617.249030] kitcTimeoutThreadRunner: [WT] to INCOMPATIBLE
    Apr 17 09:57:11 beaglebone kernel: [ 3617.254607] Routing priority 0xa6/2 packet to itc!pru!1
    Apr 17 09:57:11 beaglebone kernel: [ 3617.266403] 0 from trysend 0xa6/2 pkt (kfln 3) via prudev itc!pru!1 mPriorityOB
    Apr 17 09:57:11 beaglebone kernel: [ 3617.273989] recvKITCPacket rc INCOMPATIBLE len=2 (us=[ET]INCOMPATIBLE)
    Apr 17 09:57:11 beaglebone kernel: [ 3617.283766] sendKITCPacket pkt=INCOMPATIBLE len=2 (src=WT)

but it doesn't appear to.

Let's look into that.[450:

Fri Apr 17 09:59:58 2020 OK, in mfzid_store, we see:

      /* Invalidate the KITCs */
      for (i = 0; i < MFM_MINORS; ++i) {
        BUG_ON(!S.mMFMDeviceState[i]);
        S.mMFMDeviceState[i]->mStale = true;
      }

      printk(KERN_INFO "mfzid set; len=%d, token=%d, MFM pid is %d\n",
             count,
             ts->mToken,
             ts->mMFMPid);

so the question is: Are the KITCs even really interrogating mStale at
all??  [451: Hmm NO HITS for mStale anywhere in itcmfm.c..  :451]

:450]

:449]

:448]
[452:

Fri Apr 17 10:01:57 2020 Review:

 - mStale is a bool in ITCMFMDeviceState.  It is false on creation.

 - The code above sets it true for all ITCs, when the mfzid is set.

 - It is set false for an ITC device (/dev/itc/mfm/ET etc) when opened

 - It is checked when each such device is read from or written to.

 - It is used nowhere else.

[453:

Fri Apr 17 10:38:50 2020 So it seems clear that setting the mfzid
should explicitly reset all the KITCs, and then we'd be past this
initial issue.[454:

Fri Apr 17 10:48:52 2020 Rebooting again for that.

RISKY BITS OFF

:454]

:453]

:452]
[455:

Fri Apr 17 11:05:54 2020 OK so geez a lot of stuff in itcmfm.c is
pretty seriously incomplete.  Thanks, Dave-from-the-past.  You're the
best.

The current issue is twofold -- first, the KITC mMFZIdUs data member
was never getting set at all: The MFZ ID gets written to tile state
only, not KITC state.  So we're ditching the mMFZIdUs data member
entirely and just fetching it out of S.mMFMTileState.mMFZId when we
need it.

And second: The mToken field, which is supposed to be used to uniquify
MFZids, isn't being sent on the wire at all.  Did we EVER document
what the KITC packet formats were really supposed to be?[456:

Fri Apr 17 11:25:05 2020 Doesn't look like we did, at least not here.
By :216: we're sending and receiving (empty) MFZIds and seemingly
feeling like the packets are complete..[457:

Fri Apr 17 11:37:40 2020 So, if we were to try to inject some
mToken-awareness, what would we need

TODO

[458: Fri Apr 17 15:01:08 2020
DONE :458] - timeout_CONFIG_KITC puts mMFZId on the wire.  Needs to put mToken
   there too.

[459:
DONE :459] - So does timeout_CHECK_KITC.  Ditto.

[460: Fri Apr 17 15:04:38 2020
DONE :460] - receive_CONFIG_KITC pulls mMFZIdThem off the wire.  Needs to pull an
   mITCState.mToken too

[461: Fri Apr 17 15:21:31 2020
DONE :461] - So does receive_CHECK_KITC.

[462: Fri Apr 17 15:26:49 2020 Added token write to
   timeoutIn_or_Compatible_KITC and token check to
   receiveIn_or_Compatible_KITC, so let's try calling this
DONE :462] - But what is compatibleMFZId() supposed to do with that?  We can't
   compare their token to ours, only theirs to theirs.  So I guess the
   point (such as it is) is that we'd be supposed to inject the token
   into (all) subsequent KITC packets, and we'd match that to
   mITCState.mToken as an extra check.

:457]

:456]


:455]
[463:

Fri Apr 17 15:32:50 2020 OK I guess time to try again.

RISKY BITS OFF.

:463]
[464:

Fri Apr 17 15:57:56 2020 Well, we're getting to SN_COMPATIBLE now, and
userspace appears to be getting the 'synthetic HELO packets'..  So it
must be time to commit and then try to move forward a bit more?[465:

Fri Apr 17 16:23:02 2020 Committed and pushed T2-12..

So.  How do we handle the compatible/incompatible packet at the T2ITC
level?  We should capture it as indicating that direction is/isn't
open for business and locking.  Where is that fact recorded?

:465]

:464]
[466:

Fri Apr 17 17:16:46 2020 OK now we're seeing this:

    214: MSG: MenuAction o424 '' to panel ''
    215: WRN: Big MSPAST 3599
    216: MSG: ITC/WT status COMPATIBLE
    217: WRN: resetAllCircuits XXX IMPLEMENT ME

on startup, which seems all as expected.  Except.. we don't see ITC/ET
reporting anything.

[467:

Fri Apr 17 18:00:28 2020 Which appears to be the obvious thing: We
were only sending to userspace from the one side of the protocol.
Ready to try again.

RISKY BITS OFF.

:467]
:466]
[468:

Sat Apr 18 01:15:19 2020 OK, now getting:

    215: WRN: Big MSPAST 3354
    216: MSG: ITC/ET status COMPATIBLE
    217: WRN: resetAllCircuits XXX IMPLEMENT ME
    218: MSG: ITC/WT status COMPATIBLE
    219: WRN: resetAllCircuits XXX IMPLEMENT ME
    220: MSG: Pushing fake isDown 0 pressed 1 val 1.000000

Can we clear any old to-do?

[469:

Sat Apr 18 01:16:54 2020 Well, everything back to :430: is already
checked off, so..

Q: Where are we in the T2EventWindow state machine?
A: We have ALL_EW_STATES_MACRO() in T2EventWindow.h, currently full of
   all unused states.

Q: Is there a state machine framework to update those states?
A: T2Tile::maybeInitiateEW() allocates them and puts them on the
   master timequeue.  Then T2EventWindow::onTimeout gets called, and
   it should update the state.  But it does randomly releases or
   requeues itself instead, and the state remains IDLE forever.

Q: What should onTimeout do instead?
A: It should do something analogous to what itcmfm.c does with its
   state machine, down in itc_pkt LKM.

Q: And what, pray tell, does itcmfm.c do with ITS state machine?
A: Well, each state offers two functions:
   - timeout(), called when we time out in that state, and
   - receive(), called when we get a packet while in that state
   - Before calling timeout(), the framework sets up a PacketHandler
     for the state to write to, on the assumption that's (part of)
     what the timeout handler will want to do.
   - (And on receive(), naturally, the framework sets up a
     PacketHandler for the state to read from.)

[470: Sat Apr 18 02:15:41 2020 This Q&A style is helpful!  Keep it
going!

Q: And do we just want to do the same thing here for T2EventWindow?
A: Well, it's a little more complicated.

Q: What makes it more complicated?
A: Well, for one thing, because we also have this 'ITC Circuits'
   concept that's supposed to mediate T2EventWindow packet routing.

Q: But hasn't any necessary 'routing' already been done, by the time a
   packet arrives at a T2EventWindow?
A: Yes.. But.. the setup of a T2EventWindow.. and how to send a packet
   from a state..

Q: You sound confused.  Perhaps you could work out an example?  Say,
   just starting with an EW getting initiated on the active side?
A: Well, I'm still really not sure how to code that up.

Q: Could you maybe write a fantasy take on it right here right now?
A: Maaaaaaybe.  I'll try

[471:

Sat Apr 18 02:36:09 2020

The fantasy scene opens in T2Tile::maybeInitiateEW(), which was called
by the 'EWInitiator' -- which already exists.  maybeInitiateEW() goes
to tryAcquireEW, which already exists too, and, we shall assume,
succeeds.

Now, when tryAcquireEW returns, all the involved T2Tile::mSiteOwners
have been set to point to the acquired EW, and the EW itself has been
initialized via T2EventWindow::assignCenter, which sets up the EW's
mCenter and mRadius.[475: And sets its state to AINIT.  And then puts
it on the master TQ with a timeout of 0.  And the AINIT timeout()
routine should take things from there.  In particular, it will know
that AINIT timeout is not a failure but a beginning.

So now, AINIT->timeout needs to determine if the event is hidden or
visible.  It does its geometry work and comes up with a possibly empty
set of ITCs that must coordinate for this event to happen
consistently.  That must involve, I guess, allocating circuits in the
ITCs that are in COMPATIBLE state.


:475]

[Q: Who sets up the T2EventWindow::mStateNum, that tells us what state
    we're in?
 A: Umm, it gets set up by the T2EventWindow ctor.
 Q: But aren't these constructed EWs used over and over?
 A: Umm, yeah.  Somebody needs to reset that statenum on acquisition.
    Good catch, Q.[472: Sat Apr 18 02:57:01 2020 And perhaps that's
    where the active/passive EW distinction should be
    established.[473:

Sat Apr 18 05:08:26 2020 OK so now T2Tile::tryAcquireEW takes a 'bool
forActive' argument, and all the phony EWs on the TQ are now in state
AINIT instead of IDLE.[474:

Sat Apr 18 05:37:14 2020 So, back to the fantasy story.

:474]

:473]  :472]]


:471]

:470]

:469]
:468]
[476:

Sat Apr 18 06:39:26 2020 OK, so we need to make a struct T2EW_OPS and
XX-generate instances for each state.  I don't think we're doing that
yet? [477:

Sat Apr 18 06:42:31 2020 OK but we are in C++ here so it would be a
base class with default implementations, plus XX-generated per-state
subclasses.. [478:

Sat Apr 18 06:46:55 2020 Wait. Then we have a singleton for each
subclass?  And we have an array of ptrs to those singletons to map
from statenumber to handlers?

I guess so.  Then the timeout() and receive() methods need to get
passed a T2EW as well as the PacketHandler, pretty exactly analogous
to itcmfm.[479:

Sat Apr 18 08:29:08 2020 OK, so we've beaten the major bugs out of the
XX-ing for the T2EW state machine framework, and now we need to start
defining timeout()s and receive()s..  ..at least to DIE_UNIMPLEMENTED.
[480:

Sat Apr 18 09:03:53 2020 Maybe we should include a 'stub out' arg that
would do that for us.  It would make things easier if we're expecting
to be changing state names and counts and rearranging things for a
while..

:480]

:479]

 :478]

:477]

:476]
[481:

Sat Apr 18 15:53:08 2020 OK so dinner's in the oven, and our
AINIT::timeout method is legitimately getting called.  So I think
there's several things

TODO

[485: Sun Apr 19 03:29:04 2020 Coverted it to PacketBuffer
DONE :485] - Flesh out our userspace PacketHandler

 - Flesh out some initial packet formats

:481][482:

Sun Apr 19 02:15:38 2020 Is there any reason NOT to use
src/core/include/Packet.h?  ..We'll find out..[483:

Sun Apr 19 02:20:57 2020 And the first bit of friction we find is
there's no obvious way to call ::read(fd,buf,len) on a PacketBuffer?
There has to be.  ..Doh of course there's Read(fd,maxlen), okay..
[484:

Sun Apr 19 02:25:55 2020 Can we just hand around a PacketBuffer and
ditch PacketHandler entirely?  Now's the time to give it a try.

:484]

:483]

:482]
[486:

Sun Apr 19 03:32:23 2020 OK it's all PacketBuffer now.  I note that
src/core/include/Packet.h has PacketType definitions like UPDATE_BEGIN
= 'b' and so forth -- do we want to just use them?

Let's take a couple minutes here and reconsider.  For starters, that
calls for s16 X and Y coords; can't we really get away with s8's?  If
we're solid on the max EW radius being 4, there's really no way a...
whups oh yeah I remember.  Even though intertile events can't be more
than a few EW radii from the tile edge, we don't have some magic
per-ITC-pair origin to reference things to.  We send event centers in
tile coordinates, and with variable-sized tiles in mfms, you could
easily have a tile coordinate that exceeds s8.

[487:

Sun Apr 19 03:52:28 2020 But what if we did establish per-ITC-pair
origins?  Like:

 ET: ITC origin is at (W-1,H/2)
 SE: ITC origin is at (3W/4,H-1)
 SW: ITC origin is at (1W/4,H-1)
 WT: ITC origin is at (0,H/2)
 NW: ITC origin is at (1W/4,0)
 NE: ITC origin is at (3W/4,0)

That's probably yet another over-optimization-of-the-wrong-thing --
saving a few bytes on the wire -- when by far most of the time is lost
in per-packet overheads not per-byte.

But it does make we wonder about a userspace response to HELO COMPAT.
Shouldn't we send some establishing hello packet of our own?  Giving
our grid origin and dir8, for example?  Allowing each side to develop
the SPoint offset for mapping coords moving through the ITC?

And the real anxiety point is about establishing sequence numbers at
the userspace ITC pair level.  The rule needs to be that once an ITC
opens, nothing visible to the far end can be changed without an
in-sequence packet notification going out about it.

Now, in mfms we ended up not sending a giant synchronizing blast when
a channel opened, right?  Yeah.. because.. the 'channel' never really
opened.  It was always open.

Maybe we should send a big fart full visible-sites dump when a channel
opens?  Maybe that could be something the ITCs do on their own,
independent of an EW?  Independent of, and before, any EWs are allowed
to initiate in the area?

But that's a pretty lot of data, way more than one packet's worth.

:487]

:486]
[488:

Sun Apr 19 05:07:32 2020 OK, so here's the thing right now:

 - We have a whole 'circuit' level in T2ITC that's currently totally
   unused.

 - We need to understand that better.  For example, an initial cache
   synchronization would be naturally a T2ITC function, not an T2EW
   one.

 - But that's going to take a bunch of thinking and a bunch of new
   design.

 - And it's April 19th.  I can't tear into that now.

 - Checkpoint committing all this and switching to wall of science.

 - When we come back, think about stuff like:
   = T2ITC should have the power to put a 'hold' on all the sites
     visible through it
   = A 'hold' means that any in-progress events involving those sites
     can continue, but no new events involving them can be initiated.
     Those sites are 'held by the ITC'.
   = The ITC gets awoken when sites it holds are released by an EW.
   = Actually perhaps an ITC should hold an EWSet of all the EWs that
     own sites the ITC cares about.  Then the ITC-with-a-hold could be
     awoken only when that set is empty.
   = In any case, when the holding ITC's sites are quiescent, the
     holding ITC ships the whole damn visible subspace, using however
     many packets-full it takes.
   = When the visible subspace dump has been received, the receiving
     ITC switches to state 'sync' or something, and sequence numbers
     are then required to make any changes to visible space.

[489:

Sun Apr 19 06:48:10 2020 Well, not clear that that's really the
answer, vs the incremental approach used in mfms, but we'll see.

Committing.

:489]

:488]
[490:

Fri May  8 00:08:24 2020 OK, so, at very long last, we are back.

Reviewing notes.[491:

Fri May  8 00:10:31 2020 OK possible issues:

 - Should we design/have a userspace HELO ITC packet to set up
   intertile details?

 - Should(n't) such a HELO ITC include the 'ITC origin and dir8'?

 - AAaaand should(n't) it establish the ITC sequence numbers to be
   used for all future marking of the change channel between the ITC
   pair?

 - And should it or should it not provide a complete cache dump at the
   time of opening?  But how can it?  It can't do it atomically
   because it's too much for one packet, so it would have to be a
   bunch of packets.  And wouldn't all those sites need to be locked,
   at the event level, so they couldn't change before we got a full
   read on them and sequenced.

[492:

Fri May  8 01:00:41 2020 So we're leaning towards just marking all the
sites, somehow as 'content not yet known by the far side', and dealing
with it incrementally?

Let's review what CURRENTLY ACTUALLY happens in userspace [494:

Fri May  8 02:28:26 2020 What currently actually happens, overall, is
we start up itcSpike12, with like

(gdb) r -z ID -w wconfig.txt

and we quickly get to

    216: WRN: Big MSPAST 3206
    217: ERR: src/T2EventWindow.cpp:111: (timeout) XXX IMPLEMENT ME

which is coming from

      //// AINIT: CUSTOM STATE HANDLERS
      void T2EWStateOps_AINIT::timeout(T2EventWindow & ew, PacketBuffer & pb) {
        DIE_UNIMPLEMENTED();
      }

which is the timeout method for an active side event window in its
initial state.  And I guess it's right that that is happening -- or I
mean, it's not like we can't have active event windows without
connected ITCs.

So we'll need to deal with both.[495:

Fri May  8 03:01:27 2020 I think it's time for second sleep here.  But
then to consider the startup sequence for itcs: Design packet(s) to
send to get an ITC pair set up?

:495]

:494]

:492]

:491]

:490]
[493:

Fri May  8 02:27:36 2020 OK had a spontaneous chat with a nice person
Tim Bansemer of dgov.foundation.

:493]
[496:

Fri May  8 09:43:10 2020 So I guess we need a way to tie off the AINIT
FAIL just so it won't get in the way while we look at ITC HELO traffic
design.

I guess just stay in AINIT and push the timeout?  That should be
easy, right?[497:

Fri May  8 10:51:18 2020 OK so now all 32 EWs are allocated as being
active, and then sitting in AINIT and timing out every 10 seconds.
And we can push the button and show the timequeue and see them rising
and falling on it.

So.

What happens, now, when we connect a loopback?[498:

Fri May  8 11:00:12 2020 This is what happens now:

    219: MSG: ITC/WT status COMPATIBLE
    220: WRN: resetAllCircuits XXX IMPLEMENT ME
    221: MSG: ITC/ET status COMPATIBLE
    222: WRN: resetAllCircuits XXX IMPLEMENT ME

so how did 'resetAllCircuits' get called?[499:

Fri May  8 11:11:04 2020 It got called by T2ITC::tryHandlePacket,
after it received a COMPATIBLE packet from LKM.[500:

Fri May  8 11:22:14 2020 And that packet, in its entirety, was
generated by LKM itcmfm.c doing:

      byte = 0xc0 | (compatible ? 1 : 2);
      kfifo_in(&ipb->mFIFO, &byte, 1);

Now, exactly why does 0xc in the high nybble of the header make sense?
According to T2-Packet-Header-Formats-13.pdf, that means it has the
standard (STND) and local (LOCL) bits set, and local standard packets
are only defined as moving between PRU and LKM, not LKM and userspace.

Now we could declare that LOCL means any single hop between PRU, LKM,
and userspace, and then use STND+LOCL for different things on each
hop.  (I suppose they could even go PRU-PRU externally, if the PRUs
were not completely transparent, and happened to have something to say
specifically to each other.  But for sure not now.)

[501:

Fri May  8 11:44:47 2020 So do we do that?  Do we start exploding
the local standard documentation to be on a per-link basis?

I guess let's pretend we've already done that, for now, and just keep
the info, such as it is, here.

So, when userspace -- which we'll call 't2mfm', perhaps? -- gets
COMPAT (packet 0xc1) from LKM, it should:

 - Reset itself internally (whatever that means)

 - Send a HELO T2MFM packet containing:
   = Its tile size
   = Its nominal position in tile coordinates
   = Its dir8 orientation
   = A random nonce

 - And put itself in some state to remember that it did that, and to
   wait for HELO T2MFM from the other side.

And when a HELO T2MFM arrives, t2mfm should:

 - Capture the info contained

 - Determine if it is the winner based on the nonce comparisons.

[502:

Fri May  8 12:16:44 2020 So it does seem like we have to ship our
sites to populate their cache (and vv).  I don't see how we can be
that lazy about it either, because if we don't know what's in some
shared site how can we give out an EW lock for it?

But consider corners: Couldn't we have a lock-involving event in
progress at the time that the adjacent ITC receives HELO COMPAT?

                 +----NE----+   Like, NE is open, ET is
                 |    .  .  |   closed, and an event is
   +TILE---------|----+--+..|   in progress at *, holding
   |             |    . *|  |   a NE precision lock.  The
   |             +----------+   event in progress at * saw
   |                  .  |  .   the sites to its east as
   |                  .  |  E   not-living, and it computed
   |                  .  |  T   its transition on that basis.
   |                  .  |  .     Then, while waiting for
   |                  .  |  .   cache traffic on NE, we get
   |                  .  |  .   HELO COMPAT on ET.  Now what?
   +------------------+--+..+

[503:

Fri May  8 12:37:04 2020 Well, I guess what could happen is like:

 - ITC/ET sends its HELO T2MFM packet

 - ITC/ET also marks itself as 'opening' or something.  This blocks
   any further active EW acquisitions involving ET visible or cached
   sites.

[504:

Fri May  8 12:41:21 2020 I guess it would be smarter to have the ITC
involved in EW comings and goings even when they are closed.  That way
the ITC could know precisely what events are in progress that could
affect any of its visible sites.

The events would complete atomically if all involved ITCs were closed,
but it would take some computing before that would be evident, so we'd
go ahead and register the ew on the ITC somehow, and then release it
again as the event finishes.

So 'registering an ew with an ITC' returns 'lock attempt in progress'
or 'no lock needed' or 'no circuits available' and proceeds from there
(or unwinds if 'no circuits available').  But even if it's 'no lock
needed', the ew has to come back to unregister with the ITC later.
[505:

Fri May  8 14:00:46 2020 So let's say we have that, and each ITC knows
all the active EWs that could affect any sites visible through that
ITC.  Then how does it go?

 - ITC/ET sends its HELO T2MFM packet

 - ITC/ET also marks itself as 'opening' or something.  This blocks
   any further active EW acquisitions involving ET visible or cached
   sites.

 - ITC/ET checks if any EWs are in progress.  If so, it sleeps for a
   time sufficient to throw a fit if the time expires.

 - When an EW deregisters from an ITC, among whatever else it does,
   the ITC also bumps itself.

 - ITC/ET runs and discovers no EWs are in progress.  It sends an
   initial sequence number packet, then starts sending a full cache
   blast, packet by packet.  If LKM runs out of buffer space, ITC/ET
   blocks for a little while, remembering where it is.

 - As this is happening ITC/ET is also receiving the corresponding
   packets from the far end.  Those it is stashing away in appropriate
   places.

 - Eventually ITC/ET has sent a full cache blast.  It sends a final
   'ready to rumble' packet and goes to sleep.

 - When it receives 'ready to rumble' from the far side, it marks
   itself as 'open for events' and goes back to sleep.  As of this
   point, when an EW acquisition attempt arrives, it will trigger an
   intertile locking event via circuit allocation.  ITC/ET will 'ring'
   the far side with the location and radius desired, plus channel
   information, and return 'lock attempt in progress' to the EW, which
   then sleeps.

:505]

:504]

:503]

:502]

:501]

:500]

:499]

:498]

:497]

:496]
[506:

Fri May  8 15:01:12 2020 So at least we got to a semi-plausible story
where the circuits get involved.  What state do the circuits currently
have? [507:

Fri May  8 15:02:29 2020 Hmm it appears they have a circuit number and
an ew slot number and that's it.

We're thinking they'd also want the ew center and radius, and some
kind of state number, and some kind of far side circuit number as
well?[508:

Fri May  8 15:08:29 2020 No, we don't need far side circuit numbers
because we're assigning them 1-1 in mCircuits[2][CIRCUIT_COUNT].  So
(active) circuit #3 here == (passive) circuit #3 there and there's no
negotiating required.

We have T2ITC::tryAllocateActiveCircuit nicely randomizing circuit
selection.  But at the moment it's just handing the allocated
CircuitNum back, it's not capturing anything about who wants to use
it.[509:

Fri May  8 15:11:56 2020 And at present nobody is calling it anyway.

Almost time for Lance chat, but, do we have any idea, now, where we
  might[510:

Sat May  9 00:14:39 2020 ..intervene to call
T2ITC::tryAllocateActiveCircuit?

So we have two flows to be aware of:

1. EW allocation and freeing 'from above'

2. Circuit allocation and freeing 'from below' (or nghbr really)

In particular, the two flows have to interact somewhere(s)!

Flow 1:

EWInitiator::onTimeout ->
  T2Tile::maybeInitiateEW ->
    T2Tile::tryAcquireEW ->
      T2Tile::allocEW
      <region check> [INTERVENE HERE? FLOW TO ITC?]
      <hog region>
      T2EventWindow::assignCenter


Flow 2:
T2ITC::onTimeout ->
  T2ITC::pollPackets ->
    T2ITC::tryHandlePacket ->
      T2ITC::resetAllCircuits
      ??

[511:

Sat May  9 00:52:21 2020 So it seems _somebody_ has to bring the ITCs
into Flow 1.  Right now we're check if mSiteOwners[x][y] == 0 for all
desired sites -- could we make the ITC be the owner there during ITC
opening, for example?[512:

Sat May  9 00:54:34 2020 Not at the moment since the declaration is:

    T2EventWindow * mSiteOwners[T2TILE_WIDTH][T2TILE_HEIGHT];

but we could generalize that if we wanted to.  What would an
mSiteOwner API want to provide?
 - Name
 - description/purpose of ownership

Nothing else??  The whole point is to really just to make mSiteOwners
be non-empty?  Well that doesn't answer the '(maybe) needs a lock'
question.  We'd need a second pointer or other mechanism for that.

[513:

Sat May  9 01:05:04 2020 So let's deal with that now.  How shall we
answer the question: Who do I need to ask about getting a lock for
this site?  Based on the recent discussion we think we need to make
that check whether or not any particular ITC is in state open or
whatever, so the ITC can know about if a Flow 2 opening sequence
begins.

So let's try being dumb.  How dumb?  We could poll all six ITCs with
every site number, for example.  Or we could have

 T2ITC * mSiteITCs[T2TILE_WIDTH][T2TILE_HEIGHT]

and set up those pointers during construction.

Ah but no, that won't do, because corner sites can require two locks.
So maybe polling isn't so so dumb?  We could split the difference and
have like

 u8 mInterestedITCs[T2TILE_WIDTH][T2TILE_HEIGHT]

with a six bit ITC map in each u8.  If the thing is zero that site
requires no ITC interactions.  Or we could have the u8 be two nybbles
containing up to two (ITCnums+1), so we could index for them rather
than scanning all six bits.  Or we could throw compactness to the
winds and have like

 s8 mInterestedITCs[T2TILE_WIDTH][T2TILE_HEIGHT][2]

where the [x][y][0] == n if any ITC#n cares about it, and < 0 if
nobody does; same for [1] == m.

Maybe do that?  And what do we ask of those ITCs?  If there are any
circuits necessary but not available?   Something like

  /** return false if lock needed but no circuit available */
  bool T2ITC::isLockable(SPoint tilesite);

which we call during the 'region check' loop.
[514:

Sat May  9 01:45:04 2020 OK warning here: The existing tryAcquireEW
loops are not taking any cache boundary into consideration.  They'll
grab sites all the way to [TILE_WIDTH-1][TILE_HEIGHT-1] no problem --
or down to [0][0] for that matter.

And we think that's wrong.  We should never use the cache sites
_except_ once an ITC comes up and says so.

That affects selecting the ew center also.  We have to start getting
serious about all that coord and radius and cache/visible/hidden crap
here![515:

Sat May  9 01:48:15 2020 Hmm, it appears that T2Tile::maybeInitiateEW
actually is avoiding the caches on center selection:

    UPoint ctr = UPoint(getRandom(), T2TILE_OWNED_WIDTH, T2TILE_OWNED_HEIGHT) + UPoint(CACHE_LINES,CACHE_LINES);

so things could be worse, I guess.

[516:

Sat May  9 02:26:12 2020 So if we did mInterestedITCs[][][2] we could
have

  bool T2ITC::isLockable(SPoint tilesite);

return false for cache sites when the ITC isn't open.. but no, that
would blow the event, whereas we want to let the event happen but have
those sites end up not live.

Worth considering a separate T2ITC::isLive(SPoint)?  If it's not live
keep going, if it is live ask if it's lockable?  We want the ew to not
even temporarily record writes to non-live sites, so that one could
detect site liveness (while avoiding ew.isLive for some mysterious
reason), by doing like

  Atom tmp = ew[sn];
  ew[sn] = SomethingNonEmpty.instanceof;
  Bool dead = ew[sn] is Empty;
  if (!dead) ew[sn] = tmp;

..If one wanted to.

..Why are we talking about this?

:516]

:515]

:514]

:513]


:512]

:511]

:510]

:509]

:508]



:507]

:506]
[517:

Sat May  9 02:37:47 2020 Modified Flow 1

EWInitiator::onTimeout ->
  T2Tile::maybeInitiateEW ->
    T2Tile::tryAcquireEW ->
      T2Tile::allocEW or blown0
      T2EventWindow::assignCenter
      for each site in region
        mSiteOwner[site] == 0 or blown1
        assume liveflag is true
        for each ITC interested in site
          ask itc if site is live (clear liveflag if it says no)
          if yes check if already got circuit for that ITC
              if not, allocate ITC circuit or blown2
        if !liveflag mark site dead and continue
      // Here we have circuits for all involved ITCs
      <hog region: which also copies live atoms to ew>
      if any ITCs involved
        register ew with ITC (triggering lock request on circuit)
        set ew state to AWLOCKS
        reschedule long
        done
      // else
      set ew state to ABEHAVE
      reschedule now
      done
    blown2: deallocate any allocated circuits
    blown1: deallocate ew
    blown0: done

[518:

Sat May  9 12:11:48 2020 Well maybe.  But then state AINIT seems
pointless.  It seems like it would be 'more uniform' if most of that
code was in the AINIT timeout.  Let's push that way for now:

EWInitiator::onTimeout ->
  if not initiating events
    reschedule long
    done
  T2Tile::maybeInitiateEW ->
    T2Tile::tryAcquireEW ->
      T2Tile::allocEW or done
      exam
      T2EventWindow::assignCenter
      set ew state to AINIT
      reschedule now
      done

EW::AINIT::onTimeout ->
  for each site in region
    mSiteOwner[site] == 0 or blown1
    assume liveflag is true
    for each ITC interested in site
      ask itc if site is live (clear liveflag if it says no)
      if yes check if already got circuit for that ITC
          if not, allocate ITC circuit or blown2
    if !liveflag mark site dead and continue
  // Here we have circuits for all involved ITCs
  <hog region: which also copies live atoms to ew>
  if any ITCs involved
    register ew with ITC (triggering lock request on circuit)
    set ew state to AWLOCKS
    reschedule long
    done
  // else
  set ew state to ABEHAVE
  reschedule now
  done
  blown2: deallocate any allocated circuits
  blown1: deallocate ew
  blown0: done


EW::ABEHAVE::onTimeout ->
  run

:518]
:517]
[519:

Sat May  9 12:33:16 2020 OK but there's an issue: If we don't hog the
sites immediately, during EWInitiator, there's nothing to stop our
center site from getting overwritten by something with a different
radius than what we claimed when we allocated the ew.  So I think we
do need to do all that in EWInitiator::onTimeout, and we should just
pretty it up with helper functions.  So AINIT probably goes away
entirely.

Try again.[520:

Sat May  9 12:36:05 2020 Remodified Flow 1:

void EWInitiator::onTimeout ->
  if not initiating events
    reschedule long
    done
  if T2Tile::maybeInitiateEW != 0
    reschedule now
  else
    reschedule short
  done

bool T2Tile::maybeInitiateEW ->
  for i from 0 to maxInitiateTries
    pick non-cache center C
    if ((radius = considerSiteForEW(c)) > 0) break;
  if radius == 0 return false
  return T2Tile::tryAcquireEW(C,radius)

Unsigned T2Tile::considerSiteForEW(c) ->
  if mSiteOwners[C] != 0 return 0
  radius = ew[C].getRadius()
  if radius == 0  // generally only Empty but strict data could declare?
    increment ew[C].eventCount
    return 0;
  return radius

bool T2Tile::tryAcquireEW(center,radius) ->
  if T2Tile::allocEW
    if ew.tryInitiateEvent(center,radius)
      return true
    T2Tile::freeEW
  return false

bool T2EventWindow::tryInitiateEvent(center,radius) ->
  T2EventWindow::assignCenter
  if !checkSiteAvailability return false
  if !checkCircuitAvailability return false
  takeOwnershipOfRegion
  if registerWithITCs
    set ew state to AWLOCKS
    reschedule long
  else
    set ew state to ABEHAVE
    reschedule now
  return true

[521:

Sat May  9 13:24:33 2020 We have to go to code.  It's foggen Saturday
afternoon already.

:521]
:520]

:519]
[522:

Sat May  9 23:40:39 2020 Looks like first go-to-code attempt is about
to build clean.  Not even sure how much behavior we've actually
written yet.  Still in active side EW initiation.[523:

Sat May  9 23:45:11 2020 Build clean.  Let's watch it die.[524:

Sat May  9 23:51:44 2020 Well it's not dying (yet).  It's now
picking sites, detecting that they're empty, giving itself credit for
an instant 'empty event performed', doing that 10 times and then
giving up, and then doing a ~5ms 'short' wait because it didn't
actually find an EW to launch.  [525:

Sat May  9 23:54:12 2020 So it's not putting that many events up on
the board, because of the ~5ms wait, but then, it's only eating about
17% of the machine according to top.[526:

Sat May  9 23:55:48 2020 Soooooo, it looks like we need some kind of
non-empty atom to test further, don't we?[527:

Sat May  9 23:59:51 2020 Aaaaaad I guess we're totally going to have
to hack that for now, because the 'correct' way to do that is somehow
unpack the -z argument and find the libcue.so inside the MFZ
file.. and we're certainly not going to start into that now.

So, could we add another command line argument to specify a detached
libcue.so, and try to load that?  That's still a LOT less hacked than
I was expecting, vs something like #define DREG_ATOM_TYPE 1 and so
on..  But if we could suck in a _little_ more of the existing codebase
without super pain?  Let's take a quick look.  Start with a completely
hardcoded libcue.so path to somewhere.
[528:

Sun May 10 00:39:33 2020 Where is a built-for T2 .mfz file anyway?
This tile doesn't appear to have ulam on it.

Let's just go with #define DREG_ATOM_TYPE 1 total hackage.  I haven't
given up on actually seeing events here..[529:

Sun May 10 00:53:15 2020 OK, well, step by step.  We made a phony DReg
and stuck it in the middle of the grid.  And now we blow up in an
unimplemented failure.  Where is that failure?  Deep in the guts of
fully-pipelined luxury space event windows?

No.

It fails in T2GridPanel::paintSite, which, currently, only knows how
to paint empty atoms.[530:

Sun May 10 00:57:25 2020 Actually, to be more precise, it doesn't know
how to paint _anything_.  But that happens to be the correct behavior
for Empty.

So we'll hack the color but figure out how to do the positioning now.

:530]

:529]

:528]
:527]

:526]

:525]

:524]

:523]

:522]
[531:

Sun May 10 01:02:07 2020 Okaaay, so we're talking 60x40 sites total,
but there's a four site cache all the way around, that we're not going
to draw (normally) that makes it 52x32 sites total.

Or we could try bumping up to 68x48 total and presenting 60x40 live
per tile.  Let's try that, and revisit once everything is dog-slow and
we're desperate to buy some mAER.[532:

Sun May 10 01:05:05 2020 OK, 68x48 total, owned size 60x40.

According to wconfig.txt, our grid panel is 462x308, giving us a
square aspect ratio of 7.7 pixels per site.

Well I like the square part.

The problem is, although our display is 480x320, which is a perfect 8
pixels per site, in fact we trim 12 pixels off the width and 6 pixels
off the height because they get covered up by the bezel.

If we went 7 pixels each we'd take 420x280, leaving a ton of space
around it..  Suppose we draw sites for 8x8 pixels, but space them at
'7.7 pixel' intervals, so they'll overlap slightly every so often:

0 7 15 23 30 38 46 53 61 69 77 84 92 100 107 115 123 130 138

 7 8  8  7  8  8  7  8  8  8  7  8  8   7   8   8   7   8

width: 431 438 446 454 (462)
height: 277 284 292 300 (308)

[533:

Sun May 10 01:27:22 2020 Implementing..  Note that what we should do
here is work in dits, and let the scaling come out as it comes out.

How would that come out?

462 x 308pix is 118272 x 78848dits

dits/site
  118272/60 = 1971.2
  78848/40 = 1971.2

So if we 'just' multiplied site coords by 1971 and called it dits,
we'd be pretty close.  But I still think we'd draw at 8 pix==2048dits.

[534:

Sun May 10 01:58:06 2020 OK, here we go.  Trying to allocate a 'real'
active EW for the first time in the history of the universe.[535:

Sun May 10 01:59:26 2020 OK, got one.  Now trying to initiate an
active event..[536:

Sun May 10 02:00:44 2020 Note that assignCenter is setting the EWSN,
which we're deprecating.  But downstream code will overwrite soon I
think.  [537:

Sun May 10 02:02:08 2020 And blam.  We reached INCOMPLETE_CODE in
checkSiteAvailability.

Time for more implementation.  For one thing, it appeared these
eventwindows have no site storage??
[538:

Sun May 10 02:09:44 2020 So.  What is checkSiteAvailability supposed
to do, again?  From :520:, I guess it's the mSiteOwners[] scan?

:538]
:537]

:536]

:535]

:534]

:533]

:532]

:531]
[539:

Sun May 10 02:52:10 2020 OK, got through checkSiteAvailability,
looking plausible, and now we're on to checkCircuitAvailability.

That's where we have to find out if this event needs locks, and
somehow record that information in the EW.  And with this, we're
getting to allocations that we have to be careful to unwind when we're
done with the EW.

Hmm actually I think we were planning on recording ITC involvement
during checkSiteAvailability, and then just going for circuits here
later.

So, back in checkSiteAvailability, we need to settle how we're going
to discover and record which ITCs may need to be involved in this
event.  One idea was an array of two ITC numbers or dirs or pointers
or something, and we just fill up the two slots and check the two
slots and search the two slots and so forth.[540:

Sun May 10 03:23:31 2020 Right now a Circuit has an 'mEW' in it,
meant, I think, to be an index into T2Tile::mEWs.  So that's how we
get from a Circuit to a T2EW.  Circuits are per ITC, so going back it
would really need like a T2ITC * and a circuit num.[541:

Sun May 10 03:37:54 2020 OK, so now how do we tell which T2ITCs are
interested in any given site?  2D site array of dirs?  1D array of
Rects?  Former feels fast because one-check-done for non-locking
sites.. but latter would be lot more cache-friendly.  Let's do 1D
array of coords.  Maybe not rect since 4xu8 suffices for each ITC, so
6x4 == 24 bytes suffices for the whole list.  Where a Rect is 4xu32 so
it's 6x16 == 64 for the whole list.. which is the size of a cache
line, so at most two cache lines would be needed, and then we could
use whole word ops..  Well I guess 1D of Rect is really the way to go.

We'll put it T2Tile, like everything..

:541]

:540]

:539]
[542:

Sun May 10 04:16:43 2020 OK, now we're hitting at

    13	  Rect T2ITC::getVisibleRect() {
    14	    FAIL(INCOMPLETE_CODE);
    15	  }

meaning we need the damn visible rects for each dir6.  Just brute
force it for now, I guess.[543:

Sun May 10 04:30:16 2020 Well, made up the most simple-minded whack at
rects for each ITC, basically just 2*CACHE_LINES in across the entire
edge (for ET,WT) or half-edge (for the others).  We'll see.

:543]


:542]
[544:

Sun May 10 04:39:47 2020 OK so we've watched the dir6 scanning and
we've watched addITCIfNeeded add itcs and discover they were already
there, all plausible assuming the rects don't have fencepost errors or
worse.  Which is a big assumption but we'll see.

So now we allegedly have all the information we need to do
checkCircuitAvailability.

But I think it's time for second sleep.

:544]
[545:

Sun May 10 04:53:57 2020 Actually, shouldn't the NE/NW rects, for
example, have some kind of overlap in the middle?  I don't think my
rects do, do they?

I have

    case DIR6_NW:
      return Rect(0,0,
                  T2TILE_WIDTH/2, 2*CACHE_LINES);
meaning 34x8@0,0

    case DIR6_NE:
      return Rect(T2TILE_WIDTH/2,0,
                  T2TILE_WIDTH/2, 2*CACHE_LINES);

meaning 34x8@34,0

so they don't overlap.  So doesn't that mean there are no sites that
would require both the NE and NW locks?  And isn't that wrong?

Is the problem that my width is too small?  T2TILE_WIDTH includes 8
total cache lines front and back.  Dividing it by two means only 4
cache lines are included, but shouldn't we have an extra four to span
the middle split?  [546:

Sun May 10 05:17:07 2020 I think so.[547:

Sun May 10 05:20:11 2020 So now we're saying

    case DIR6_NW:
      return Rect(0,0,
                  T2TILE_WIDTH/2+CACHE_LINES, 2*CACHE_LINES);

meaning 38x8@0,0

    case DIR6_NE:
      return Rect(T2TILE_WIDTH/2-CACHE_LINES,0,
                  T2TILE_WIDTH/2+CACHE_LINES, 2*CACHE_LINES);

meaning 38x8@30,0

so now there's an eight column overlap -- each reaches four columns
into the other.  Which I suspect makes more sense.

:547]

:546]

:545]
[548:

Sun May 10 05:23:58 2020 Sleep now.  checkCircuitAvailability after.
[549:

Sun May 10 05:27:41 2020 Opps, the site display isn't skipping the
caches..

:549]
:548]
[550:

Sun May 10 11:33:14 2020 OK, checkCircuitAvailability.  What do we
know about its job(s)?

Well, going all the way back to :517: it might be mainly:

         register ew with ITC (triggering lock request on circuit)

but we note we were also 'supposed' to be asking ITCs about marking
sites dead during checkSiteAvailability, which we're not as yet
doing.  And we don't even have any place in T2EW to store that info?
Add a quick bool array?  It's only [41] per T2EW..

:550]
[551:

Sun May 10 12:45:12 2020 OK so we took a side trip to reduce the size
of the owned grid from 60x40 down to 48x32, which is more like what I
recall we were thinking about trying to do.  T2Constants is now more
parameterized-out so we ought to be able to change it more easily
if/when we want to in the future.  (In particular, if we're doing runs
that are intended to be recorded and sped up anyway, we may well want
to go with more sites/tile and take the hit in the realtime AER.)

:551][552:

Sun May 10 12:51:54 2020 So back to liveness.  We're initting
mSitesLive[41] to all false now, so we want to mark all the live ones
during checkSiteAvailability.  The idea for liveness is our own sites
are always live, but cache sites are dead unless _all_ (? or _any_?)
involved T2ITCs says they're live?[553:

Sun May 10 12:57:02 2020 The 'liveflag' stuff earlier said assume good
unless a T2ITC says no.  If that, T2ITC::isLive() should say..  hmm,
our Rects include both cache and visible sites.  We don't have just
cache sites separately.

Also, though, T2ITC needs to be able to blow an EW entirely, during
checkSiteAvailability, if it's currently draining active events in
anticipation of starting up.  Are we supporting that yet at all?[554:

Sun May 10 13:29:20 2020 No, we're not yet.  So do we want some
three-way return from T2ITC: EW_BLOWN, SITE_LIVE, SITE_DEAD?  We could
have

:554]

:553]

:552]
[555:

Sun May 10 14:09:22 2020 OK review the rules again I'm confusing
myself.

 - A hidden site (not visible or cache) can always be used, and no
   itcs need to be consulted.  The site is live for EW purposes.

 - A visible site can be used UNLESS an ITC that can see it is in the
   process of clearing EWs prior to cache synchronization, and in that
   case itc.isVisibleUsable() will return false.  If any visible site
   CANNOT be used by this rule, then the entire EW is blown.
   Otherwise the site is live for EW purposes.

 - A cache site can be used ONLY if ALL involved ITCs say
   isCacheUsable() is true.  If a cache site CANNOT be used by this
   rule, then that site is marked dead but the EW continues.

[556:

Sun May 10 14:23:06 2020 OK that all seems plausible.  Are we
defaulting EW sites dead now, so we have to mark all the live ones?

..Yes, initializeEW makes mSitesLive[sn] all false.

:556]
:555]
[557:

Sun May 10 14:35:27 2020 OK now we're blowing up in
T2ITC::isVisibleUsable.  The implementation of that needs to consult
the T2ITC state machine state, I'd think, but that's not ia a
super-believable state, yet, is it?  Let's take a look.
[558:

Sun May 10 14:37:09 2020 T2ITC doesn't even have a state variable, let
alone any state machine structure?  Yikes, we're back to design?[559:

Sun May 10 14:40:47 2020 Looks like.  LKM has state machines for
KITCs, and we ripped off that shape for the still-developing
T2EventWindow state machine, but T2ITC seems to have squat so far.

Sooooo.  I proclaim, T2ITC states:

 - RESET   (isVisibleUsable false  isCacheUsable false)
 - INIT    (isVisibleUsable false  isCacheUsable false)
 - CLOSED  (isVisibleUsable true   isCacheUsable false)
 - CONTACT (isVisibleUsable false  isCacheUsable false)
 - CACHEXG (isVisibleUsable false  isCacheUsable false)
 - SYNCED  (isVisibleUsable true   isCacheUsable true )

maybe need:

 - CLOSING (isVisibleUsable false  isCacheUsable false)

and/or other glue states; we'll see.

:559]

:558]

:557]
[560:

Sun May 10 14:56:43 2020 Getting to be meeting time.  Tear into T2ITC
state machines after.  Clearly vizUse and cchUse will be two XX
arguments..

:560]
[561:

Sun May 10 16:39:43 2020 Post meeting.  Have about an hour here before
cooking.  T2ITC State Machines, Manifest!

:561]
[562:

Sun May 10 17:01:11 2020 Well giant copy paste from
T2EventWindow.h/cpp, ugh.  First build blowing up.[563:

Sun May 10 17:25:27 2020 OK, break for cooking.  Current status:

 - EWs fail silently when ctr is in corner.

 - EWs in hidden blow up at checkCircuitAvailability, so we can
   continue there.

But also:

 - T2ITCs have everything stubbed out, so they never advance from
   RESET->INIT->CLOSED.  Need to start fleshing out their state
   machines so that they do.

 - And finalizeEW never gets called.  Should it have by now?

:563]

:562]
[564:

Mon May 11 02:08:22 2020 OK let's get a couple solid hours here and
see how far we can get before the day intrudes.

T2ITC STATE MACHINES!  ADVANCE!

[565:

Mon May 11 02:11:06 2020 Goal 1: Blow up in RESET timeout

:565]

:564]
[566:

Mon May 11 02:13:14 2020 We'll just go from RESET to INIT on
  timeout..[567:

Mon May 11 02:13:40 2020 Except the our RESET timeout does not appear
to be getting called.[568:

Mon May 11 02:15:03 2020 OK, a slight design ah issue: We need to have
the T2ITCs coming off the master timequeue rapidly, because we have to
poll for packets.  But that means the TimeQueue timeout field is taken
up being very small to poll for packets, and we can't make it also be
long to do state timeouts for error conditions and such.

So the 'obvious' solution is for each ITC to have two entries on the
master TQ: A fast one that just polls, and a variable one that does
the 'semantic timeouts' for the state machine.

Aaand, it's embarrassing, but we could have a SINGLE entry that polls
packets for all the ITCs..  (If we randomized the polling order.)

But let's just make a T2ITCPacketPoller for each.. I don't know.[569:

Mon May 11 04:09:24 2020 Well we didn't do that.  We made one
T2ITCPacketPoller, and ported the LKM random iterator to C++, and we
have our packet poller polling all the T2ITCs in a random iterator
randomized order.

At the moment we have the packet poller running about every 10ms.
That'll be tuned once we actually have some packets to poll.

And we have an 'I/O' checkbox on the physics page where we can turn
polling on and off.

CPU% is up to ~19% now, but that's with or without I/O.  We're
compiled -g2 so can't tell much.
[570:

Mon May 11 04:14:25 2020 Soooo, pop pop pop, that means that
T2ITC::onTimeout is now available for state machine timeouts. GO GO
GO.[571:

Mon May 11 04:16:35 2020 OK!  Now we're dying in

    257	  void T2ITCStateOps_RESET::timeout(T2ITC & itc, PacketBuffer & pb, TimeQueue& tq) {
    258	    DIE_UNIMPLEMENTED();
    259	  }

T2ITC CUSTOM STATE HANDLERS, MANIFEST!

:571]

:570]

:569]

:568]

:567]

:566]
[572:

Mon May 11 04:17:48 2020 And what does timeout in ITC reset mean?  Who
knows, move on to INIT I guess.[573:

Mon May 11 04:32:25 2020 And I have INIT doing nothing now, but really
it should be trying to send config packet to the neighbor, right?  Do
we have the ITCs flushing packets when they first open the channel?
We should, right?

:573]

:572]
[574:

Mon May 11 05:03:24 2020 OK, we're up to dying in
T2ITCStateOps_CLOSED.  I guess we should have a long timeout and then
send a little are you there god packet.  A packet!  Something to send!
[575:

Mon May 11 05:09:34 2020 Sooo, what exactly is the format of these
'low level' T2ITC packets, that we're sending long before cache
updates begin to move?[576:

Mon May 11 05:11:04 2020 What are the ITC packets in
T2-Packet-Header-Formats-13.pdf?  Those are really KITC packets,
right?  We don't have any examples of userspace ITC packets at all,
yet, right?

By T2-PHF-13, if it's not (K)ITC, it's circuit traffic -- there's no
bits left for ITC level.[577:

Mon May 11 05:17:22 2020 Now, none of the circuit stuff is used yet.
-13 is claiming CTL-ACT==00 means 'Cache upd ack', but it's not clear
to me that cache upd ack, whatever it ever exactly proves to mean,
really rises to the level of ringing a circuit or hanging it up.
Maybe we could steal back CTL-ACT==00 to mean ITC level traffic, and
remap CN3..CN0 to be ITC command types.  And make ITC_CMD_TYPE_PING
be, say, 0.

Oh wait.  'ACT' actually means something; it means 'ACTIVE'.  That's
why cache upd ack is given a separate code: It's coming from the
passive side.  And officially we're going to use to interpret CN3..CN0
as active or passive.

Well, can we steal a circuit pair and use it for the ITC level?  Or I
guess we could make the (K)ITC bit be two bits..?  I guess that would
mean combining the MFM and ITC bits into a pair, and using a mapping
like

  00 FLASH
  01 KITC
  10 ITC
  11 CIRCUIT

except that blows ASCII7 for flash traffic.  Could we leave MFM alone
but combine ITC with CTL and ACT to get seven cases like:

  000 KITC + 4 SN
  001 RING + 4 CN
  010 HANGUP + 4 CN
  011 UPDS + 4 CN
  100 UPDACK + 4 CN
  101 RSRV ACTIVE
  110 RSRV PASSIVE
  111 ITC + 4 CMD

[578:

Mon May 11 05:47:52 2020 Second sleep.[579:

Mon May 11 13:07:08 2020 Well it's time to move the flag again, but
the three-bit scheme is seeming plausible.  Unclear there's time to
cut into LKM to do it before the update.[580:

Mon May 11 13:11:11 2020 We need a name for those three bits
together..  TYPE1?  Meaning type info in byte 1?  XITC, meaning
cross-level ITC info?

:580]

:579]

:578]

:577]

:576]


:575]
:574]
[581:

Mon May 11 13:43:25 2020 OK, well, hacked new flags into itcpkt.h and
have a cut at the modified itcpkt LKM code, built but uninstalled.

Moving the flag.

RISKY BITS OFF

:581]
[582:

Mon May 11 15:36:08 2020 Flag moved.  Trying the install..

:582]
[583:

Mon May 11 15:48:47 2020 Well, LKM mfz compatible stuff still seems to
be working.  Do we dare try to advance the T2ITC state machine story a
little bit here?  Still have a few solid hours to work, I'd say.

So where were we?

:583]
[584:

Mon May 11 17:04:37 2020 Well we made T2-Packet-Header-Formats-14 to
update things a bit.

[585:

Mon May 11 17:05:35 2020 So.  All userspace T2ITC packets have byte[0]
as 0xc0|dir8, yes?  Shall we fill that in for timeout packetbuffers?

:585]

:584]
[586:

Mon May 11 18:59:03 2020 OK so taking a break I think.  Current issue
(among many) is that we're flushing packets when we first open the itc
paths -- and history says that's the right thing to do, to avoid
trying to process piles of ancient history crap when starting up --
but that means we tend to discard the compatibility message that KITC
kindly sent up to us... precisely ONCE.

So we never see it, almost surely, so we never try to advance our
ITCs.

Two approaches come to mind.
 - Be able to 'elicit' a compatibility packet, for example by writing
   an empty packet down to KITC.  Or, less OBVIOUSLY HACKY, by

 - Having a sysfs entry, say /sys/class/itc_pkt/compatible or
   something, that somebody reads when they want to check where we're
   at.

Nap.[587:

Mon May 11 19:38:28 2020 Actually, we're moving towards have STD LOCL
0xc0 packets always be defined on a point-to-point basis, since (by
definition) they're never routed, so everybody always knows STD LOCL
packets always came from their immediate wire-level counterparty.  And
that means it wouldn't be so hacky to have a STD LOCL packet meaning
'report compatibility' that could be sent USER->KITC to elicit the
0xc1 (compatible) or 0x2 (incompatible) response.

And that's arguably less hacky than sys class foofery.  We can do it
because we're doing multiscale 'end to end' packet definitions, rather
than pooping out on a transparent byte stream and forcing everything
else to go OoB via other mechanisms.

Of course the advantage of sys class foofery is that it's atomic.

:587]

:586]
[588:

Tue May 12 23:59:21 2020 OK so we're past the update and the first
thing I want to do here is commit to the 'STD LOCL is link layer'
concept and redo the doc to reflect that, with different STD LOCL
sections for documenting the different links the T2 tile has:

 LKM->PRU
 LKM->USR
 PRU->LKM
 PRU->PRU
 USR->LKM

Now, except for PRU->PRU -- which is not currently using STD LOCL at
all -- all of those links are asymmetric.  Does that mean, for
example. that we want to document LKM->USR and USR->LKM separately, as
that alpha-by-source listing implies?

I guess that ordering is bad because the LKM should be in the middle
no matter what.  So it should probably be a 'pseudo-7 layerish'
ordering like:

  PRU->PRU
  PRU->LKM
  LKM->PRU
  LKM->USR
  USR->LKM

which puts all the asymmetric pairs adjacent to each other.

Let's give it a try.[589:

Wed May 13 04:34:18 2020 OK well T2-PHF-15 is still pretty torn up,
but it's getting there.  And we've updated T2ITC.cpp to follow what we
documented.  And we've rewritten LKM stuff in itcpkt and itcmfm to
(supposedly) respond to an MFM->LKM 'ping'.

The LKM stuff now builds again.  But nothing's been installed or
tested at all.[590:

Wed May 13 06:22:26 2020 OK, so T2-PHF-15 is pretty much declared
done, modulo any bugs found soonish..  But second sleep first.

:590]

:589]

:588]
[591:

Wed May 13 12:21:08 2020 Well so let's install this and try it, right?
Is userspace ready to go, as far as we know?[592:

Wed May 13 12:40:02 2020 Is now, as far as we can tell.  Let's try the
modified LKM.

RISKY BITS OFF

:592]

:591]
[593:

Wed May 13 12:44:54 2020 Well, we seem to be back up.  And in a change
from recent days, the itcSpike12 launched by systemd seems to be
surviving.  ITC/ET and /WT both seem to be closed despite the
loopback, so we can start there..[594:

Wed May 13 12:57:21 2020 We also have a pending design question: In
the 'new original' state machine system in itcmfm, received KITC
packets are dispatched based on the state machine number ENCODED IN
THE PACKET, NOT on the state of the receiving KITC.  But that makes
sense because it's peer to peer KITC<->KITC traffic, so the same state
machine code is doing both send and receive.

But here in T2ITC userspace that's not necessarily true.  The packets
that are going to advance us through our state machine states may be
coming from KITC, as in our compatibility pings.

....Buut it is also true that eventually T2ITC is going to be getting
packets from peer T2ITCs, which is like the KITC<->KITC story.  And we
have an alternative -- sysfs -- for doing the compatibility checking.

Maybe we want to rethink the whole KITC<->MFM LOCLSTD story (which, of
course, just drove the upheaval of T2-PHF-15), and just expect MFM to
poll down via sysfs for compatibility info.[595:

Wed May 13 13:58:32 2020 I kind of think maybe we do.  So what would
be the changes for that?

 - Create more sysfs entries.  How many?
   = One? /sys/class/itc_pkt/..  [596:

Wed May 13 14:01:33 2020 Well, now, we note we already have
/sys/class/itc_pkt/status

    $ cat /sys/class/itc_pkt/status
    01000100

which has a dir8 entry per itc.  We could consider extending that from
a bitvector to a decimal vector or something, and using, say, '2' for
contact-but-incompatible, and '3' for 'compatible contact'.

Who's using this status?  cdm.pl probably?[597:

Wed May 13 14:14:44 2020 Well, I don't see any relevant 'status'
matches in cdm.pl..[598:

Wed May 13 14:16:19 2020 ~/T2-12/apps/t2/pktstat/pktstat (perl script)
is reading it.  And T2InfoPanel.cpp in itcSpike12 is reading it.

And:

 - MFM/src/drivers/t2viz/src/T2Viz.cpp

 - MFM/src/drivers/mfmt2/src/ITCLocks.cpp

and a few other hits in older itcSpikeXXs.[599:

Wed May 13 14:20:53 2020 Screw it, let's do it.  Update All.[600:

Wed May 13 14:23:56 2020 Actually wouldn't it be

 '0' not in contact
 '1' in contact but not known mfz compatible
 '2' known to be mfz compatible

and that's it?  No '3'.

:600]

:599]

:598]

:597]

:596]

:595]

:594]

:593]
[601:

Wed May 13 16:35:32 2020 OK have a cut at /sys/class/itc_pkt/status
set to return 8x{0,1,2}.  We do NOT yet have T2ITC.cpp reading that
file though.  Let's try to get through LKM make install and then see
where we are.

RISKY BITS OFF

:601]
[602:

Wed May 13 16:46:52 2020 Well, we appear to be back up..

no cables:

    root@beaglebone:~# cat /sys/class/itc_pkt/status
    00000000
    root@beaglebone:~#

w/loopback:

    root@beaglebone:~# cat /sys/class/itc_pkt/status
    02000200
    root@beaglebone:~#

So that seems okay so far.

Need to start dinner here but next up is T2ITC READ SYSFS

:602]
[603:

Thu May 14 01:40:32 2020 OK, so we have a little progress: With the
loopback, ET and WT reach CONTACT and want to send the HELO T2ITC
message -- and pulling the cable causes them to reinitialize and then
sit quietly, and reconnecting the cable -- within a few seconds --
causes them to wake up and start wanting to talk again.

So now we need the HELO T2ITC message to actually exist.  And we want
to keep in mind that the goal is to do STATE NUMBER SIGNALING -- we're
not sending arbitrary packets back and forth, here at the T2ITC level,
we're sending our current state number plus whatever additional data
we think is relevant to being in that state.  Let's quickly review the
KITC state machine and see what lessons we might glean.[604:

Thu May 14 02:00:01 2020 For example:

 - KITC state numbers ship in the bottom four bits of packet byte[1]

 - Byte 0 is 0xa0|dir8 -- where is that getting set up or checked in
   T2ITC?

 - We now have separate minors for each dir6 -- PKT_MINOR_MFM_ET
   .. PKT_MINOR_MFM_NE -- which means userspace can write packets to
   any of them.  But userspace still has to put on packet byte[0], and
   it apparently has to set its destination dir8, even though you'd
   really think that would be implied by the minor device number.

   So it currently seems, for example, that if you wrote a packet
   beginning with 0xa1 to, say, /dev/itc/mfm/WT, that packet would get
   sent out the northeast ITC, since dir8==1 means NE.

   The design aggressive approach to this is to have the
   /dev/itc/mfm/* minors create byte[0] themselves, and have userspace
   think the packets begin at byte[1].

   A more moderate approach is have userspace still include a byte[0],
   but the minors overwrite it with the appropriate 0xa|dir8, since
   (we'd be saying) that's the only kind of packet -- routed+urgent in
   the minor direction -- that should ship on any given/dev/itc/mfm/*

   The lame-o wild-west approach, currently implemented, is to just
   believe userspace, let them write packets any direction they want,
   and have the whole idea of writing to per-itc mfm minors just be a
   continuing low-level embarrassment.

:604]

:603]
[605:

Thu May 14 02:54:30 2020 So yeah lame-o continuing embarrassment.  And
what has the HELO T2ITC packet got in it?

 - State number, as always

 - (ARE WE GOING TO DO THE HALF-PERIOD ANTI-SYNC THING?)

 - Nothing else?  Why do we have to configure the ITC local origin, or
   the tile size, or anything, instead of just hardcoding all of that
   on both sides?  As e was pointing out: Am I really going to support
   intertile events between different-sized tiles?

 - So say it's all hardcoded.  And maybe all we need to do is the
   HALF-PERIOD ANTI-SYNC THING, which we can copy relatively directly
   from the KITC state machine.  That way the userspace protocol
   leader is randomized, so the fact that the leader or the follower
   will get to OPEN (or whatever the state is) first won't induce any
   systematic bias.

 - So the states might be like:

  XX(INIT,        0,    0,    "initialized state")            \
  XX(WAITCOMP,    1,    0,    "wait for compatible physics")  \
  XX(LEAD,        1,    1,    "declare I am leader")          \
  XX(WLEAD,       0,    0,    "wait for follower ack")        \
  XX(FOLLOW,      1,    1,    "declare I am follower")        \
  XX(WFOLLOW,     0,    0,    "wait for cache sync")          \
  XX(LCACHE,      1,    1,    "send leader cache")            \
  XX(WCACHE,      0,    0,    "wait for follower cache")      \
  XX(FCACHE,      1,    1,    "send follower cache")          \
  XX(LREADY,      1,    1,    "leader is ready")              \
  XX(OPEN,        1,    1,    "open circuits to EW traffic")  \

..or something like that; not really clear at the end there.  Why do
we want the HALF-PERIOD ANTI-SYNC THING here, again?  Vs like

  XX(INIT,        0,    0,    "initialized state")            \
  XX(WAITCOMP,    1,    0,    "wait for compatible physics")  \
  XX(SYNCRDY,     0,    0,    "ready to sync caches")         \
  XX(SNDCACHE,    1,    0,    "sending cache data")           \
  XX(OPENRDY,     1,    0,    "ready to open circuits")       \
  XX(OPEN,        1,    0,    "circuits are open for EW")     \

..aand I guess I do remember the pain: The problem is never knowing
whether you'll get the next state before or after you're in it, so you
have to support both cases.  Like you might recv SYNCRDY when you're
in WAITCOMP, or you might recv SYNCRDY when you're already in SYNCRDY.

But don't we, in effect, have that problem anyway?  The leader and the
follower have to take semantic actions in different states, so we have
to duplicate code or helper-function all the semantics out anyway.
Like:

    void timeout_CHECK_KITC(ITCMFMDeviceState * mds, PacketHandler * ph)
    {
 ..
      setEnabledStatusAndKITCCompatibility(mds);
 ..
    }

and

    void receive_CHECK_KITC(ITCMFMDeviceState * mds, PacketHandler *ph)
    {
      StateNumber sn = getStateKITC(mds);
      s32 ch;
      if (sn != SN_WCONFIG || ((ch = readByteFromPH(ph)) < 0)) resetKITC(mds);
      else {
 ..
        setEnabledStatusAndKITCCompatibility(mds);
 ..
      }
    }

Where one guy -- I guess the leader -- does the semantics on a
timeout, while the follower does it when it recvs the packet the
leader sent from the timeout.

So let's stick with the HALF-PERIOD ANTI-SYNC THING and just not worry
about it now.  What we want is to have a clean exit from the protocol,
so that even though one side will get to OPEN before the other,
there's no way the early open side will be able to ring a circuit or
whatever before the later openind side sees the timeout packet that
lead to the leader being open.

:605]
[606:

Fri May 15 01:44:26 2020 Well so meetings and such ate up a big chunk
of Thursday, but we're back.  Current status is blowing up because
EWDRAIN::timeOut is a stub.[607:

Fri May 15 02:41:42 2020 Urgh blinded by the nets, and an hour is
gone.  Grrr.

Anyway, so the EWDRAIN challenge is that so far we don't have the
accounting systems set up for a T2ITC even to know which EWs it needs
to wait for.  So I guess we REVIEW the existing EW<->T2ITC framework
and see where we are and what we might need:

 - bool T2ITC::isVisibleUsable() : This needs to return false while
   draining EWs.  (Could it be as simple as:

    bool isVisibleUsable() { return getITCSN() == ITCSN_EWDRAIN; }

   ?)[609: Fri May 15 03:24:19 2020 Doh, it's ALREADY IMPLEMENTED to
   do that, via XX argument 2 ('vz') in ALL_ITC_STATES_MACRO  :609]

 - We have T2ITC::mActiveFreeCount; I imagine we'd need that to be 0
   before we'd be done with EWDRAIN.

 - But what about the passive EWs?  That stuff's hardly designed at
   all.  ..Wait: If we're just in the process of setting up this
   T2ITC, how could we possibly have any passive EWs in progress?
   'mPassiveFreeCount' (which doesn't exist ATM) would have to be zero
   or we're inconsistent.

 - So we'd also like to bump the state machine when mActiveFreeCount
   goes to 0, rather than wait for a timeout.  Where would that
   happen?  [608: Fri May 15 03:21:05 2020 freeActiveCircuit, I guess?
   Trying that.. :608]


:607]

:606]
[610:

Fri May 15 06:30:50 2020 OK, so we're finally sending and receiving
packets.  At the moment, received packets are indeed getting to
T2ITC::tryHandlePacket, which is dropping them on the floor.  What
should it be doing?  If we're following the KITC MFM code, we should
be dispatching to the receive method specified by the ITCSN in the
packet itself.  Which always seems weird to me.  But it's kind of
cool, I think.  It's an example of how 'process' on the far side (the
state machine state) becomes 'data' on the near side (that packet
type).

So on the receiving end, the idea is you got a packet of this 'type',
and you check if you're an an appropriate state for that type, and you
respond, and that's natural.  Is the idea, anyway..[611:

Fri May 15 13:27:07 2020 OK so I didn't actually realize that the
first case we saw was actually a leadership race, that we need code to
resolve:

    229: MSG: ->ITC/ET:EWDRAIN
    230: MSG: ->ITC/WT:EWDRAIN
    231: MSG: ->ITC/WT:LEAD
    232: MSG: ->ITC/ET:LEAD
    233: MSG: ->ITC/WT:WLEAD
    234: MSG: ->ITC/ET:WLEAD
    235: WRN: ITC/WT:WLEAD XXX HANDLE 2 byte 0xA6 packet

so an 'easy' next step here is to put a random byte into the LEAD
packet and do the nearest-over winner thing, right?  And didn't the
yoink protocol teach us that playing evens-odds with single bits was
enough, if we fall back on fred-vs-ginger to interpret the results?
Each send one random bit, both sides xor the bits, result==1 means
ginger wins, result==0 means fred wins.

Couldn't we draft two states, LEAD0 and LEAD1, and pick which one to
go to randomly from EWDRAIN?  Then we don't have to allocate any bits
for the yoink.  And the execution paths flow back together afterwards,
I think, so the state number cost is just one extra?[612:

Fri May 15 13:37:17 2020 No I guess we'd want WLEAD0 and WLEAD1 as
well, as the cleanest way to remember our our nonce.  (Rather than
having some bool T2ITC::mNonce to worry about.)

:612]

:611]

:610]
[613:

Fri May 15 13:44:21 2020 OK, we're setting up W?LEAD[01], and now we
need tryHandlePacket to actually dispatch to receive methods..[614:

Fri May 15 15:13:46 2020 And how exactly are WLEAD[01] going to work?
Well, mainly we want to be customizing the receive method, not the
timeout method.  (What does the default timeout method do?  Reset the
ITC? [615: Fri May 15 15:15:53 2020 No, it dies.  Maybe have it reset
instead?  :615])  [616:

Fri May 15 16:42:13 2020 So, if we received LEAD[01] while we're in a
WLEAD[01], that means a race, and we resolve it.  But what if there's
a clean win?  Receiver might conceivably be in EWDRAIN or even
WAITCOMPAT or INIT, right?  We can't jump from those states all the
way to FOLLOW, right?  We still do have to wait for EWs to drain, for
example.  How do we remember the other side won across state
change(s)?  DO we remember it?

[620:

Fri May 15 23:43:21 2020 Maybe we should grab for leader before we
drain the EWs, hey?  Y Naught?[621:

Sat May 16 01:21:13 2020 OK, still working on that.  Also added
another XX arg 'MINCOMP' so each state declares the minimum
compatibility status (in the sense of /sys/class/itc_packet/status)
that is needed to support that state.  And now T2ITC::onTimeout
automatically resets if the current status is less than the min.

Also, and this seems like probably a mistake now as I'm writing this,
KITCPoller::onTimeout now bumps any ITC when its compatibility status
changes.  The problem is, some states are counting on getting full
their timeout period, because they're going to do something that
should be unlikely if it expires.

Two questions:

 - ITC status changing is already pretty serious.  Is there really
   something that we WOULDN'T want to disrupt if it changes?
   Especially since most states currently declare 2 as their minimum
   compatibility status, which is in fact the maximum, meaning any
   changes that occur will be downward.

 - Is it worth considering a OKBUMP XX arg, saying whether this
   state's timeout can be advanced when circumstances change?

[622:

Sat May 16 01:54:56 2020 Let's leave it as we've done it, for now.
Automatically bump the ITC on enable status changes, but automatically
reset on (downward) enable changes except in special cases.

So what's next here?  More flesh on the reordered state machine I
guess.

:622]
:621]

:620]
:616]

:614]

:613]
[617:

Fri May 15 16:48:42 2020 Hey, why is PacketBuffer typedeffed as an
OString128 (in core/include/Packet.h)?  T2-PHF-* says packet length is
1..255 bytes.  In pru/itcio/module/itcpkt.h we've got:

    #define ITC_MAX_PACKET_SIZE 255

and we're going to want all those bytes for nice fat cache update
packets.

Does mfms rely on OString128 for packets in any fundamental way?  Oh,
all that simulated byte channel stuff?[618:

Fri May 15 17:05:40 2020 Well, PacketBufer from core/include is used
all over the place.  I don't want to mess with it.  Switching the
T2PacketBuffer (as OString256) for our stuff.

:618]

:617]
[619:

Fri May 15 20:40:21 2020 Not sure how it would work with the current
scheme but it would sure make sense to try to batch up into single
packets even cache updates from different in-flight event windows.
Not sure how to achieve that cleanly but it would amortize the
rpmsg+pru+wire overheads as much as possible.

But screw it crawl before fly for the moment.

:619]
[623:

Sat May 16 02:53:59 2020 OK, our LEAD[01]->WLEAD[01]->W?FOLLOW flow is
possibly plausible, albeit untested.  I guess the idea from there is
that we shouldn't have an EWDRAIN state, we should just do that as a
semantic action.  ..Which means not enabling EWs to start in those
states, and getting bumped when active EWs goes to 0?

And T2ITCStateOps::isVisibleUsable() is meant to capture that.  It's
false except in ITCSN_WAITCOMP (when cache is not usable) and in
ITCSN_SYNCED (which cache is usable).

:623]
[624:

Sat May 16 03:29:44 2020 Well let's get to gdb for a while.  Need some
concrete something here.  I guess we might need to be branching to the
EW state machine (GAH!), or at least stubbing it out, pretty soon
here.[625:

Sat May 16 04:00:57 2020 Jeez finally got it to build.

:625]

:624]
[626:

Sat May 16 05:09:36 2020 OK, got to this with the ET<->WT loopback.

    217: MSG: ITC/WT:INIT: Initializing
    218: MSG: ->ITC/WT:WAITCOMP
    219: MSG: ITC/ET:INIT: Initializing
    220: MSG: ->ITC/ET:WAITCOMP
    221: MSG: ->ITC/WT:LEAD0
    222: MSG: ->ITC/ET:LEAD0

They both picked 0

    223: MSG: ->ITC/WT:WLEAD0
    224: MSG: ->ITC/ET:WLEAD0

And went to WLEAD0 accordingly.  That leads to 'evens' in
T2ITC::resolveLeader.. which should lead to whichever side isGinger
being the leader (and will go to WFOLLOW to await the far side's ack),
and the isFred side should go to FOLLOW.

    225: MSG: ->ITC/ET:FOLLOW

And indeed, according to dirdatamacro.h:

    /*           DIR FRED IRQLK IGRLK ORQLK OGRLK */ \
    /*0 0x01*/ XX(ET,   1,  69,   68,   66,   67)    \

ET is a fred, which means it loses the race and goes to FOLLOW,

    226: MSG: ->ITC/WT:WFOLLOW

while WT is a ginger and wins the race.

    227: ERR: virtual void MFM::T2ITCStateOps_FOLLOW::timeout(MFM::T2ITC&, MFM::T2PacketBuffer&, MFM::TimeQueue&) is a stub
    228: ERR: src/T2ITC.cpp:248: (timeout) XXX IMPLEMENT ME

Then ET times out and everything blows up. The End.

:626]
[627:

Sat May 16 05:17:10 2020 So what happens now?  By TO FOLLOW, all EWs
should be drained, so we say.  They've been blocked from starting
since leaving WAITCOMP.  So in TO FOLLOW we confirm no active EWs,
then we init some 'cache atoms sent' counter and go to CACHEXG with a
short timeout.

At TO WFOLLOW, we do the same thing?

Time for walkies, but it's really starting to bug me that on TO the
potential outbound packet is already set up with the current state,
when I feel like I'd rather be sending the new state I'm going to.
Can we double-check itcmfm.c and see why it's happy doing it with the
current state?
[628:

Sat May 16 06:09:22 2020 Well itcmfm does seem to do that.. and it
allows timeout_FOO and receive_FOO methods to be written one after the
other, and then they get executed one after the other, on opposite
tiles.  Like:

    void timeout_LEAD_KITC(ITCMFMDeviceState * mds, PacketHandler * ph)
    {
      setStateKITC(mds, SN_WLEAD);
      setTimeoutKITC(mds, jiffiesToWait(WC_FULL));
      sendPacketHandler(ph);

Sends SN_LEAD, not SN_WLEAD..

    }

    void receive_LEAD_KITC(ITCMFMDeviceState * mds, PacketHandler *ph)
    {

So this runs on the other side..

      StateNumber sn = getStateKITC(mds);
      if (sn == SN_WLEAD &&              /* race detected */
          prandom_u32_max(2)) {          /* flip coin */
        resetKITC(mds);
      } else {
        setStateKITC(mds, SN_FOLLOW);
        setTimeoutKITC(mds, jiffiesToWait(WC_HALF));
      }
    }

Can we review what we have in T2ITC land with that happy feeling in
mind?

:628]
:627]
[629:

Sat May 16 13:54:08 2020 OK, we're blowing up in startCacheSync and
the yoinking is looking vaguely plausible.  Time to SHIP CACHE![630:

Sat May 16 13:56:46 2020 So, what are these packets going to look
like?  Design issues:

 - It's going to be multiple packets, and conceivably (CONCEIVABLY) we
   might blow out kfifo space, so we're not going to assume we write
   all those packets in one sitting.  So we're going to keep track of
   what we've written successfully, and be willing to sleep a little
   and try again.

 - We need to iterate over all sites that are visible from a given
   ITC.  How do we do that?  Do we have a RectIterator?  Do we want
   one now?  [631: Sat May 16 14:14:59 2020 Well let's whip up a quick
   one.. :631]

:630]

:629]
[632:

Sat May 16 16:40:52 2020 Umm.  I may have forgotten some long-ago
design decisions...

    232: MSG:   ITC/ET:CACHEXG wrote 254 == 254
    233: MSG:   ITC/WT:CACHEXG wrote 254 == 254

Beautiful nearly full cache exchange packets!  They be writ!

    Thread 1 "itcSpike12" hit Breakpoint 1, MFMLongJmpHere (buffer=0xbefff928, toThrow=1)
        at src/FailPlatformSpecific.cpp:48
    48	    longjmp(buffer,toThrow);
  ..
    475	  void T2ITCStateOps_CACHEXG::receive(T2ITC & itc, T2PacketBuffer & pb, TimeQueue& tq) {
    476	    FAIL(INCOMPLETE_CODE);

OK we need to write more code.

    477	  }
    478
    479	}
    (gdb) p pb.m_written
    warning: RTTI symbol not found for class 'MFM::OverflowableCharBufferByteSink<258u>'
    $125 = 127

But uh, but uh, where did the rest of the packet go?

[633:

Sat May 16 16:44:54 2020 I see:

    ./firmware/Buffers.h 133:#define MAX_PACKET_SIZE 256

and I see

    ./module/itcpkt.h 149:#define ITC_MAX_PACKET_SIZE 255

..so what's the deal?

[634:

Sat May 16 16:48:57 2020 GAG NOW I ALSO SEE

    ./T2ITC.cpp 125:    const u32 MAX_PACKET_SIZE = 127;

Why is that foggen peon soldier even dreaming it has any right to
decide anything like that?!


:634]

:633]

:632]
[635:

Sat May 16 22:33:21 2020 OK, now dying in recvCacheAtoms!  Time to
write that!  Getting a little excited here!  A few more functions and
debugging and stuff, and we'll have to start on the event window state
machine!
[636:

Sun May 17 01:00:43 2020 Debugging first cut at recvCacheAtoms.  Looks
like we have issues on the ITC rectangles (that are actually appearing
on the sendCacheAtoms side now that the recv isn't blowing up.)
Suspecting my rectangles in getRectForTileInit aren't all quite right,
for one thing.

Let's try to sketch it all out here.


                                TTTTTTTTTTT
                                WWWWWWWWWWW
                                ///////////                    TTTTT
                                22222222222                    WWWWW
                                -----++++++                    -----
       +01234-------------------54321012345--------------------54321+
       0oooooooooooooooooooooooooooooopppppppppppppppppppppppppppppp0
       1oooooooooooooooooooooooooooooopppppppppppppppppppppppppppppp1
       2oooooooooooooooooooooooooooooopppppppppppppppppppppppppppppp2
       3oooooooooooooooooooooooooooooopppppppppppppppppppppppppppppp3
       4aaaaeeeeggggggggggggggggggmmmmmmmmkkkkkkkkkkkkkkkkkkiiiicccc4
       5aaaaeeeeggggggggggggggggggmmmmmmmmkkkkkkkkkkkkkkkkkkiiiicccc5
       6aaaaeeeeggggggggggggggggggmmmmmmmmkkkkkkkkkkkkkkkkkkiiiicccc6
       7aaaaeeeeggggggggggggggggggmmmmmmmmkkkkkkkkkkkkkkkkkkiiiicccc7
       8aaaabbbb                                            ddddcccc8
       9aaaabbbb                                            ddddcccc9
       |aaaabbbb                                            ddddcccc|
       |aaaabbbb                                            ddddcccc|
       |aaaabbbb                                            ddddcccc|
       |aaaabbbb                                            ddddcccc|
       |aaaabbbb                                            ddddcccc|
    TH-9aaaabbbb                                            ddddccccTH-9
    TH-8aaaaffffhhhhhhhhhhhhhhhhhhnnnnnnnnlllllllllllllllllljjjjccccTH-8
    TH-7aaaaffffhhhhhhhhhhhhhhhhhhnnnnnnnnlllllllllllllllllljjjjccccTH-7
    TH-6aaaaffffhhhhhhhhhhhhhhhhhhnnnnnnnnlllllllllllllllllljjjjccccTH-6
    TH-5aaaaffffhhhhhhhhhhhhhhhhhhnnnnnnnnlllllllllllllllllljjjjccccTH-5
    TH-4qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrTH-4
    TH-3qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrTH-3
    TH-2qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrTH-2
    TH-1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrTH-1
       +------------------------------------------------------------+

  a:WT cache    i:NE&ET vis  p:NE cache
  b:WT visible  j:SE&ET vis  q:SW cache
  c:ET cache    k:NE vis     r:SE cache
  d:ET visible  l:SE vis
  e:WT&NW vis   m:NE&NW vis
  f:WT&SN vis   n:SE&NW vis
  g:NW vis      o:NW cache
  h:SW vis

:636]
 :635]
[637:

Sun May 17 03:06:23 2020 OK we're still not sure about the rects, but
we fixed the rectiterator and now we're using multiple CACHEXG packets
to send a big pile of atoms, and finishing up with an empty CACHEXG as
a flag.. And we're dying on INCOMPLETE_CODE again -- what do we do
when we've sent all our packets?

Well, we want to wait until we've gotten all their packets, and then
we fricken want to go to SYNC and start letting EWs go intertile.

We theoretically know when we've gotten all their packets because
recvCacheAtoms will return true.  Now, recvCacheAtoms also returns
true if something screwed up and it did a reset, but how does caller
know that?  Check its own effen state?  Ugh!

:637]
[638:

Sun May 17 06:41:59 2020 Try to review the intended flow here.

 TO INIT -> WAITCOMP now
 TO WAITCOMP -> LEAD[01] now
 TO LEAD[01] ship -> WLEAD[01] full

               RP LEAD[01] -> FOLLOW half if lost
                           -> WFOLLOW full if won

 TO FOLLOW ship -> CACHEXG full

               RP FOLLOW startCacheSync -> CACHEXG now

 TO CACHEXG

:638]
[639:

Sun May 17 16:45:06 2020 Gah I'm really wondering why we can't just do

T2ITC ctor sets everything to 0 forcibly, then calls reset
reset (method) aborts all registered EWs, then sets EWINTRA with short timeout

EWINTRA -> EWPAUSE -> CACHEXG* -> EWINTER

(0) While in EWINTRA, we accept EWs for local execution.  All events
    touching sites visible in this ITC are registered and unregistered
    as they happen, but no locks are required or taken.

(1) In TO EWINTRA, when we see compatibility status == 2, we ship our
    EWINTRA state, then go to EWPAUSE with a decent timeout (perhaps
    250-500ms).  In EWPAUSE, no further EWs are allowed to register.

    (1a) In RP EWINTRA, if our state is > EWPAUSE, we reset, else do
         nothing.

(2) In TO EWPAUSE, there are no registered events, or else we reset.
    We call startCacheSync, which resets mVisibleAtomsToSend, sets
    mCacheAtomsReceived to 0, and takes us to CACHEXG with a 0
    timeout.

(3) In TO CACHEXG, we call sendVisibleAtoms (which ships our CACHEXG
    state) and note whether it was finished.  We also note whether
    we've received all cache atoms from the far side.  If finished
    both ways, go to EWINTER, otherwise short timeout.

    (3a) In RP CACHEXG, if our state < EWPAUSE, we reset, else we
         accept atoms into our cache, while counting them.

(4) We sit in EWINTER doing events intertile.  All events touching
    sites visible in this ITC are registered to get a circuit, and
    locks must be taken using the EW state machine + the allocated
    circuit.

    In TO EWINTER we ship our state just to be neighborly and do a
    random long timeout;

    (4a) In RP EWINTER, if our state < CACHEXG, we reset, else we do
         nothing.

[640:

Sun May 17 17:41:35 2020 What's wrong with that, I axe you.  Time to
cook dinner.

:640]
:639]
[641:

Mon May 18 00:39:56 2020 Well, going to try the 'simplified' scheme of
:639:.  Committing all this WIP first..

:641]
[642:

Mon May 18 01:40:57 2020 Committed..  Tearing up the T2ITC state
machine.

:642]
[643:

Mon May 18 04:11:25 2020 Ohhhhhhhhhhhh man.  The brand new simplified
just written no yoink T2ITC protocol kind of seems to be working first
try:

    wconfig.txt:171:57: debug: Name:PhysicsCtl_Button_Seed, Type:MenuItem, Parent:PhysicsCtl, 300x94@(158,4)
    wconfig.txt:177:55: debug: Name:PhysicsCtl_Button_X, Type:MenuItem, Parent:PhysicsCtl, 300x94@(81,209)

End of window config during start up.

    14: WRN: Big MSPAST 2756
    15: ERR: void MFM::T2ITC::abortAllEWs(): WRITE ME XXX

That will come in the next phase, as we actually start dealing with
EWs..

    16: MSG: ->ITC/ET:EWINTRA
    17: ERR: void MFM::T2ITC::abortAllEWs(): WRITE ME XXX
    18: MSG: ->ITC/SE:EWINTRA
    19: ERR: void MFM::T2ITC::abortAllEWs(): WRITE ME XXX
    210: MSG: ->ITC/SW:EWINTRA
    211: ERR: void MFM::T2ITC::abortAllEWs(): WRITE ME XXX
    212: MSG: ->ITC/WT:EWINTRA
    213: ERR: void MFM::T2ITC::abortAllEWs(): WRITE ME XXX
    214: MSG: ->ITC/NW:EWINTRA
    215: ERR: void MFM::T2ITC::abortAllEWs(): WRITE ME XXX
    216: MSG: ->ITC/NE:EWINTRA
    217: MSG:   ITC/WT:EWINTRA wrote 2 == 2
    218: MSG: ->ITC/WT:EWPAUSE

WT detects compatibility and begins the opening sequence.

    219: MSG:   ITC/ET:EWINTRA wrote 2 == 2
    220: MSG: ->ITC/ET:EWPAUSE

ET does too.

    221: ERR: MFM::u32 MFM::T2ITC::registeredEWCount() const: WRITE ME XXX

Also to come in next phase.  Current returns 0 meaning no EWs to be
waiting on.

    222: MSG: ->ITC/WT:CACHEXG

So it's on to cache exchange.

    223: ERR: MFM::u32 MFM::T2ITC::registeredEWCount() const: WRITE ME XXX
    224: MSG: ->ITC/ET:CACHEXG

ET ditto

    225: MSG:   ITC/WT:CACHEXG wrote 254 == 254
    226: MSG:   ITC/ET:CACHEXG wrote 254 == 254
    227: MSG:   ITC/WT:CACHEXG wrote 254 == 254
    228: MSG:   ITC/ET:CACHEXG wrote 254 == 254
    229: MSG:   ITC/WT:CACHEXG wrote 254 == 254
    230: MSG:   ITC/ET:CACHEXG wrote 254 == 254
    231: MSG:   ITC/WT:CACHEXG wrote 254 == 254
    232: MSG:   ITC/ET:CACHEXG wrote 254 == 254
    233: MSG:   ITC/WT:CACHEXG wrote 254 == 254
    234: MSG:   ITC/ET:CACHEXG wrote 254 == 254
    235: MSG:   ITC/WT:CACHEXG wrote 254 == 254
    236: MSG:   ITC/WT:CACHEXG wrote 254 == 254
    237: MSG:   ITC/ET:CACHEXG wrote 254 == 254
    238: MSG:   ITC/WT:CACHEXG wrote 254 == 254
    239: MSG:   ITC/ET:CACHEXG wrote 254 == 254
    240: MSG:   ITC/WT:CACHEXG wrote 212 == 212

WT sends the last of its visibles.

    241: MSG:   ITC/ET:CACHEXG wrote 254 == 254

ET is still going

    242: MSG:   ITC/WT:CACHEXG wrote 2 == 2

WT sends the empty "I'm done" packet.

    243: MSG:   ITC/ET:CACHEXG wrote 212 == 212

ET sends the last of its stuff.

    244: MSG:   ITC/WT:CACHEXG wrote 2 == 2

WT sends another "I'm done" packet, which is not really what I
intended, but is what I coded.  If we wanted to avoid this, we'd need
to have some additional state or flag to record the fact that we
already announced we're done sending.  But it doesn't really hurt much
as it is; recvCacheAtoms gets called an extra time and has to discover
there's no atoms in this packet either.

    245: MSG:   ITC/ET:CACHEXG wrote 2 == 2

ET says "I'm done sending".

    246: MSG: ->ITC/ET:EWINTER

And since ET already knows WT is done sending, it's on to EWINTER.


    247: MSG:   ITC/WT:CACHEXG wrote 2 == 2

WT announces it's done one more time.

    248: MSG: ->ITC/WT:EWINTER

But now it knows ET is done too, so it's on to EWINTER!

    249: MSG:   ITC/WT:EWINTER wrote 2 == 2
    250: MSG:   ITC/ET:EWINTER wrote 2 == 2

Every ten seconds or so, they just say a friendly hello -- even though
normally they'll be pounding circuit traffic to each other non-stop
while in EWINTER: It's not like they won't know the other side is there.

    251: MSG: Pushing fake isDown 0 pressed 1 val 1.000000
    252: MSG: Pushing fake isDown 1 pressed 0 val 0.000000

I switched to the TQ just to see what's what.  Everything looked as
expected.

    253: MSG:   ITC/WT:EWINTER wrote 2 == 2
    254: MSG:   ITC/ET:EWINTER wrote 2 == 2

:643]
[644:

Mon May 18 05:03:09 2020 Well!  So that's some progress!  I guess I'm
a little unhappy that the names EWINTER vs EWINTRA are so visually
similar; they're hard to tell apart on the TW display.  EWCLOSED vs
EWOPEN?  LOCAL/REMOTE?  IN/OUT?  CLOSED/OPEN?  ISOLATED/LINKED?
EDGE/BRIDGE?  (Grr, that pair's cool, but lots of letter overlap.)

EDGE/LINK?  INTERNAL/EXTERNAL? INT/EXT?

Maybe just CLOSED/OPEN.  It's pretty obvious.

:644]
[645:

Mon May 18 06:13:14 2020 Going with SHUT/OPEN.

:645]
[646:

Mon May 18 06:14:05 2020 So now it's time for the EW state machine.
Shall we just talk about that informally first for a little?

It starts with EWInitiator::onTimeout.

Which goes to T2Tile::maybeInitiateEW.

Which picks random centers and goes to T2Tile::considerSiteForEW

Which examines the site and determines its radius.  If the radius is
0, the event is done.

If the radius is non-zero, maybeInitiateEW then goes to
T2Tile::tryAcquireEW.

Which goes to T2Tile::allocEW()

Which consults T2Tile::mFree to see if any EWs are available.  If not,
tryAcquireEW returns false, so maybeInitiateEW returns false, so
EWInitiator::onTimeout reschedules for about 5ms in the future.

Otherwise an EW was allocated.  And tryAcquireEW goes to
T2EventWindow::tryInitiateActiveCenter with the given center and
radius.

Which initializes the EW and records the center and radius in it.

Then it goes to checkSiteAvailability.

Which scans the whole neighborhood checking to see if all the sites
are unowned.  If any are owned, that's an overlap so this event can't
happen.

If checkSiteAvailability returns false for any reason,
tryInitiateActiveEvent returns false as well.  When that happens,
T2Tile::tryAcquireEW calls freeEW to get rid of it.  Note that sooner
or later, T2ITCs will need to be in that process of freeing an EW
somehow.

If sites ARE available, checkSiteAvailability then checks if the site
is hidden.  If so, it marks that site as live and continues.

For peripheral (non-hidden) sites, checkSiteAvailability then checks
all the ITCs to see if one or more contain the site.  For each T2ITC
that is, goes to addITCIfNeeded, which adds that itc to
T2EventWindow::mCircuits if it's not already there.  It seems that
mCircuits[].mITC != 0 is (part of) how we couple T2EventWindows and
T2ITCs, so we'll need to focus on that when aborting EWs or generally
cleaning up.

If the site under consideration is in cache, checkSiteAvailability
asks the itc if isCacheUsable, and T2ITC::isCacheUsable gets that
information from the state machine tables.  Specifically, if XX CCH
arg in ALL_ITC_STATES_MACRO is non-zero, then the cache is usable.  In
the current code, that is true only of state ITCSN_OPEN.  Otherwise
cache sites are not live.

For visible sites, checkSiteAvailability goes to the itc asking if it
isVisibleUsable, which accesses the XX VIZ arg in
ALL_ITC_STATES_MACRO.  isVisibleUsable is true in ITCSN_SHUT and
ITCSN_OPEN, and false everywhere else.

Note well: If isVisibleUsable says no, checkSiteAvailability
immediately returns false WITHOUT ZEROING OUT any mCircuits[].mITCs
that it may have set up.

Finally, if checkSiteAvailability returns true, then all sites are
available and usable, and the EW's mSitesLive[] array has been set up
indicating the live sites for this event.
[647:

Mon May 18 07:59:09 2020 Have to nap.  But that was useful for heading
into this T2EW<->T2ITC interaction phase.  (Maybe we could say you
need mCircuits[].mITC != 0 AND mCircuits[].mCircuitNum != MAX_VAL or
something, for the EW to be considered 'registered' with the ITC, from
the EW side.

Sleep now.[648:

Mon May 18 13:05:21 2020 OK where were we.

If checkSiteAvailability returns false, tryInitiateActiveEvent returns
false, and T2Tile::tryAcquireEW releases the (unused) EW via freeEW,
which currently does nothing except put the EW back into
T2Tile::mFree.

Otherwise checkSiteAvailability returns true, and
tryInitiateActiveEvent then goes to checkCircuitAvailability.  Which
is currently unimplemented, and always returns false, thus blowing
every event right there.

So that's the frontier.

:648]

:647]

:646]
[649:

Mon May 18 13:11:59 2020 So that's where we are.  A couple other
notes/thoughts:

 - When EWs are in T2Tile::mFree, they are not scheduled.

 - Are we thinking (I think) that even hidden EWs are NOT going to
   complete atomically?  The way tryInitiateActiveEvent is written, if
   we get all the way through everything, we schedule the EW either
   way.

 - If we had a shortcut path for hidden events it could be notably
   shorter -- wouldn't have to hog and unhog mSiteOwners, for
   example..  But ah, come on, all that's going to be down in the
   noise; this is not a 'tight loop' we're talking here.  Let's
   continue to assume non-atomic for all EWs.

[650:

Mon May 18 13:19:17 2020 So.  EW overview:

Random center + allocate EW + init EW + checkSiteAvailability

that's what exists now.  Then I'd think

 + registerWithITCs + schedule

and then we're into the EW state machine.

Right now we're doing

 checkCircuitAvailability + hog region + registerWithITCs

but I think easier cleanup might want us to do circuit allocation the
same time as we register with the ITCs.

Let's look at the resource lifetimes of an EW.[651:

Mon May 18 13:29:37 2020 An EW has up to two CircuitInfos.  Each
CircuitInfo has a T2ITC * and a CircuitNum.

Suppose we 'register with the ITC' as part of checking site
availability.  Like in addITCIfNeeded.  Change that to return bool --
addITCIfNeededAndAvailable.  And at that point the EW will be
responsible for deregistering from the ITC as during its lifetime.

bool tryRegisterWithITC(T2ITC & itc)

Rule for EW is you have to register with itc if any of your sites are
contained by the itc's visible or cache.  (Hmm checkSiteAvailability
is currently check its sites against just the visible rect.  That's
probably wrong, right? [652: Mon May 18 13:52:29 2020 Changed it to
tile.getVisibleAndCacheRect(dir6).  We shall see. :652])

[653:

Mon May 18 13:52:55 2020 So the invariant is going to be that
EW->mCircuits[].mITC == ITCPTR implies that ITCPTR->mSOMETHING == EW,
and that will be INDEPENDENT of whether a circuit is currently
allocated for the EW or not.

So, an instance of that invariant will be created by
T2EventWindow::tryRegisterWithITC(T2ITC&), which will go to
T2ITC::registerEventWindow(T2EventWindow &), which will.. put it in an
EWSet?  ..But EWSet doesn't have fast find.  Does each EW have a
number, so we could index off that?[654:

Mon May 18 14:25:58 2020 Yes, each EW has a const mSlotNum, assigned at
ctor time in the range 1..MAX_EWSLOT.  (We're contorting ourselves to
avoid using slotnum==0 for some reason.)

And we can map from slotnum back to EW* via T2Tile::getEW(slotnum).

So. What is the T2ITC::mSOMETHING going to be?[655:

Mon May 18 14:56:53 2020 Trying

      T2EventWindow *(T2ITC::mRegisteredEWs[MAX_EWSLOT+1]);

[656:

Mon May 18 15:43:00 2020 Saying T2EW::finalizeEW() is where we
unregister from ITCs.

:656]
:655]

:654]

:653]


:651]

:650]

:649]
[657:

Mon May 18 15:52:53 2020 Hmm we're building clean at the moment.  But
lots of stuff doesn't exist.  Maybe see what blows up, try to get a
little concrete behavior here?[658:

Mon May 18 15:54:35 2020 Well, so, concrete:

 - abortAllEWs still doesn't exist

 - registeredEWCount doesn't exist (but that's easy now, right?)

 - After getting to open, still no events seem to be happening.

Let's work on those![659:

Mon May 18 16:11:43 2020 OK, first two knocked off.  Now let's watch
EWInitiator again and see what's what.

:659]

:658]

:657]
[660:

Mon May 18 16:15:50 2020 OK working through from EWInitiator.  We only
have the one non-zero site so that's the one we're focusing on.

We've gotten as far as:

    #0  MFM::T2EventWindow::assignCenter (this=0x506548, tileSite=..., radius=4, activeNotPassive=true)
        at include/T2EventWindow.h:124
    #1  0x00459dc6 in MFM::T2EventWindow::tryInitiateActiveEvent (this=0x506548, center=..., radius=4)
        at src/T2EventWindow.cpp:106
    #2  0x0045136a in MFM::T2Tile::tryAcquireEW (this=0x4b9008 <MFM::T2Tile::get()::THE_INSTANCE>, center=..., radius=4,
        forActive=true) at src/T2Tile.cpp:364
    #3  0x00451a00 in MFM::T2Tile::maybeInitiateEW (this=0x4b9008 <MFM::T2Tile::get()::THE_INSTANCE>) at src/T2Tile.cpp:444
    #4  0x00450148 in MFM::EWInitiator::onTimeout (this=0x4ec970 <MFM::T2Tile::get()::THE_INSTANCE+211304>, srctq=...)
        at src/T2Tile.cpp:18

and just nothing that assignCenter is currently setting the EWSN to
EWSN_AINIT or EWSN_PINIT.. which seems maybe a little out of
assignCenter's lane but we'll see.[661:

Mon May 18 16:19:05 2020 Got through getSiteAvailability OK.  And now
to checkCircuitAvailability which still doesn't exist and returns
false.

So that's where we are.

And how should checkCircuitAvailability work?[665:

Mon May 18 23:33:05 2020 Considering the EW's ITCs..  :665]

 - If we're in ITCSN_SHUT, we don't need a circuit

 - Otherwise, if we're NOT in ITCSN_OPEN, we shouldn't be asking,
   because we already checked isVisibleUsable in
   checkSiteAvailability.

 - If we are in ITCSN_OPEN, we go to T2ITC::tryAllocateActiveCircuit.
   If we get ALL_CIRCUITS_BUSY, we return false from
   checkCircuitAvailability, as we are doing now.  Otherwise, we store
   the resulting circuitnum in mCircuits[].mCircuitNum associated with
   the itcs.

 - That means we now also need to release that circuit when we
   finalize the EW.  And what, really, are we using to mean 'no
   circuitnum allocated', there?[662:

Mon May 18 16:35:24 2020 It seems like although we're using
1..MAX_EWSLOTS for event window numbering, we're using
0..CIRCUIT_COUNT-1 for circuit numbering.  So let's use
CircuitNum.maxof (==0xff) to mean unallocated.

:662]

:661]

:660]
[663:

Mon May 18 17:09:24 2020 Getting to be time to break for the evening.
Leaving it busted with T2ITC::freeActiveCircuit needing work, and
finalizeEW, and still still checkCircuitAvailability.

:663]
[664:

Mon May 18 23:31:16 2020 OK, we're now back to
checkCircuitAvailability.
[666:

Mon May 18 23:42:53 2020 And now at long long last we have a cut at it..

:666]
:664]
[667:

Mon May 18 23:46:10 2020 OK!  Finally on to a DIFFERENT incomplete
code!  Now it's time to hog the region!

[668:

Mon May 18 23:54:01 2020 And just like that we're finally into the
actual T2EventWindow state machine code:

    216: ERR: src/T2EventWindow.cpp:243: (timeout) XXX IMPLEMENT ME
 ..
    241	  //// DEFAULT HANDLERS FOR T2EWStateOps
    242	  void T2EWStateOps::timeout(T2EventWindow & ew, T2PacketBuffer & pb, TimeQueue& tq) {
    243	    DIE_UNIMPLEMENTED();
    244	  }
    245
    246	  void T2EWStateOps::receive(T2EventWindow & ew, T2PacketBuffer & pb, TimeQueue& tq) {

[669:

Mon May 18 23:59:08 2020 Aand our first state blowout is:

    219: ERR: ABEHAVE on EW32/ABEHAVE: no timeout handler
    220: ERR: src/T2EventWindow.cpp:244: (timeout) XXX IMPLEMENT ME

because, indeed, our only possible event is the DReg-in-the-middle,
and it's hidden, so we skip past locks and go straight to behave.

What say we move our DReg into the NW corner, though?  Hidden events
aren't so interesting since most of that code will need to be torn out
when ulam comes back in anyway..  DReg-in-the-corner can get both SHUT
and OPEN events, and getting that working is big poop.

:669]
:668]

:667]
[670:

Tue May 19 00:24:38 2020 Ah now we're blowing an actual assertion for
a change; what's going on?

    #1  0x0045d58e in MFM::T2ITC::registerEWRaw (this=0x4b9d94 <MFM::T2Tile::get()::THE_INSTANCE+3468>, ew=...)
        at src/T2ITC.cpp:371
    371	    MFM_API_ASSERT_STATE(isVisibleUsable());

[671:

Tue May 19 00:28:24 2020 So, we're in ITC/WT, and we just saw:

    232: MSG:   ITC/WT:CACHEXG wrote 254 == 254

and so indeed, isVisibleUsable is returning false, which is what's
blowing the assertion.  So, this is a good case.  We should have
detected the problem and blown up this particular event before trying
to register the EW.  Why didn't that happen?[672:

Tue May 19 00:33:13 2020 Looks like because checkSiteAvailability was
trying to be tricky and ended up doing things in the wrong order.
Really, we should be going to isVisibleUsable as soon as we find a
site in the visible region.  Problem is our opening check combines
both visible and cache.  Let's just hack it, here.[673:

Tue May 19 00:38:26 2020 Now wait a second, here.  If visible isn't
usable due to ITC not being either SHUT or OPEN, the same is going to
be true of cache, too, right?  isCacheUsable ought to presume
isVisibleUsable..  Which means we don't have to distinguish cache from
visible for usability purposes in checkSiteAvailability.

:673]

:672]

:671]

:670]
[674:

Tue May 19 00:55:39 2020 Well, we got through
checkCircuitAvailability, and correctly differentiated between ITC/WT,
which did need a circuit because it was OPEN, and ITC/NW, which didn't
because it was SHUT.

Now it appears we've successfully hogged the whole region...[675:

Tue May 19 00:57:48 2020 And we're on to (the unimplemented) lock code:

    135	    if (isRegisteredWithAnyITCs()) {
    Value returned is $203 = true
    (gdb) s
    136	      setEWSN(EWSN_AWLOCKS);
    (gdb) n
    140	    schedule(tq,0);   // NOW
    (gdb) n
    (gdb) c
    Continuing.
    247: WRN: Big MSPAST 48811
    248: WRN: Big deltams 616242 on update 6
    249: MSG:   ITC/WT:OPEN wrote 2 == 2
    250: MSG:   ITC/ET:OPEN wrote 2 == 2
    251: ERR: src/T2EventWindow.cpp:188: (timeout) XXX IMPLEMENT ME

:675]

:674]
[676:

Tue May 19 01:43:41 2020 OK now we're blowing up in AWLOCKS::timeout,
and we need an AWLOCKS packet to send.  And indeed here's where we
will need the yoink protocol.  I'm already thinking it's better to
minimize official state machine states even if that means adding more
miscellaneous state, so we'll remember our yoink-bit on the side
rather than thinking about AWLOCKS0 and AWLOCKS1 or whatever.

So, AWLOCKS::timeout.  How do we know this is the first time we've
gotten here?  Do we want to do locks-related inits before we set
AWLOCKS?

Also, AWLOCKS (and all EW -- as opposed to T2ITC -- intertile traffic)
is supposed to travel via channels, and all that code is unwritten.

Well, so what does a lock request carry?

  - ew center + radius
  - yoink bit

[677:

Tue May 19 01:53:25 2020 Referring to T2-PHF-15, it seems that AWLOCKS
would be equivalent/shipping as a 'Ring' packet.. ?  Now, all the
T2TIC packets go into the 'ITC state' XITC, so maybe all the active
EW stuff could go into one... no.. we need a channel number AND a
state number..

But we can still think of 'ring' as for an active lock request,
recognizing that we'll have to deal with mapping between circuit
packets and EWStateOps receive handlers.

[678:

Tue May 19 02:12:06 2020 So, ring.  We're on to byte[2] now.  Suppose
we just take the whole thing for ew state

byte[0]     byte[1]    byte[2]
0xc0|dir8   0x90|cn    0xf0|ewsn

where we're leading with an 0xf0 to limit the state number size and
reserve codes for the future.  Then we'll be on the byte[3] and beyond
for ewsn args.

Let's just set this much up.  We'll need a second level of handler in
T2ITC::tryHandlePacket to detect XITC==1.  Actually, let's detect
XITC==1..4 and dish for all of them.[679:

Tue May 19 02:18:20 2020 Actually let's commit first.[680:

Tue May 19 02:39:42 2020 Comitted.

:680]

:679]

:678]

:677]

:676]
[681:

Tue May 19 02:39:48 2020 So, actually it seems that perhaps Ring
really should be just for the AWLOCKS packet -- because that's the one
where there won't already be a passive EW allocated for the far end of
the circuit.

It seems like cache upds/acks is really too specific for XITC==3..4.
What we really want is something more like:

  ACTIVE INIT ==     1  handleCircuitPacket tries to allocate passive
  ACTIVE ONGOING ==  2  hCP delivers to existing passive
  PASSIVE ONGOING == 3  hCP delivers to existing active
  ACTIVE FINAL ==    4  hCP commits and releases existing passive?
  PASSIVE FINAL ==   5  hCP commits and releases existing active?

  (ITC RESERVED == 6)
  ITC STATE == 7

[682:

Tue May 19 02:53:36 2020 Not clear about 4 and 5..  Is FINAL
double-sided or not?

Also: We explicitly will need to abort an event in the case of race
lost.  That event will be associated with some active circuit, and
we'll have to unhog the sites it's holding, and so forth.

(And in fact we'll have had to locate that active event just to
resolve the race, so that's sort of logical.)
[683:

Tue May 19 03:39:20 2020 So.  Let's add a bool mYoinkValue to
T2EventWindow?  Is that really where it goes?  That is, after all,
the pointer that we'll be hogging the sites with, so..
[684:

Tue May 19 03:54:15 2020 But if we put it in the EW, then there'll
only be one yoink bit for potentially two separate ITC races.  It
wouldn't be hygienic to reuse the bit.

So maybe we say the yoink protocol is actually happening between a
pair of distinct circuits that are associated with a pair of distinct
EWs that happen to overlap on one or more sites.[685:

Tue May 19 04:19:40 2020 OK, moved mYoinkVal to T2ITC.

But here's a question: It seems to me there could be much more
complicated races than we have considered so far.  In particular, our
active EW 'X' could end up racing with TWO OR MORE active EWs 'Y' and
'Z' on the far side.  If we resolve the races pairwise, we could end
up with X beating Y but also Z beating X -- and then where are we?  If
we resolve Z-vs-X first then both Y and X can continue, but if we
resolve X-vs-Y first then only Z can continue.

And we can't tell which race to resolve first based on packet order,
because the single AWLOCKS X packet triggers both the races.  But we
have to resolve them in a systematic but isotropic way, so that both
ends will ultimately compute the same winners.

This Is An Issue!
[686:

Tue May 19 04:45:58 2020 This Really Is An Issue.  And it could be
even worse: Tile 1 window A might overlap with two EWs on tile 2 while
those tile 2 windows might also overlap with DIFFERENT EWs on Tile 1:

              +1A----++1B----+
              |      ||      |
          +------++---|--+   |
          |   |  ||  ||  |   |
          |   +--||--++------+
          |      ||      |
          +2C----++2D----+

Now, we'll have a systematic order that 1A and 1B were claimed.  So we
can count on the order they will arrive at Tile 2.  Same for 2C and 2D
arriving at Tile 1.

The fundamental problem is that losing a race destroys information.
If you lose a race you're gone, which means that you can't be around
to win some other race you would have won, under a different ordering.

Could we track the order that our side windows were claimed, so that
when a racing window appears from the other side, we can resolve it
against our windows from oldest to newest?

The idea is that the passive side will necessarily resolve races from
our older window before our newer one, because it will discover the
older-involved races first, since it will necessarily be handling the
older packet first.

So we'd have to scan the region the far side is asking to lock, and
assemble a list of EWs that own sites on it on our side.  Then we'd
have to order that list from oldest to newest in terms of our event
initiations.  Then we'd check the races in order, blowing up our EWs
or killing the incoming one according to yoink.

The far end would see our oldest overlapping request first.  It would
do what we just described on its side, checking its oldest overlapping
against our oldest overlapping, and it would get the same result as we
did.

Seems like it might work.  We might well be blowing up a lot of EWs,
and blowing up EWs that we 'could' have saved under some other
ordering, but that's got to be the price of admission.
[687:

Tue May 19 05:09:01 2020 But that raises another question: How does an
EW know when it can proceed?  How does it know there are no other
inbound races against it?  We were thinking with the yoink protocol we
wouldn't even have to wait for confirmation, because we could tell who
won locally.

But that's not the whole story.  We still have to confirm, so that
it's clear to the far side that all family business has been settled
and no further claims against this EW will be forthcoming.

So on the passive side we know when the race is resolved when we can
hog a region for some foreigner, and then send them an acknowledgment
that they have the lock.  And on the active side we know all races are
resolved when we receive acks from all the passive EWs.

[688:

Tue May 19 05:18:01 2020 I still feel like that's not quite
everything, though.  Still seems like we could get in a state where we
'confirmed' one remote request but then another one came in that
overlapped something some other way, and then we're going to want to
blow up the thing that we just confirmed.

:688]

:687]
:686]

:685]

:684]
:683]

:682]

:681]
[689:

Tue May 19 06:57:19 2020 So

 send on active circuit:
    LOCK + ctr + radius + nonce
 recv on corresponding passive circuit:
    LOCK + ack/nak

    -> Is it possible we don't have to send a NAK?  Because that can
       only be caused by a race and sender will detect the race and
       compute the NAK for itself.  But the ACK means there's no
       further risk of races on this circuit.  If that's true?

[690:

Tue May 19 09:17:35 2020 Off the jitsi with Jeff.

:690]


:689]
[691:

Tue May 19 14:30:18 2020 So, what do we do about the multiple
overlapping EW issue?

 - Do we believe the "resolve oldest-EW first" scheme really works?  I
   suspect maybe we do.

 - Do we believe we can/have to ack only successful EWs?

 - Do we believe there really is a time we can be sure an EW won't be
   blown up by anything incoming, and so can actually do it?

   = I guess the answer to that is 'When the ACK comes'.  But it's
     really 'when all the ACKs come'.  And it might get blown up by
     race loss with a third tile, after we get an ACK from a second
     tile, so we have to be able to still blow up from the active side
     even after getting an ACK from a passive side.

     The point of the ACK is that the passive side is saying 'This is
     OK by me, let me know when you commit or abort it'.

 - But doesn't that mean we have to process ALL the overlaps on the
   passive side before we respond to the OLDEST overlap?  And aren't
   we still vulnerable to cascading aborts as subsequent requests come
   in?

 - So maybe we don't want to be pairwise yoinking at the EW level at
   all.  Maybe we want to be 'yoinking in time', and saying everything
   after a race loser is deemed to 'happen after' the race winner.

   Once we know our EW wins against a particular partner tile --
   meaning active side processes an ack for that EW (really circuit)
   from that partner tile -- nothing that partner tile can do can
   change that.  If we're not waiting on any other tiles, we can
   commit that EW.

 - If, instead/before getting an ack, we get overlapping lock requests
   from that partner tile, we resolve them in order, getting the same
   answers the far side does.  Eventually either our EW will blow up,
   or we will receive an ack from that partner.

[692:

Tue May 19 15:13:34 2020 So it's:

 (1) ACTIVE REQUEST: Any side may blow this up
 (2) PASSIVE ACK:    That side may no longer blow this up
 (3) ACTIVE COMMIT:  This event cleared all sides and is done, upds included.
 (4) ACTIVE ABORT:   This event blew up due and is gone

 REQ -> ACK -> CMT
 REQ -> ACK -> ABT

  1AEW -> 2REQa
       -> 3REQ

  3AEW -> 1REQ

  2ACK -> 1AEW

:692]

:691]
[693:

Tue May 19 15:34:20 2020 Well I'm not sure how to (ASCII-)draw an
example, but this is seeming more plausible.  Am going to need
oldest-first resolution.

But getting to this level of understanding is really also suggesting
to me that the circuit level might be unnecessary.  We could just use
the EW slotnum in the circuitnum field.  Although now that I say
that.. EW slotnums are global to the tile, but circuitnums are local
to each ITC.  What advantage is there to knowing that if EW#12 is
talking to WT, it can't also be talking to SE?  So we could have a
larger pool of EWs to reuse but still have a smaller bitsize for
circuitnums.

But that raises yet another another issue: We also have the risk of
being unable to allocate a passive EW, because ours are all tied up
doing other things -- but the active side has no way of knowing that.

So the passive side does have to have some NAK mechanism at the very
least to say "I don't have an EW to give you for this, so no."

[694:

Tue May 19 15:49:50 2020 Could the passive EWs be statically allocated
on a per ITC basis?  So that each ITC has sixteen EWs just to play the
passive sides, so it would never need to NAK due to EW exhaustion?

Do we really need passive side EWs at all?  That was a 'clean'
approach, but what is it buying us?

 - Well for one thing, it provides us with a T2EventWindow * to put
   into mSiteOwners when we're hogging sites for a passive event.

   = But we could go with some other mechanism there.  Numbers instead
     of pointers; zero means unowned, positive P means owned by active
     EW P, negative N means..  What?  It can't be some per-ITC thing?

   = Could it be some little 'passive EW stub' that just has the
     ctr+radius, but no space for sites?  Saying we don't need to
     buffer passive side committed updates; we'll commit directly to
     the tile as cache upds come in, then unhog the region when
     they're done.

   = So we could say each ITC has an array of sixteen passive EW
     stubs, corresponding to the counterparty's sixteen active EWs.
     And we could use some unified base pointer that could point at
     either of those.. I guess the base class could have the ctr +
     radius, and then the active side subclass could add the sites.
     Then we hog regions with ptrs to base class either way.

[695:

Tue May 19 16:48:29 2020 Now, is the EW base class, or passive side,
TimeoutAble?  Or is that just for active EWs?  Base class, I'd think;
we'll need to have passive EWs wake up eventually for error recovery.

State machines, ditto?  We could split them or not, it seems.  Feels
cleaner to split them, if a lot more boilerplate.[696:

Tue May 19 17:47:27 2020 The only reason really to split them, though,
is for single-sides inequalities on state numbers.  Which really isn't
super compelling.  Move the state machine up to the base.

:696]

Time to cook dinner.

:695]

:694]

:693]
[697:

Wed May 20 01:00:32 2020 OK let's do the T2EW refactoring.  GO GO GO

[698:

Wed May 20 01:11:49 2020 aaand this is all to save a little space?
The essential difference between EWActive and EWPassive is the latter
doesn't have any sites?  How much space are we talking?  Like:

    #2  0x0045d3f0 in MFM::T2EventWindow::onTimeout (this=0x504d30, srcTq=...) at src/T2EventWindow.cpp:151
    151	    ops->timeout(*this, pb, srcTq);
    (gdb) p mSites[0]
    $206 = {m_atom = {<MFM::Atom<MFM::P3AtomConfig>> = {m_bits = {static BITS_PER_UNIT = 32, static ARRAY_LENGTH = 3,
            m_bits = {4294967168, 0, 0}}}, <No data fields>}, m_base = {m_base = {<MFM::Atom<MFM::P3AtomConfig>> = {
            m_bits = {static BITS_PER_UNIT = 32, static ARRAY_LENGTH = 3, m_bits = {4294967168, 0,
                0}}}, <No data fields>}, m_sensory = {m_touchSensor = {m_touchType = MFM::TOUCH_TYPE_NONE,
            m_lastTouchEventCount = 0}}, m_paint = 4278190080}, m_eventCount = 0, m_lastChangedEventCount = 0,
      m_lastEventNumber = 0, m_isLiveSite = true}
    (gdb) p sizeof(mSites[0])
    $207 = 88

Each OurT2Site is 88 bytes all in

    (gdb) p sizeof(mSites)
    $208 = 3608

Or under 4KB for the whole event window (41*88)

    (gdb) p 16*sizeof(mSites)
    $209 = 57728

Or under 60KB for 16 EWs in an ITC (16*3608)

    (gdb) p 6*16*sizeof(mSites)
    $210 = 346368

Or about 350KB for all the passive EWs on a tile.

    (gdb)

And we're currently at something like

    t2@beaglebone:~/T2-12$ top | head
    top - 01:17:19 up 6 days,  8:32,  2 users,  load average: 0.52, 0.13, 0.04
    Tasks:  96 total,   2 running,  94 sleeping,   0 stopped,   0 zombie
    %Cpu(s): 69.2 us, 30.8 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
    MiB Mem :    483.4 total,     73.2 free,    178.9 used,    231.2 buff/cache
    MiB Swap:      0.0 total,      0.0 free,      0.0 used.    293.4 avail Mem

So we've got something like 70-300MB available depending on how hard
you want to push the file cache buffers.

      PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    20739 root      20   0  103708  70304   4072 R  76.2  14.2   0:01.92 itcSpike12

And the native engine is currently eating under 15% of memory.

    20744 t2        20   0    9244   2472   2048 R   9.5   0.5   0:00.06 top
        1 root      20   0   31904   6940   5404 S   0.0   1.4   0:18.30 systemd
    t2@beaglebone:~/T2-12$

[699:

Wed May 20 01:20:33 2020 So, obviously: Screw the refactoring.  Let's
just put sixteen more full-on event windows in each ITC, so they'll
always be available for passive sides.[700:

Wed May 20 02:40:28 2020 OK, we have passive ews sitting in the
T2ITCs.  Over an hour: Why on earth did that take so long?

Anyway, now we're blowing up in the AWLOCKS timeout.[701:

Wed May 20 02:45:01 2020 So how are we going to structure the
OLDEST-RACE-FIRST overlap detection?  Let's just try to identify the
players.

 - T2ITC::tryHandlePacket dishes to handleCircuitPacket

 - [703: Wed May 20 03:20:42 2020 handleCircuitPacket will discover
   it's looking at a lock request and dish to handleLockRequest or
   something

 - handleLockRequest will scan the requested neighborhood and note any
   already-existing-owners, recording them in an array or something.

 - Whenever an active EW request is made, some kind of time stamp is
   captured, for 'OLDEST-RACE' ordering.  What should that be?  Should
   we create a uniqueNow() like ccr has?  Does this ordering have to
   apply between itcs or just within one?  [704: Wed May 20 04:32:50
   2020  Just within an ITC, right?  If we're really only dealing with
   races, we can only run into other owners that just sent requests to
   us.  So we could keep a packet-shipped-number?  And even not worry
   about it wrapping, so long as we have timeouts that will flush
   fogged-up EWs or whatever long before wrapping could cause our
   answer to go wrong.   Let's try that.  :704]

:703]

:701]

:700]

:699]

:698]

:697]
[702:

Wed May 20 03:03:53 2020 If we limited ourselves to 16 active windows
per tile we could, once again, ditch the circuits and just use
ewslotnums.  Right?

And I do know an interesting property of this whole scheme: It's easy
enough to imagine all EWs getting tied up in intertile protocols -- in
which case there'd be no way even to run HIDDEN events, and that would
'naturally' reduce the hidden site advantage.  At the cost of somewhat
reducing the tile event rate, of course.

:702]
[705:

Wed May 20 04:46:24 2020 Hmm could we just keep the EWs registered on
an ITC in like a list or something in oldest-first order?  Is there
any case where time-of-registration would compare differently than
time-of-lock-request? [706:

Wed May 20 04:50:41 2020 Well it appears we're not actually sending
any lock requests yet, so there's no place to call getPacketsShipped()
to pick up for comparison. [707:

Wed May 20 04:59:44 2020 But let's build comparison plumbing into T2EW
  anyway..[708:

Wed May 20 05:00:55 2020 So how can the sequence number be on the
T2EventWindow, if the T2 event window might be associated with
two ITCs?  It really has to be associated with the combination of an
ITC and an EW.[709:

Wed May 20 05:06:14 2020 The ITC has T2EW * mRegisteredEWs[], we could
expand that to a little struct and stick a mLockSequenceNumber in
there.  But if we're putting the T2EW * in site owners, we'd still
have to map back to that little struct somehow.  We could put

 u32 mLockSequenceNumber[ITC_COUNT];

in the T2EWs and be done with it that way.[710:

Wed May 20 06:21:14 2020 OK we added

    void captureLockSequenceNumber(T2ITC& itc) ;
    void clearLockSequenceNumbers() ;
    u32 getLockSequenceNumber(Dir6 dir6) ;

    u32 mLockSequenceNumber[DIR6_COUNT];

in T2EventWindow.h.  But nobody's using any of it yet.

[711:

Wed May 20 06:24:10 2020 OK, so, what could be our next steps here?

 - Continue with the :700: path.
[713:

Wed May 20 14:32:48 2020 OK, trying to move on this.  But what is the
lock request packet format?  We still haven't sent one.[714:

Wed May 20 14:37:08 2020 Let's say it's TO AINIT that sends the lock
requests.  It'll be like

 XITC == [0xc0|dir8] + [001/'Ring' + cn] + [x:s8] + [y:s8] + [(yoink:u1<<7)|radius:u3]

for five bytes total?  [715:

Wed May 20 14:53:16 2020 And what really is the advantage of waiting
until TO AINIT?  Why just not ship them as part of
tryInitiateActiveEvent?  We thought TO was going to be nice because
we'd have an outbound T2PacketBuffer set up for us.. but we need to
send potentially multiple packets, with different contents, so that's
not a big win.  Let's just send them.

:715]



:714]

:713]
   = Get to handleLockRequest.
     - I guess set up the passive EW right away, so it can win or lose
       races.
     - Scan the hood.
     - Find overlapping active EWs.  Order them by

          time_before(ew1.getLockSequenceNumber(mDir6),
                      ew2.getLockSequenceNumber(mDir6));

     - Iterate in oldest-race-first order, calling
       resolveRace(ew1,ew2)

 - Figure out what resolveRace does

   = Where is the yoink bit at present?  Should be the same place as
     the lock sequence number, right?[712: Wed May 20 07:51:24 2020
     It's in the Circuit struct, which could be a candidate for the
     lock sequence, modulo the same old T2EW->Circuit lookup issue
     :712]

   = Figure out how actually to blow up a pending ew -- active or
     passive -- unhogging its sites and freeing all its resources.



:711]

:710]

:709]

:708]

:707]

:706]

:705]
[716:

Wed May 20 16:09:29 2020 OK, how do we find the far-side itc origin in
our tile coords?  Is it the position of the associated cache rect?
Maybe.[717:

Wed May 20 16:54:08 2020 So, we've been using UPoint for eventwindow
centers, but that's wrong for passive EWs, since the CENTER might be
all the way off tile for us -- center coords could be negative, and it
just be with the radius that it reaches into our cache or visible.  So
we'll need to redo assignCenter and the data member, I think.[718:

Wed May 20 17:09:09 2020 OK, I'm fading here; time to go deal with
dinner.  Current status:

 - We're building again

 - We're sending a lock request (first one got out okay)

 - Second iteration in trySendLockRequests is getting non-zero for
   mITC but U8_MAX for mCircuitNum, which is blowing up getYoinkVal.

Pick up there.
[719:

Thu May 21 00:00:36 2020 Realized over dinner the problem is NW is on
mCircuits but .mCircuitNum is uninitted because NW is SHUT.[720:

Thu May 21 00:05:23 2020 OK that's better.  Now we're dying INCOMPLETE
CODE in TO AWLOCKS, which, at least, is totally true.  It might not be
the next blow-up we were expecting, though..  What did we use for a
timeout when we when it ITCSN_AWLOCKS?[721:

Thu May 21 00:09:28 2020 Ah bug: Passed a WC waitcode to schedule(),
which treated it like a ms.  Wanted to be calling scheduleWait().
Bummer the types coerced silently.

[722:

Thu May 21 00:11:35 2020 Moving scheduleWait and the waitcodes from
T2ITC.h up to TimeoutAble.h.[723:

Thu May 21 01:06:19 2020 Ugh how much time did I just lose?  Almost an
hour, gaaah: The vast majority of which was debugging an apparent
infinite loop on startup.. that turned out to be caused by a
newly-created call on scheduleWait inside the KITCPoller() ctor.  Why
is that a problem?  Because scheduleWait uses T2Tile::get() to get at
the TimeQueue via the tile singleton.  So?  Well, the KITCPoller ctor
runs WHILE WE'RE ALREADY INSIDE T2Tile::get(), as the static T2Tile
ctor runs.

Grrrrr.[724:

Thu May 21 01:10:58 2020 Why don't we give every TimeoutAble a
TimeQueue& mBaseTQ or something, and rewrite all these effen functions
to NOT take a TimeQueue& at all?

When we set all this up, we we're imagining TimeoutAble's would be
moving between different TQs at different times for different
purposes, but we're really not seeing that.  We want everything on the
master TQ so dispatching is all consistent and we can't have 'time
inversions' where something in the past is stuck waiting to be
dispatched by something else that's in the future.

[725:

Thu May 21 01:47:59 2020 Well, started to change all the APIs and then
backed it all out: Having a no-arg ctor for TimeoutAble is just too
valuable, and counting on somebody to set up a 'permanent' TQ later is
just too gross.

Instead I went the other way: Now if anybody calls T2Tile::get() while
the T2Tile ctor is running, we blow up real good, with a message to
stderr and a FAIL that we can break on and see the offending call on
the call stack immediately.

:725]

:724]

:723]

:722]

:721]

:720]

:719]
:718]

:717]

:716]
[726:

Thu May 21 01:52:25 2020 So now we're back to needing code for TO
AWLOCKS?  Still?  Shouldn't somebody have gotten a packet we sent,
before that?[727:

Thu May 21 02:06:25 2020 OK it's now clear that we're writing a
five-byte lock request, but it's not getting delivered for some
reason..  So eventually TO AWLOCKS hits, as it must.[728:

Thu May 21 02:09:42 2020 Is our lock request packet fogged up?  Yes I
think it is.  We're sending a 0xc0|mDir8 but it should be an
0xa0|mDir8, right?  Doh.  Going again.  (And grrr, by the way, too.
Why am I still generating byte[0] headers by hand????)[729:

Thu May 21 02:14:01 2020 Geez byte[1] was fogged up too.[730:

Thu May 21 02:15:05 2020 OK FINALLY we're hitting
handleCircuitPacket. [731:

Thu May 21 02:18:29 2020 And we're dying here:

    144	  void T2EventWindow::initPassive(SPoint ctr, u32 radius, bool yoink) {
    145	    assignCenter(ctr, radius, false);
    146	    FAIL(INCOMPLETE_CODE); // XXX WHERE TO STICK THE YOINK
    147	  }

and what's the answer to that comment?  [732:

Thu May 21 02:50:21 2020 Well, it's got to be on a Circuit because
that's where mYoinkVal is.  And T2ITC has a whole rack of passive
Circuits in mCircuits[0].  So that's where it ought to go, right?  And
the passive circuit number just matches the active that we got from
the packet..[733:

Thu May 21 04:24:03 2020 OK, we've gotten past
checkSiteAvailabilityForPassive, and theoretically we've even hogged
the region for the remote guy.  Maybe we should watch that once before
pushing on.
[734:

Thu May 21 04:42:30 2020 Well, it looks plausible enough in the
non-race condition, which is all we can observe in the current setup
(having only one non-Empty atom in the whole universe.)

What happens on the passive side after we hog the region for the
remote?  We reply with an ACK, I guess.  How is that going to work?
Well, what state is this passive guy in?[735:

Thu May 21 05:04:49 2020 It's currently in EWSN_PINIT.  Actually we're
not really dispatching on received EW states, yet.  We're dispatching
on XITC types.  Could we change 'Hang up' to 'Connect' or 'Answer',
and send that?

Well let's send XITC==2 to mean ACK, for now anyway.[736:

Thu May 21 06:17:19 2020 OK, so the ACK has arrived and

    3336: DBG: ITC/WT:OPEN: Recv 2/0xA6
    3337: DBG: ITC/WT:OPEN: Enter HCP
    3338: DBG: ITC/WT:OPEN: Enter HAP
    3339: MSG: ITC/WT:OPEN EW26/AWLOCKS HAP

we successfully mapped it back to the EW that's in EWLOCKS.  So I
guess it's time to bump it?  Let TO AWLOCKS check and discover that
it's got everything it wished for?[737:

Thu May 21 06:24:40 2020 No, we're not supposed to bump until all the
locks are known.  How do we record an ACK from a counterparty?  We
want to call something on T2EventWindow and let it store that
information, and bump itself if it wants to.[738:

Thu May 21 06:51:44 2020 OK, we're incomplete in
T2EventWindow::handleACK now, but I'm running out of gas.  Thinking
CircuitInfo in T2EW.h could handle the extra state?

:738]

:737]

:736]

:735]

:734]
:733]

:732]

:731]

:730]

:729]

:728]

:727]

:726]
[739:

Thu May 21 14:05:04 2020 OK!  We have FINALLY reached ABEHAVE while
holding a NATIVE ENGINE INTERTILE PRECISION LOCK!

[740:

Thu May 21 14:45:45 2020 OK so we need to break for a meeting in a
couple minutes, but we're very close to a phony legit event transition
here.  Right now it appears the event window is full of Empty.  Did we
ever load up the sites?  I think we didn't, we just set mSiteOwners so
that nobody else would touch them.

So I guess executeEvent should load up the sites..


:740]

:739]
[741:

Thu May 21 17:15:15 2020 OK, after meeting.  It's time to send out
cache updates.

But first it's time to move the flag.

Committing.

:741]
[742:

Thu May 21 23:47:41 2020 OK have to have to finish reviewing but so
close to an intertile event here..  I guess we need yet more Circuit
state -- per ITC*EW combo -- to track what we've sent, just like we
used a persistent iterator to track what we'd sent in the cache sync
process.

:742]
[743:

Fri May 22 04:08:55 2020 OK now allegedly generating cache updates
after the event transition..  We shall see.[744:

Fri May 22 04:12:42 2020 OK, it appears we've shipped the cache
updates plus its terminating packet:

    3345: MSG: EW30/AWLOCKS hACK ITC/WT:OPEN
    3346: MSG:   ITC/WT:OPEN wrote 28 == 28
    3347: MSG:   ITC/WT:OPEN wrote 2 == 2

and now we're blowing up on what comes after that:

    522	    if (ew.trySendCacheUpdates()) { // True when all have been shipped to all
    523	      FAIL(INCOMPLETE_CODE);

So.  What does come after that?  Do we wait for the far end to hang
up, or do we commit now?  Since we're the active side, we should
probably wait for ACKs..  So we go to AWACKS?  And we reset the
circuitinfo as we get final acks from them, so when we're done the
event looks like a local one and we go to ACOMMIT?  We'll see.[745:

Fri May 22 06:43:20 2020 OK, now we've apparently applied a cache
update to a passive event window:

    3343: DBG: ITC/ET:OPEN: Recv 28/0xA2
    3344: DBG: ITC/ET:OPEN: Enter HCP
    3345: DBG: ITC/ET:OPEN: Enter HCUP

and then gotten the empty end-of-update packet:

    3346: DBG: ITC/ET:OPEN: Recv 2/0xA2
    3347: DBG: ITC/ET:OPEN: Enter HCP
    3348: DBG: ITC/ET:OPEN: Enter HCUP
 ..
    334
    335	    if (count == 0) { // Final update packet
    336	      FAIL(INCOMPLETE_CODE);

and now we need to know what to do next.  And that should be:

 - Store the passive EW to the tile

 - Hang up the circuit somehow from the passive, which sends a final
   packet and releases the passive resources

 - Recv the hang up notification, which causes the active EW to clean
   up that circuit and remove it from its mCircuits.

 - And then, if that's the last circuit in the active EW, we commit it
   and release the active side resources.  Doesn't seem like there's a
   real reason to have an ACOMMIT or PCOMMIT state in the machine,
   because neither should need to block and neither sends a packet.

:745]

:744]

:743]
[746:

Sat May 23 03:37:38 2020 OK let's take another run at this.  Store the
passive EW to the tile GO GO GO

:746]
[747:

Sat May 23 05:03:16 2020 OK we may have stored the passiveEW to the
tile (did we ever load the passive from the tile?  That seems like a
waste given we could just keep track of that sites came from the
active side, and only compare them when storing back.  Anyway.)

But the immediate question is how do we now 'hang up' on the T2ITC
side of things.  We think we need to:

 - Send a HANG UP packet, XITC type 5

 - Unhog the passiveEW region

 - Reset the ITC circuit info back to unused

 - Reset the passive EW back to unused.

There'll be more to do once the HANG UP reaches the active side, but
step by step..[748:

Sat May 23 05:43:43 2020 So a minor issue at the moment is what do we
do if the attempt to send the hang up fails due to buffer space or
whatever?  If we used the separate PCOMMIT state we could try again in
TO PCOMMIT or whatever, but we were claiming we didn't need to do
that.

:748]

:747]
[749:

Sat May 23 06:13:52 2020 OK, so I'm in T2EW::commitPassiveEWAndHangUp,
and I'm trying to find the circuit this passive EW is associated with,
but neither of them are set up.  Should they be, or should I not be
looking at them?

:749]
[750:

Sat May 23 07:14:56 2020 OK, now we've received the HANG UP packet
back on the active side.

 ..
    3355: MSG: EW06-ET/PINIT PASSIVE DONE
    3356: DBG: ITC/WT:OPEN: Recv 2/0xA6
    3357: DBG: ITC/WT:OPEN: Enter HCP

    Thread 1 "itcSpike12" hit Breakpoint 1, MFMLongJmpHere (buffer=0xbefff928,
        toThrow=1) at src/FailPlatformSpecific.cpp:48
    48	    longjmp(buffer,toThrow);
    (gdb) up
    #1  0x00465e62 in MFM::T2ITC::handleCircuitPacket (
        this=0x4c5eb8 <MFM::T2Tile::get()::THE_INSTANCE+3768>, pb=...)
        at src/T2ITC.cpp:137
    137	      FAIL(INCOMPLETE_CODE);
    (gdb) l
    132	      */
    133	    case 4: // TALK: Send updates
    134	      handleCacheUpdatesPacket(pb);
    135	      break;
    136	    case 5: // HANG UP: Release lock
    137	      FAIL(INCOMPLETE_CODE);
    138	      break;
    139	    }
    140	  }
    141
    (gdb)

That means that next up it's time to write the LAST FOGGEN PIECE OF
THE UNCONTESTED INTERTILE EVENT SEQUENCE.

But first sleep.

:750]
[751:

Sat May 23 11:47:02 2020 OK so we're into T2ITC::handleHangUpPacket.
I guess maybe we call the activeEW to commit and clean up first --
cleaning up the EW side CircuitInfo, and then tear down the ITC
circuit last?  That seems backwards: We created the activeEW first and
then got an ITC circuit for it, so we should tear it down in reverse.
So:

 - Tear down T2ITC side circuit info (unregisterITC?)

 - Tell the activeEW that this circuit is done.

 - ActiveEW removes that circuit from its mCircuits.  If the activeEW
   then determines that was the last ack, it commits, and (goes to
   T2Tile to) freeEW itself.

Something like that. GO GO GO[752:

Sat May 23 12:47:03 2020 Well, the putative 'Last Piece Of The Puzzle'
just built clean for the first time.  It can't work, right?  Trying
it.[753:

Sat May 23 12:48:24 2020 It didn't :).  Blew up in TO AWACKS, but not
clear if that was due to breakpoints or something more real..  Going
again. [754:

Sat May 23 12:50:36 2020 Seems repeatable.  Here's what I'm looking
at, for 'the historical documents' natch:

 ..
    3321: MSG:   ITC/ET:CACHEXG wrote 2 == 2
    3322: MSG: ->ITC/ET:OPEN
    3323: MSG:   ITC/WT:CACHEXG wrote 2 == 2
    3324: MSG: ->ITC/WT:OPEN

Picking up the story as the ITCs finish their cache exchanges and get
to open.

    3325: DBG: ITC/ET:OPEN: Recv 2/0xA2
    3326: DBG: ITC/WT:OPEN: Recv 2/0xA6
    3327: MSG:   ITC/ET:OPEN wrote 2 == 2
    3328: MSG:   ITC/WT:OPEN wrote 5 == 5

WT sends a Ring packet to request a lock.

    3329: MSG:   ITC/WT:OPEN wrote 2 == 2
    3330: DBG: ITC/ET:OPEN: Recv 5/0xA2
    3331: DBG: ITC/ET:OPEN: Enter HCP
    3332: DBG: ITC/ET:OPEN: Enter HRP

ET goes to handleRingPacket,

    3333: MSG:   ITC/ET:OPEN wrote 2 == 2

and sends an ACK packet granting the lock.

    3334: DBG: ITC/ET:OPEN: Recv 2/0xA2
    3335: DBG: ITC/WT:OPEN: Recv 2/0xA6
    3336: DBG: ITC/WT:OPEN: Recv 2/0xA6
    3337: DBG: ITC/WT:OPEN: Enter HCP
    3338: DBG: ITC/WT:OPEN: Enter HAP

WT enters handleAnswerPacket

    3339: MSG: ITC/WT:OPEN EW29-/AWLOCKS HAP

What's the deal with that 'EW29-/'?  Looks like something missing?
After the '-' is supposed to be.. the getCategory().  What is that
again now?  It's some random const char * mCategory; in T2EW?  Who
sets it up?  T2EW ctor sets it up!  Who called the T2EW ctor here?

Ah, T2Tile::earlyInit called it:

        mEWs[i] = new T2EventWindow(*this, i, "");

and that certainly explains the empty category.  Should we make it
"AC" for active?  "AT" for active tile?  All the other categories are
the Dir6 names ET..NE.  Let's say "AC".  But pushing on:

    3340: MSG: EW29-/AWLOCKS hACK ITC/WT:OPEN

T2ITC::handleAnswerPacket dishes to T2EW::handleACK

    3341: WRN: Big deltams 227 on update 16

Hopefully these go away once we're compiling with optimizations again.

Anyway, somewhere in here handleACK bumped EW29, which discovered it
had all the locks it needed, so it went to state ABEHAVE, which
actually EXECUTED THE DANG EVENT, and then went to ASCACHE..

    3342: MSG:   ITC/WT:OPEN wrote 28 == 28

..which wrote a cache update packet reporting that two atoms had
changed.

    3343: MSG:   ITC/WT:OPEN wrote 2 == 2

And wrote an empty cache update packet behind it to signal the end.

    3344: DBG: ITC/ET:OPEN: Recv 28/0xA2
    3345: DBG: ITC/ET:OPEN: Enter HCP
    3346: DBG: ITC/ET:OPEN: Enter HCUP

ET receives the updates and (we believe) applies them to its passive
EW.

    3347: DBG: ITC/ET:OPEN: Recv 2/0xA2
    3348: DBG: ITC/ET:OPEN: Enter HCP
    3349: DBG: ITC/ET:OPEN: Enter HCUP

And receives the end-of-update packet

    3350: MSG: EW01-ET/PWCACHE (ITC/ET:OPEN) cPEWAHU

Which triggers commitPassiveEWAndHangUp!  (And NobodyFishInTheMiddle).

    3351: MSG:   ITC/ET:OPEN wrote 2 == 2

After applying the remote update, ET sends the Hang Up packet.

    3352: MSG: EW01-ET/PINIT PASSIVE DONE

And the passive side of this event is done.

    3353: DBG: ITC/WT:OPEN: Recv 2/0xA6
    3354: DBG: ITC/WT:OPEN: Enter HCP
    3355: DBG: ITC/WT:OPEN: Enter HUP
    3356: MSG: EW29-/AWACKS hHU ITC/WT:OPEN

WT receives that last packet and gets to T2EW::handleHangUp.  Which we
thought would discover it's all done, and commit on the active side
and free itself..

    Thread 1 "itcSpike12" hit Breakpoint 1, MFMLongJmpHere (buffer=0xbefff928,
        toThrow=1) at src/FailPlatformSpecific.cpp:48
    48	    longjmp(buffer,toThrow);
    (gdb) up
    #1  0x004631d2 in MFM::T2EWStateOps_AWACKS::timeout (
        this=0x4c5668 <MFM::singletonT2EWStateOps_AWACKS>, ew=..., pb=...,
        tq=...) at src/T2EventWindow.cpp:689
    689	    FAIL(INCOMPLETE_CODE);
    (gdb)

..but that appears not to have happened.  Looks like maybe it thought
there was more to do, but there actually wasn't, so nothing else
happened until TO AWACKS went bang.

[755:

Sat May 23 13:22:01 2020 So that was the first plausible try at an
intertile event via loopback in the T2 native engine.  Let's go again
and try to watch T2EW::handleHangUp in action.[756:

Sat May 23 13:24:02 2020 And almost surely the problem is we're
cleaning up the ET-WT circuit, but not the NW 'circuit' -- which
doesn't actually exist (since NW is SHUT), but there is CircuitInfo
for it in the active EW.[757:

Sat May 23 13:26:14 2020 Yeah, that's it.  How do we want to handle
this?  In particular, did we really even want to set up
EW::CircuitInfo for a ITC that's SHUT?  We did need to register the EW
with the ITC for the EWDRAIN scenario, but does the EW need to know
about that?

With the current scheme, it seems like we'd have to do another scan to
decide if we had only unallocated circuits in mCircuits, and if so,
release them too?  Ugh?!

:757]

:756]

:755]

:754]

:753]

:752]

:751]
 [758:

Sat May 23 13:43:15 2020 OK going again..[759:

Sat May 23 13:45:11 2020 Aaand the atom is gone!  Gone from the WT,
but nowhere to be seen in the ET!  Ono it's a transporter malfunction!

Yes yes, the atom died, very sad.  Thoughts and prayers.

But: What a tremendous success for the project!

I was certainly expecting to have all sorts of coord-transformation
issues, and that's the inside-track suspicion here.  Let's look closer
at the passive-side cache update packet handling.
[760:

Sat May 23 13:57:40 2020 OK, had a

      OurT2Site site = mSites[sn];

that wanted to be

      OurT2Site & site = mSites[sn];

which could totally be the problem.  Going again.

:760]
:759]

:758]
[761:

Sat May 23 14:09:40 2020 SUCCESS!  First intertile event on loopback
using the native engine achieved!  The DReg-not-DReg-GoWest atom went
out the west and came back in via the east.  Yay!

Not only that, it actually did like three more events before things
blew up!

Here's where it died:

    3423: MSG: EW07-WT/PWCACHE (ITC/WT:OPEN) cPEWAHU
    3424: MSG:   ITC/WT:OPEN wrote 2 == 2
    3425: MSG: EW07-WT/PINIT PASSIVE DONE
    3426: DBG: ITC/ET:OPEN: Recv 2/0xA2
    3427: DBG: ITC/ET:OPEN: Enter HCP
    3428: DBG: ITC/ET:OPEN: Enter HUP
    3429: MSG: EW27-AC/AWACKS hHU ITC/ET:OPEN
    3430: MSG:   ITC/ET:OPEN wrote 5 == 5
    3431: DBG: ITC/WT:OPEN: Recv 5/0xA6
    3432: DBG: ITC/WT:OPEN: Enter HCP
    3433: DBG: ITC/WT:OPEN: Enter HRP
    itcSpike12: src/T2EventWindow.cpp:339: void MFM::T2EventWindow::assignCenter(MFM::SPoint, MFM::u32, bool): Assertion `mRadius == 0' failed.

    Thread 1 "itcSpike12" received signal SIGABRT, Aborted.
    0xb6c07746 in ?? ()
    (gdb) up
    #1  0xb6c150ae in ?? ()
    (gdb)

So it died because an EW was being initted but it didn't have an
mRadius of 0.  Which is totally believable that I failed to clear
something somewhere.  Let's see if we can't catch it in the act.[762:

Sat May 23 14:34:17 2020 This time it looks like we have some kind of
race where an active EW gets into AWLOCKS, but nobody sees the Ring
packet, or something.  Expanding debug output and going again.

:762]

:761]
[763:

Sat May 23 15:18:13 2020 Looks like we've gotten our active EW into
state AWACKS when there are in fact no ACKS to be waiting for, because
we did not in fact need any locks..  How did that happen?[764:

Sat May 23 15:21:04 2020 Hmm, it LOOKS like the only place we go to
AWACKS is:

  void T2EWStateOps_ASCACHE::timeout(T2EventWindow & ew, T2PacketBuffer & pb, TimeQueue& tq) {
    if (ew.trySendCacheUpdates()) { // True when all have been shipped to all
      ew.setEWSN(EWSN_AWACKS);
 ..

which means we must have been in ASCACHE.  And how would we have
gotten there?  Perhaps this:

    if (ew.executeEvent()) {
      if (ew.isRegisteredWithAnyITCs())  // XXX IS THIS THE RIGHT PREDICATE?
        ew.setEWSN(EWSN_ASCACHE);
      else

in TO ABEHAVE??  With an XXX comment and everything how nice.

What does isRegisteredWithAnyITCs actually check?  Yes, it does this:

  bool T2EventWindow::isRegisteredWithAnyITCs() {
    for (u32 i = 0; i < MAX_CIRCUITS_PER_EW; ++i) {
      if (mCircuits[i].mITC != 0) return true;
    }

meaning it will return true for registered-but-SHUT ITCs, and our
observed behavior is explained.

Aaaand so what predicate do we WANT there?[765:

Sat May 23 15:28:09 2020 Well, made bool T2EW::hasAnyLocks();
switching to that in TO ABEHAVE.

:765]

:764]

:763]
[766:

Sat May 23 16:05:55 2020 OK we also have, in part, this:

  ..
      bool T2EventWindow::tryInitiateActiveEvent(UPoint center,u32 radius) {
        assignCenter(MakeSigned(center), radius, true);
  ..
        takeOwnershipOfRegion();
        if (isRegisteredWithAnyITCs()) {
          if (!trySendLockRequests()) return false; // WTF?
          setEWSN(EWSN_AWLOCKS);
          scheduleWait(WC_LONG);
        } else {
          setEWSN(EWSN_ABEHAVE);
          scheduleWait(WC_NOW);
        }

and the isRegisteredWithAnyITCs is going to send us into that first
branch, going to AWLOCKS, even if we don't need any locks.  That's
currently causing all non-locking events to have a WC_LONG delay,
followed, apparently, by the discovery that no locks are needed, so
the event actually eventually succeeds.[767:

Sat May 23 16:10:23 2020 Switching it to

 ..
    takeOwnershipOfRegion();
    if (needsAnyLocks()) {
      if (!trySendLockRequests()) return false; // WTF?
 ..

:767]

:766]
[768:

Sat May 23 16:16:59 2020 Well, we just observed multiple full passes
of our GoWest bein going across the tile and around on loopback, and
then it hit TO AWACKS after 3K+ messages:

    43389: DBG: ITC/ET:OPEN: Enter HAP
    43390: MSG: ITC/ET:OPEN EW28-AC/AWLOCKS HAP
    43391: MSG: EW28-AC/AWLOCKS hACK ITC/ET:OPEN
    43392: DBG:   ITC/ET:OPEN wrote 28/0xA2 0xC3 ...== 28
    43393: DBG:   ITC/ET:OPEN wrote 2/0xA2 0xC3== 2
    43394: DBG: ITC/WT:OPEN: Recv 28/0xA6 0xC3 ...
    43395: DBG: ITC/WT:OPEN: Enter HCUP
    43396: DBG: ITC/WT:OPEN: Recv 2/0xA6 0xC3
    43397: DBG: ITC/WT:OPEN: Enter HCUP
    43398: MSG: EW03-WT/PWCACHE (ITC/WT:OPEN) cPEWAHU
    43399: DBG:   ITC/WT:OPEN wrote 2/0xA6 0xD3== 2
    43400: MSG: EW03-WT/PINIT PASSIVE DONE

    Thread 1 "itcSpike12" hit Breakpoint 1, MFMLongJmpHere (buffer=0xbefff928,
        toThrow=1) at src/FailPlatformSpecific.cpp:48
    48	    longjmp(buffer,toThrow);
    (gdb) up
    #1  0x004634aa in MFM::T2EWStateOps_AWACKS::timeout (
        this=0x4c5668 <MFM::singletonT2EWStateOps_AWACKS>, ew=..., pb=...,
        tq=...) at src/T2EventWindow.cpp:732
    732	    FAIL(INCOMPLETE_CODE);
    (gdb) p ew.getName()
    $56 = 0x4fa550 <MFM::T2EventWindow::getName() const::buf> "EW28-AC/AWACKS"
    (gdb)

which might actually be a flat-out genuine race, at this point, what
with all the debug messages and such.  What did I set the AWACKS
timeout to?[769:

Sat May 23 16:24:06 2020 WC_HALF == 150ms.  Yeah, let's try WC_FULL.

:769]

:768]
[770:

Sat May 23 16:28:37 2020 Well, all giant payoff, big progress, for all
the tons that still remain to be done.  Have to get off to cooking
dinner but trying one more mod -- making the bein check if West is
live before going that way.  If it works, we 'should' be able to pull
the loopback and have the bein stop at the edge, then start again
after we replug the cable.

Yeah right!  I'm so sure!

Let's try it!
[771:

Sat May 23 16:31:48 2020 Bein's going nowhere.  Suspecting that
T2EW::mSitesLive is not getting set up correctly.

Pick up there next time.
[772:

Sun May 24 00:10:20 2020 OK let's take a look at mSitesLive stuff.
[773:

Sun May 24 00:11:17 2020 So right now in checkSiteAvailability, we
see:

      if (!T2_SITE_IS_VISIBLE_OR_CACHE(usite.GetX(),usite.GetY())) {
        mSitesLive[sn] = true; // Hidden sites are good to go
        continue;
      }

which is fine as far as it goes, but it's not enough.  But we also
see:

      // For cache and visible, also assess and accumulate ITC involvements
      bool isLive = true;
      for (u32 dir6 = 0; dir6 < DIR6_COUNT; ++dir6) {
        if (tile.getVisibleAndCacheRect(dir6).Contains(site)) {
          T2ITC & itc = tile.getITC(dir6);
          if (!itc.isVisibleUsable()) return false; // Sorry folks, this exhibit is closed
          registerWithITCIfNeeded(itc);
          if (T2_SITE_IS_CACHE(usite.GetX(),usite.GetY()) && !itc.isCacheUsable())
            isLive = false; // Exhibit's working but that site is currently dead
        }
      }
      if (isLive) mSitesLive[sn] = true;

so why isn't that working?  Let's watch it.[774:

Sun May 24 00:21:14 2020 OK it's a thinko I think.  In that loop
above, we're getting to

          if (T2_SITE_IS_CACHE(usite.GetX(),usite.GetY()) && !itc.isCacheUsable())
            isLive = false; // Exhibit's working but that site is currently dead
with the NW itc:

    (gdb) p itc.getName()
    $65 = 0x4fa5e0 <MFM::T2ITC::getName() const::buf> "ITC/NW:SHUT"
    (gdb) p usite
    $66 = {m_x = 3, m_y = 4}
    (gdb)

which is, we thought correctly, saying:

    (gdb) p itc.isCacheUsable()
    $63 = false
    (gdb)

because it is SHUT.  But cache is only usable if the ITC is OPEN, due
to the explicit XX arg in the T2ITC state machine tables

                 vvv
  /*   name   vz,ch,mc,to,rc,sb,desc */                          \
  XX(SHUT,     1, 0, 0, 1, 1, 0, "EWs running locally")          \
  XX(DRAIN,    0, 0, 0, 1, 0, 0, "drain EWs to settle cache")    \
  XX(CACHEXG,  0, 0, 2, 1, 1, 0, "exchange cache atoms")         \
  XX(OPEN,     1, 1, 2, 1, 1, 0, "intertile EWs active")         \
                 ^^^

So ITC/NW:SHUT seems certainly on solid ground saying its cache is not
usable.

But

    (gdb) p usite
    $66 = {m_x = 3, m_y = 4}

isn't part of the NW cache, now is it?  Consider the upper left of our
:636: figure, which we never expected to look at ever again:

        +01234-------
        0oooooooooooo
        1oooooooooooo
        2oooooooooooo
        3oooooooooooo
        4aaaaeeeegggg
        5aaaaeeeegggg
     ..

      a:WT cache    i:NE&ET vis  p:NE cache
     ..
      g:NW vis      o:NW cache
     ..

(3,4) is code 'a', not code 'o'.

I guess the problem is we need another condition.  The main guard on
the per-ITC loop is:

        if (tile.getVisibleAndCacheRect(dir6).Contains(site)) {

which says we need to do more work for sites that are EITHER cache or
visible relative to the given dir6.  And that's right because we need
to register with the dir6 ITC in either case.  But then the first
clause of this is not specific enough:

          if (T2_SITE_IS_CACHE(usite.GetX(),usite.GetY()) && !itc.isCacheUsable())

It's not enough to ask if usite is in the cache of this whole T2 tile;
we need to ask: Is usite in THE PART OF the cache THAT'S OWNED BY ITC?

[775:

Sun May 24 00:39:57 2020 Yes.  So how do we answer that?[776:

Sun May 24 00:41:29 2020 Could it be as simple as:

          if (itc.getCacheRect().Contains(site) && !itc.isCacheUsable())

??  (Rect::Contains wants a signed point, so 'site' not 'usite'.)

[777:

Sun May 24 01:39:03 2020 Well, yes, that was it.  I've been watching
it and admiring its behavior and what not.  Up over 100K messages gone
by:

 ..
    6104840: DBG: EW02-AC/AINIT OWNING (12,4)+4
    6104841: DBG: EW02-AC/ABEHAVE FREEING (12,4)+4
    6104842: DBG: EW01-AC/AINIT OWNING (11,4)+4
    6104843: DBG:   ITC/WT:OPEN wrote 5/0xA6 0x97 ...== 5
    6104844: DBG: ITC/ET:OPEN: Recv 5/0xA2 0x97 ...
    6104845: DBG: ITC/ET:OPEN: Enter HRP
    6104846: DBG:   ITC/ET:OPEN wrote 2/0xA2 0xA7== 2
    6104847: DBG: ITC/WT:OPEN: Recv 2/0xA6 0xA7
 ..

Made a little video of the the loopback cable unplug/replug behavior
-- but thinking it would be more fun to demo that 'live' on the
update.[778:

Sun May 24 01:42:03 2020 I'm thinking maybe it's time to (make a few
usability tweaks on this stuff and then) make a new disk image?  So we
could INSTANTLY SEE THIS ALL DIE ON **REAL** INTERTILE instead of
LAME-O LOOPBACK SELF-DEALING.

Maybe we should wait until after the update for that.

:778]

:777]
:776]

:775]

:774]

:773]

:772]
:771]
:770]
[779:

Sun May 24 03:36:57 2020 And we have our first event race!  Beautiful!
Here it is, plain as day:

    518467: DBG: EW13-AC/ABEHAVE FREEING (37,9)+4

Some previous event is wrapping up, 18.5K log messages into the run..

    518468: DBG: EW23-AC/AINIT OWNING (51,5)+4

EW23 goes for an active event in the far northeast..

    518469: DBG:   ITC/ET:OPEN wrote 5/0xA2 0x90 ...== 5

..and sends a lock request off ET, since ITC/ET is OPEN.

    518470: DBG: EW02-AC/AINIT OWNING (4,9)+4

But right around the same time, EW02 goes to start an active event in
the far northwest!

    518471: DBG:   ITC/WT:OPEN wrote 5/0xA6 0x92 ...== 5

And it sends a lock request out WT before seeing EW23's inbound
request! Ono!

    518472: DBG: ITC/ET:OPEN: Recv 5/0xA2 0x92 ...

In this case, ET happened to read that lock request from WT first!

    518473: DBG: ITC/ET:OPEN: Enter HRP

And ET dishes it to handleRingPacket!

    Thread 1 "itcSpike12" hit Breakpoint 1, MFMLongJmpHere (buffer=0xbefff928,
        toThrow=1) at src/FailPlatformSpecific.cpp:48
    48	    longjmp(buffer,toThrow);
    (gdb) up
    #1  0x0046278c in MFM::T2EventWindow::checkSiteAvailabilityForPassive (
        this=0x504300) at src/T2EventWindow.cpp:280
    280	      FAIL(INCOMPLETE_CODE); // Resolve races

And boom goes the dynamite.

    (gdb) l
    275	        continue;
    276	      }
    277	    }
    278
    279	    if (conflicts.size() > 0) {
    280	      FAIL(INCOMPLETE_CODE); // Resolve races
    281	      return false;
    282	    }
    283	    // THEY WIN.  WE HOG THE REGION ON THEIR BEHALF
    284	    takeOwnershipOfRegion();
    (gdb)

So that's another big chunk of functionality yet to be written.  Do I
have the strength to start into it now?  Let's take a quick look.

(I note at the outset that it wouldn't be super hard to make a test
fixture that would set this situation up, so we could have a race --
or with more work even those multiway races I was worrying about --
more or less on demand.  We'll see if we need it.)

:779]
[780:

Sun May 24 04:32:18 2020 OK well I was designing in comments in
T2EventWindow.cpp, but I've gotten myself snarled up enough that we
better move back here.

In T2EW::checkSiteAvailabilityForPassive, we have:

    std::set<T2EventWindow *> conflicts;
 ..
    for (u32 sn = first; sn <= last; ++sn) {
      T2EventWindow * rew = tile.getSiteOwner(usite);
      if (rew != 0) {
        conflicts.insert(rew);
      }
 ..

and I was going for something like:

    if (conflicts.size() > 0) {
      if (resolveRacesFromPassive(conflicts)) {
        SOMETHING
      } else {
        SOMETHING ELSE
      }
      return false;
    }

And in:

  bool T2EventWindow::resolveRacesFromPassive(std::set<T2EventWindow*> actives)

I was imagining stuff like

    // OK.  Our question here is: Do we, as a new-still-being-created
    // passive EW, win against ALL of the active EWs in actives?
    //
    // Each active EW is considered in turn, strictly from oldest to
    // newest in terms of when their ring packets were sent.

But the thing is this:

 - We only have a strict ordering of ring-packet-sent-times within a
   single T2ITC.  But an active EW may have sent ring packets on two
   different T2ITCs, and it will have two different values in two
   different elements of mLockSequenceNumber[DIR6].

 - So it seems at the very least we need the 'this' EW in
   checkSiteAvailabilityForPassive to know what T2ITC it's a passive
   for, and then resolveRacesFromPassive should use the lock sequence
   numbers of that specific T2ITC to determine race resolution order.

   = And it must be the case that every EW in conflicts MUST HAVE SENT
     a ring packet on the given T2ITC, because visibility is
     symmetric.

So I guess that's something approaching a construction plan, but I'm
fading now.  Sleep and then come back here.

:780]
[781:

Sun May 24 10:31:45 2020 Well, so what I keep coming back to now is
the possibility that one active EW 'aA' on tile T1 could race
simultaneously against active EWs 'aB' on T2 and active 'aC' on T3.

[1] So the following lock requests are all in flight:

(1) aA T1->T2
(2) aA T1->T3
(3) aB T2->T1
(4) aC T3->T1

[2] Say T1 recvs (3).  It detects the aA:aB race, and suppose aB wins.

[3] So according to our thinking so far, T1 is supposed to silently
unwind and forget about aA, and proceed to grant the lock for aB,
returning an aB ACK to T2.  T1 also sets up pB, the passive EW
matching aB.

[4] Also say T2 recvs (1).  It too detects the aA:aB race, and
necessarily also computes that its own aB wins.  So it just drops the
aA lock request on the floor and awaits the ACK from T1 for aB.

[5] But at some point in these festivities, T3 will recv (2) and
detect the aA:aC race.  Suppose aA wins that.  T3 then forgets about
aC, and returns an aA ACK to T1.

[6] But after T1 recvs (3), say, it also will recv (4).  To T1, that
appears as aC conflicting with pB.  What to do?  T1 can't unilaterally
abort pB, because it already granted the lock to aB.

[7] And at some point before or after T1 recvs (3), it will also
receive the ACK from T3 for aA.  And what is T1 supposed to do with
that?  aA already silently unwound aA back at [3].

[782:

Sun May 24 11:55:33 2020 So all this seems to suggest a couple of
things to me:

 - First, it seems like we DO have to have a NAK reply to a lock
   request, and not just the yoink protocol + an ACK to the winner.

   If this scenario is true -- and that is not completely certain to
   me -- then there can be hidden information, so both sides CANNOT
   necessarily compute the same ultimate race winner separately.

 - Second, it seems almost certain that we can't just unwind an active
   EW when we lose a race -- at least not while we still have active
   circuits on it.

So T1 wouldn't be able to unwind aA in step [3] above, during recv (3)
processing.  T1 would have to keep it aA around, because aA still has
a circuit with T3.

But that's tough, because during recv (3) processing, T1 HAS to set up
pB and let pB hog its sites.  Cache upds from aB might arrive at any
time.

So we're saying there might be some kind of 'zombie active EW' state,
where an active EW has lost its sites, but it still has at least one
circuit, so it has to wait around to possibly get an ACK from some
other poor sap who's abandoned its own active EW in favor of this
zombie.

And then when the ACK arrives, the zombie EW will send like an empty
cache upd?  Which the passive side can 'apply', changing nothing?
That would be the simplest approach, if it didn't blow any statistics
or anything.
[783:

Sun May 24 12:31:09 2020 So this is seeming _slightly_ plausible if
all very gross and disgusting.  But I do want to think a little bit
about whether the key assumption -- that there can be hidden
information that some race participants absolutely cannot see -- is
really true.

Consider the :781: situation again: 'aA' on T1 races simultaneously
against 'aB' on T2 and 'aC' on T3.

Now here's my question: What does T3 know about aB and what does T2
know about aC?  Is it really possible that the answer is 'nothing'?
If so then it seems there definitely is hidden information.

Consider the NW corner again:

      +01234-----------
      0oooooooooooooooo    a:WT cache
      1oooooooooooooooo    b:WT visible
      2oooooooooooooooo
      3oooooooooooooooo    g:NW vis
      4aaaaeeeegggggggg    o:NW cache
      5aaaaeeeegggggggg
      6aaaaeeeegggggggg
      7aaaaeeeegggggggg
      8aaaabbbb
      9aaaabbbb
      |aaaabbbb

And suppose that's T1, and T2 is WT, and T3 is NW.  We could have
something like:

   T1 aA (4,4)+4            T2 aB (-1,6)+2             .   T3 aC (3,-1)+2
                                                      ...
 +01234-----------         +01234-----------       +0..C..----------
 0oooo.ooooooooooo         0oooooooooooooooo       0oo...ooooooooooo
 1ooo...oooooooooo         1oooooooooooooooo       1ooo.oooooooooooo
 2oo.....ooooooooo         2oooooooooooooooo       2oooooooooooooooo
 3o.......oooooooo         3oooooooooooooooo       3oooooooooooooooo
 4....A....ggggggg         .aaaaeeeegggggggg       4aaaaeeeegggggggg
 5a.......gggggggg        ...aaaeeeegggggggg       5aaaaeeeegggggggg
 6aa.....egggggggg       ..B..aaeeeegggggggg       6aaaaeeeegggggggg
 7aaa...eegggggggg        ...aaaeeeegggggggg       7aaaaeeeegggggggg
 8aaaa.bbb                 .aaaabbbb               8aaaabbbb
 9aaaabbbb                 9aaaabbbb               9aaaabbbb
 |aaaabbbb                 |aaaabbbb               |aaaabbbb

(Where all the coords have been mapped into T1's frame of reference.)

But let's see: aA and aC definitely conflict -- e.g., at (4,0) -- but
aB doesn't actually conflict with aA, does it?  Suppose we move aA one
row lower, and hmm aC one column right, that should do it:

   T1 aA (4,5)+4            T2 aB (-1,6)+2              .  T3 aC (4,-1)+2
                                                       ...
 +01234-----------         +01234-----------       +01..C..---------
 0oooooooooooooooo         0oooooooooooooooo       0ooo...oooooooooo
 1oooo.ooooooooooo         1oooooooooooooooo       1oooo.ooooooooooo
 2ooo...oooooooooo         2oooooooooooooooo       2oooooooooooooooo
 3oo.....ooooooooo         3oooooooooooooooo       3oooooooooooooooo
 4o.......oggggggg         .aaaaeeeegggggggg       4aaaaeeeegggggggg
 5....A....ggggggg        ...aaaeeeegggggggg       5aaaaeeeegggggggg
 6a.......gggggggg       ..B..aaeeeegggggggg       6aaaaeeeegggggggg
 7aa.....egggggggg        ...aaaeeeegggggggg       7aaaaeeeegggggggg
 8aaa...bb                 .aaaabbbb               8aaaabbbb
 9aaaa.bbb                 9aaaabbbb               9aaaabbbb
 |aaaabbbb                 |aaaabbbb               |aaaabbbb

OK.  Now aC and aA conflict on (4,1), and aB and aA conflict on (0,5)
-- but aB is hidden from T3 (NW), right?

Is aC is hidden from T2 (WT)?  Actually I guess it's not; T2's NE
cache would be seeing over to (0,3) in T1 coords, and aC is trying for
that spot.

[784:

Sun May 24 13:01:45 2020 Is this picture all possible?  Why is there
this T2/WT-sees-aC but T3/NW-doesn't-see-aB asymmetry?

This picture has unnecessary constraints, though, right?  Our cache is
the neighbor's viz.  The neighbor can have an event center anywhere in
their viz, meaning anywhere in our cache, meaning their event can
bleed over into our viz no problem.  So it could be like this, right:

   T1 aA (4,5)+4            T2 aB (3,7)+2                  T3 aC (7,3)+2

 +01234-----------         +01234-----------       +01234------------
 0oooooooooooooooo         0oooooooooooooooo       0oooooooooooooooo
 1oooo.ooooooooooo         1oooooooooooooooo       1ooooooo.oooooooo
 2ooo...oooooooooo         2oooooooooooooooo       2oooooo...ooooooo
 3oo.....ooooooooo         3oooooooooooooooo       3ooooo..C..oooooo
 4o.......oggggggg         4aaaaeeeegggggggg       4aaaaee...ggggggg
 5....A....ggggggg         5aaa.eeeegggggggg       5aaaaeee.gggggggg
 6a.......gggggggg         6aa...eeegggggggg       6aaaaeeeegggggggg
 7aa.....egggggggg         7a..B..eegggggggg       7aaaaeeeegggggggg
 8aaa...bb                 8aa...bbb               8aaaabbbb
 9aaaa.bbb                 9aaa.bbbb               9aaaabbbb
 |aaaabbbb                 |aaaabbbb               |aaaabbbb

and now aB is totally hidden from T3/NW and aC is totally hidden from
T2/WT.  And the conflict picture would look like this:

T1 aA (4,5)+4 +01234-----------
T2 aB (3,7)+2 0oooooooooooooooo
T3 aC (7,3)+2 1oooo.oo.oooooooo
              2ooo......ooooooo
              3oo...**C..oooooo
              4o.....**.ggggggg
              5...*A..*.ggggggg
              6a.***...gggggggg
              7a.*B**.egggggggg
              8aa.**.bb
              9aaa.bbbb
              |aaaabbbb

with *s marking conflicted sites.

[785:

Sun May 24 13:15:44 2020 So is that convincing?  The argument is:

1. We can definitely have multiway races where not all of the
participants will have visibility into all of the races.

2. Therefore, participants can NOT necessarily compute the correct
race winner themselves.

3. Therefore, due to the possibility that a passive side may detect a
hidden multiway race, a passive participant must be able to signal NAK
-- lock NOT granted -- even on an event that the (pairwise) yoink
protocol dictated the active side should win.

4. Therefore as well, due to the possibility that an active side may
have to abandon an an event to a hidden multiway race, an active
participant must be able to signal CANCEL -- lock released WITHOUT an
event -- even after the passive side has granted a lock.

[786:

Sun May 24 13:28:05 2020 Yikes.  That sounds semiplausible as far as
it goes, but (1) It's a lot of hair compared to what we thought we'd
need, and (2) Are we sure that it goes far enough?

[787:

Sun May 24 13:40:46 2020 So it would go something like this:

(A1) Pick an active window, it looks available, hog the sites and send
     ring packet lock requests to all other participants.

(A2) Wait for ACK/NAK from all other participants.

(A3) On first NAK from another participant, put the active window into
     some special suspended state while unhogging its sites, and wait
     for further ACK/NAKs.

(A4) On ACK from another participant, record that information.

(A5) Once all other participants have replied, check if we are in the
     special suspended state.  If so, send a CANCEL to all the
     participants that we received an ACK from, and then tear down the
     EW.

(A6) Otherwise, we are not in the special suspended state, so we
     received ACKs from all other participants.  Move on to ABEHAVE
     and cache upds in the existing fashion.


[788:

Sun May 24 13:49:31 2020 While on the passive side, it might be like:

(P1) Receive a ring packet lock request.

(P2) If all requested sites are available, set up a passive window,
     hog the sites, and send an ACK lock granted reply.

(P3) If any sites are conflicted, assemble the set of all conflicted
     windows.  If any of the conflict windows are passive, send a NAK
     lock rejected reply back to the source of the ring packet lock
     request.

(P4) If all of the conflict windows are active, consider them in
     oldest-first order. For each, first apply the yoink protocol and
     determine if the local active or the incoming active wins.

(P5) If the incoming active wins, put the local active into the
     special suspended state as in (A3) above.  Continue with the next
     conflicted window, if any.

(P6) If a local active wins, send a NAK lock rejected reply back to
     the source of the ring packet lock request.  (Note that some
     local actives may have been suspended by the time this happens.)
     Do not consider the rest of the conflicted windows, if any, and
     no passive window is created.

(P7) Otherwise, the incoming active wins over all local actives, which
     have now all been suspended, and their sites unhogged.  Continue
     as in (P2), which will now succeed.

(P8) Eventually, either a CANCEL or cache upds will be received on the
     circuit of the passive window.  If a CANCEL arrives, unhog the
     passive window sites and tear down the window.  If cache upds
     arrive, move on to processing them and committing in the existing
     fashion.

[789:

Sun May 24 14:16:44 2020 "And that's all there is to it!"

Gah.

And even at that, we're still ignoring channel errors and ITC
disconnects and so forth -- all the 'hard' stuff.

[790:

Sun May 24 14:42:34 2020 Getting to be time to break for meeting,
but.. are we believing this?  Do we think it covers the (non-error)
cases?

:790]
:789]
:788]

:787]

:786]

:785]

:784]

:782]

:781]
[791:

Mon May 25 10:29:29 2020 OK moving the flag.

:791]
[792:

Wed May 27 08:02:29 2020 OK so we're past the update and it's time to
plan some next steps.  Urm but first breakfast.

:792]
[793:

Wed May 27 15:33:09 2020 Well so this day turned into not hacking :(

Where are we?

..I guess we're trying to implement :787:

So we think we'll need:

 - Decide what's up with the 'special suspended state'.  What's it
   called?  What are its invariants?  What resources does it hold or
   release?

 - I bet we're going to need a userspace event tracing system
   relatively soon, to get sufficient observability into the action
   without blowing the timing.  Coordinating traces between tiles is
   still going to be a trick.  Maybe we could blow four bytes in all
   the circuit signals (except Talk) for a sender side sequence
   number, which we'd capture on both sides for later matching.
   Probably worth doing that much now, tracing system or no, just to
   help out log file analysis.

(We shouldn't use 'Flash' to mean lock discard.  It's too inside-telco
and it aliases with 'Flash traffic', which is a better, or at least
cooler, use of the term.  Press the pound key?  Call it Hash?  Just
ditch the foggen telco lingo entirely, boo, and go with
Req/Ack/Nak/Discard/Update/Done?  Boo, boo.  Hey, 'Drop'.  Drop a
call, that's a telco thing, and a fair match to what we need.  'Drop
(lock discard)' it is.)

:793]
[794:

Wed May 27 16:34:43 2020 So what about the special suspended state?
It's a state in the state machine, yes?  Named 'ADROP'?

  XX(ADROP,    1,    0,   0,  "finish NAKed event")     \

So what makes ADROP special is that we've already unhogged the sites.
So what's an explicit flag that an EW has/doesn't have hogged sites?

:794]
[795:

Thu May 28 02:05:54 2020 Geez get back in gear man.  We're almost 42
hours out from shooting the last update and no more code exists!

:795]
[796:

Thu May 28 03:33:44 2020 OK, made T2EW::isHoggingSites() to check if
an EW (still) has any representation in mSitesOwners.  Nobody's
calling it yet.

And added state ADROP.  Let's try to hook it up, starting from that
race detection site..
[797:

Thu May 28 03:56:09 2020 OK we're in 'resolveRacesFromPassive'.  :787:
behavior GO GO GO[798:

Thu May 28 03:56:54 2020 So we're at P3.  Next, we need to examine our
conflicts and see if any of those EWs are passive; if so we send a NAK
(and do what else, with ourself?)[799:

Thu May 28 04:14:58 2020 OK how do we tell if an EW is active or
passive?  Sheesh I can't remember anything.

:799]

:798]

:797]
:796]
[800:

Thu May 28 05:08:45 2020 OK, now we're dying in bool
T2EW::winsYoinkRace.  Aaand we have to figure out how to implement
that.

The yoink values are stored in the T2ITC Circuit structs, so at a
minimum we'll need to access them.  But one question is: Access them
on WHICH T2ITC?  At active EW could be associated with two T2ITCs.  Ah
but wait -- the other EW, the *this in winsYoinkRace, is always a
PASSIVE EW, and that's only associated with the T2ITC it came in on.
Is that really true?  So do we just yoink race on the passive's T2ITC
and call it done (for that race)?

Maybe.

Time for morning walkies.

:800]
[801:

Thu May 28 05:45:24 2020 So okay.[802:

Thu May 28 05:56:35 2020 Tried a first chunk of winsYoinkRace..  Isn't
building yet; fixing..

:802]

:801]
[803:

Thu May 28 06:00:39 2020 Well, we got to this:

    511447: DBG: ITC/WT:OPEN: Enter HRP
    511448: DBG: EW12-WT/PINIT YOINK ITC/WT:OPEN us0 them0

And though two 0 yoink vals is completely legal, it's also a little
suspicious.  Are we actually setting the yoinks much of anywhere?[804:

Thu May 28 06:04:23 2020 Well maybe it's not so suspicious --
getYoinkVal returns s32 and < 0 for uninitted, so maybe those were two
legit zeros.  Going again.

:804]

    Thread 1 "itcSpike12" hit Breakpoint 1, 0x00478cde in MFMLongJmpHere ()
    (gdb) up
    #1  0x0045e4e8 in MFM::T2EventWindow::winsYoinkRace (this=0x52e6e8, ew=...)
        at src/T2EventWindow.cpp:278
    278	    FAIL(INCOMPLETE_CODE);
    (gdb)

:803]
[805:

Thu May 28 06:06:20 2020 OK well, second go was this:

    45080: DBG: ITC/WT:OPEN: Recv 5/0xA6 0xA4 ...
    45081: DBG: ITC/WT:OPEN: Enter HRP
    45082: DBG: EW04-WT/PINIT YOINK ITC/WT:OPEN us1 them1

Let's see us and them differ.  Going again.[806:

Thu May 28 06:08:34 2020 Hmm:

    510806: DBG: ITC/ET:OPEN: Recv 5/0xA2 0xA7 ...
    510807: DBG: ITC/ET:OPEN: Enter HRP
    510808: DBG: EW07-ET/PINIT YOINK ITC/ET:OPEN us1 them1

One more try.[807:

Thu May 28 06:09:33 2020

    44705: DBG: ITC/ET:OPEN: Recv 5/0xA2 0xA0 ...
    44706: DBG: ITC/ET:OPEN: Enter HRP
    44707: DBG: EW00-ET/PINIT YOINK ITC/ET:OPEN us0 them0

Alright.  Let's look closer.

:807]

:806]


:805]
[808:

Thu May 28 06:12:24 2020 So, active side yoinkvals appear to be set

  bool T2ITC::allocateActiveCircuitIfNeeded(EWSlotNum ewsn, CircuitNum & circuitnum) {
    if (getITCSN() == ITCSN_SHUT) return true;  // No circuit needed
    MFM_API_ASSERT_STATE(getITCSN() == ITCSN_OPEN);
    CircuitNum ret = tryAllocateActiveCircuit();
    if (ret == ALL_CIRCUITS_BUSY) return false; // Sorry no can do
    mCircuits[1][ret].mEW = ewsn; // NOW ALLOCATED as active EW
    mCircuits[1][ret].mYoinkVal = mTile.getRandom().Between(0,1);

right there.

    circuitnum = ret;             // NOW ALLOCATED as EW's circuit
    return true;
  }

In a T2ITC::mCircuits[1], which is the active side, for example
according to:

      s8 T2ITC::getYoinkVal(CircuitNum cn, bool forActive) const {
        MFM_API_ASSERT_ARG(cn < CIRCUIT_COUNT);
        return mCircuits[forActive ? 1 : 0][cn].mYoinkVal;
      }

which is what we call here:

            themVal = itc.getYoinkVal(ci.mCircuitNum,true);

On the passive side, mYoinkVal comes from:

      void T2ITC::handleRingPacket(T2PacketBuffer & pb) {
        LOG.Debug("%s: Enter HRP", getName());
 ..
        const char * pkt = pb.GetBuffer();
 ..
        bool ayoink = ((pkt[4]>>7)&0x1) != 0;
 ..
        T2EventWindow & passiveEW = *mPassiveEWs[cn];
        MFM_API_ASSERT_STATE(mCircuits[0][cn].mEW == 0);
        MFM_API_ASSERT_STATE(mCircuits[0][cn].mYoinkVal < 0);
        mCircuits[0][cn].mEW = passiveEW.slotNum();
        mCircuits[0][cn].mYoinkVal = ayoink ? 1 : 0;
        passiveEW.initPassive(ourCtr, radius, cn, *this);
 ..

Which does appear to be a different place..  Can we see the yoink bit
getting set up in the ring packet?  Here:

      bool T2EventWindow::trySendLockRequests() {
        for (u32 i = 0; i < MAX_CIRCUITS_PER_EW; ++i) {
          if (mCircuits[i].mITC == 0) continue;
          T2ITC & itc = *mCircuits[i].mITC;
          CircuitNum cn = mCircuits[i].mCircuitNum;
          if (cn == U8_MAX) continue; // ITC is SHUT, no circuit or lock needed.
          s8 yoinkVal = itc.getYoinkVal(cn, true);
 ..

Accessed there.

          T2PacketBuffer pb;
          pb.Printf("%c%c",
 ..
          pb.Printf("%c%c",
 ..
          u8 yoinkRad = ((yoinkVal&0x1)<<7)|mRadius;
          pb.Printf("%c",yoinkRad);
 ..

Packeted there.  Which does appear to be in byte[4] of the packet.
[809:

Thu May 28 06:25:12 2020 Watch one more time, then pull out bigger
guns if needed..[810:

Thu May 28 06:30:01 2020 Fudge:

    546850: DBG: ITC/WT:OPEN: Enter HRP
    546851: DBG: EW02-WT/PINIT YOINK ITC/WT:OPEN us0 them0


:810]

:809]

:808]
[811:

Thu May 28 06:36:34 2020 OK breaking in winsYoinkRace.  One thinko
seems apparent: The two EWs should typically NOT have the same
circuitnum -- because they're completely separate events, unconnected
except for both wanting to hog aliased sites -- but winsYoinkRace
appears to think ...

Gah are we not even looking in ew?  Are we just comparing the passive
EW to itself?  Um?????[812:

Thu May 28 07:14:31 2020 Well, we were, but it still seemed messed up
after fixing that, so I finally started going fine-grained through
gdb..  And eventually the case I was tracing got to this:

    (gdb)
    273	    LOG.Debug("%s YOINK %s us%d them%d",
    (gdb)
    553715: DBG: EW12-ET/PINIT YOINK ITC/ET:OPEN us0 them1

And the yoinks are NOT necessarily identical.  Doh.

    278	    FAIL(INCOMPLETE_CODE);
    (gdb)

:812]

:811]
[813:

Thu May 28 07:15:45 2020 So OK.  Who wins?

If we go like the ITCs, [814: Thu May 28 07:20:11 2020 ...opps, the
T2ITcs ended up not yoinking.  The LKM?[815: Thu May 28 07:21:35 2020
...no, itcmfm.c is still using the heads-to-reset mechanism and
letting randomness sort it out..

Thu May 28 07:22:21 2020 Seems like it really really is up to us here
at the event level to yoink this out...

So this answer is: TIES GO TO GINGER.  If the bits are the same,
Ginger wins; if they're different, Fred wins.  Which in
one-strike-three terms means Ginger takes evens and Fred takes odds.

:815]  :814]

:813]
[816:

Thu May 28 08:05:27 2020 So trying to watch through a race example,
and I'm confusing myself a lot.  In particular, thinking in terms of
'us' and 'them' EWs is messing me up.  The *this in winsYoinkRace is a
passive EW, which really represents 'them', but we're calling its
yoinkVal 'usVal'.  While the active ew that gets passed in is one that
we ourselves originated, but we're using 'themVal' for their yoink
bit.

No matter what else, we have to fix that!

:816]
[817:

Thu May 28 10:10:44 2020 OK well it's half-conceivable that
passiveWinsYoinkRace is not utterly wrong.  (There's clearly some kind
of coord/mapping/something issue somewhere -- even in non-race
situations, because we're getting transporter accidents wiping out
bystanders quite often.  But we're leaving that for now.)

So back to :787: What next?[818:

Thu May 28 10:12:44 2020 Well for starters, :787: P5 has the same
active/passive confusion, saying: 'If the incoming active wins'..  But
the EW implied by the incoming ring packet is represented by a passive.
[819:

Thu May 28 10:31:03 2020 We're up to first-cut implementing P6
apparently?

:819]
:818]

:817]
[820:

Thu May 28 11:03:08 2020 Well I'm going cross-eyed here.  We just got
as far as seeing both sides of a race, kind of:

    6132360: DBG: EW31-AC/AINIT OWNING (4,11)+4
    6132361: DBG: EW31-AC/AINIT RING abs(4,11) usrel(0,11) yoink=0
    6132362: DBG:   ITC/WT:OPEN wrote 5/0xA6 0xA2 ...== 5
    6132363: DBG: EW28-AC/AINIT OWNING (48,14)+4
    6132364: DBG: EW28-AC/AINIT RING abs(48,14) usrel(0,14) yoink=1
    6132365: DBG:   ITC/ET:OPEN wrote 5/0xA2 0xA8 ...== 5
    6132366: DBG: ITC/ET:OPEN: Recv 5/0xA2 0xA2 ...
    6132367: DBG: ITC/ET:OPEN: HRP abs(52,11) themrel(0,11) yoink=0
    6132368: DBG: u EW28-AC/AWLOCKS (48,14); t EW02-ET/PINIT (52,11): YOINK ITC/ET:OPEN(Fred) us1 them0 -> they win

'Our' active EW28 (48,14) overlaps with incoming ET (52,11), and ET
wins.  (The (52,11) is the mapped EW31 (4,11) from 6132360.)

So (supposedly) we unhogged EW28 and put it into state ADROP.

    6132369: WRN: Big MSPAST 95386
    6132370: DBG:   ITC/ET:OPEN wrote 2/0xA2 0xB2== 2

And send an ACK telling (the active side of) EW31 that it had the lock.

    6132371: DBG: ITC/WT:OPEN: Recv 5/0xA6 0xA8 ...
    6132372: DBG: ITC/WT:OPEN: HRP abs(0,14) themrel(0,14) yoink=1

Meanwhile-ish, the corresponding lock request (from EW28 (48,14)) has
arrived at WT.

    6132373: DBG: u EW31-AC/AWLOCKS (4,11); t EW08-WT/PINIT (0,14): YOINK ITC/WT:OPEN(Ginger) us0 them1 -> we win

WT resolves the same race, the other way around, and correctly
concludes that it wins.

    6132374: DBG:   ITC/WT:OPEN wrote 2/0xA6 0xD8== 2

And it sends the first EW NAK packet in the history of the universe.

:820]
[821:

Thu May 28 16:36:37 2020 So let's think about event tracing at the
native engine level.  It doesn't have to be as tight and fast as the
LKM stuff, because we're here in userspace we're that much closer to
value...  What about just a ring buffer of strings?  Or a simple
struct with a time and a 'source' code of some kind..

Or what about just expanding the foggen log structure that we already
have?  Having some logging that goes basically straight to disk in
some kind mfmlog file.  But do make it parsable, so we can make some
kind of log merge program that will align a bunch of files from
neighboring tiles, using sync marks added to packets.  The sync marks
don't even have to be times; they probably don't want to be times;
they could be variable length too, so rare packets could have long
sync codes while frequent packets could have little or none.  One
matches long sync codes to match up flows to begin with -- "Aha!  I
have concluded that the tile that produced FILE13 was WT of the tile
that produced FILE213!"

I guess the log entries could/should have relative times in them as
well, like a u32 of usec perhaps, so that time delays could be
reconstructed too.

:821]
[822:

Fri May 29 03:17:37 2020 OK have a couple hours here; let's knock
together an mfm-level tracing system so we can reconstruct reasonably
detailed after-action reports that span multiple interacting tiles.

We need a master trace struct.  What will we put in it?

 - u16 deltaMs: Difference between TQ::now() and prev trace TQ::now()

 - u8 trace type: E.g., packet sent or received, race won, EW abort..

 - u8 data len: Number of trace type specific bytes following, 0..255

 - u8 data[len]: Arbitrary trace-type specific data

So we're saying variable length trace records?  From 4..259 bytes?
And that's enough room to stash an entire packet if we like, so long
as there's nothing else in the data except the packet.

And we'll declare subclasses of Trace to read and write each specific
trace type that we want.

And we'll have some pure virtual methods for everybody:

 - s32 write(ByteSink&) - return bytes written >=0 or error <0

 - s32 read(ByteSource&) - return bytes read >=0 or error <0

 - s32 tag() - return source tag > 0, sink tag < 0, no tag == 0

[823:

Fri May 29 04:03:33 2020 Maybe we should try for high-res intratile
absolute time, rather than deltaMs.  While understanding that there's
no intertile clock alignment, so we'll have to rely on matching source
and sink tags, at least to approximately align traces from different
tiles.

[824:

Fri May 29 04:07:23 2020 So I see:

    (gdb) p sizeof(struct timespec)
    $78 = 8
    (gdb)

So why not just do that (perhaps with htonl calls)?

 - struct timespec: Local absolute time

 - u8 trace type: E.g., packet sent or received, race won, EW abort..

 - u8 data len: Number of trace type specific bytes following, 0..255

 - u8 data[len]: Arbitrary trace-type specific data

If we went with fixed size records we could foggen mmap these files
couldn't we?  For analysis purposes anyway.  Ah, like we care about
speed or space during analysis, please!

:824]

:823]
:822]
[825:

Sat May 30 15:27:01 2020 Well okay time to take my medicine.  I went
for too much generality in the Trace subclass system and now things
are a mess and I'm going to have to back out a bunch of stuff, I
think.

So what is the TOTAL PALETTE of types of events we'd like to capture:

 - Packet movements, source, dest, and content

 - Some or all state changes for each ITC

 - Some of all state change for each EW

 - Explicit log messages.  We can do that here too.

 - Ulam-level debug messages

What is the set of addresses/indices we'd need to describe all those
locations.

 - ITC dir6

 - EW slot num for active EW

 - ITC dir6 and channel n for passive EW

 - No address

So we'll put room for all that crap in TraceBase and include some kind
of addressing mode saying which pieces of that information are the
address for this Trace record.  And that address mode goes early in
the trace record plus the stylized appropriate information.  And we
have a default ctor for TraceBase that inits to no address, and then
we have init functions to provide bits of info and set the addressing
mode.

Then the table-driven stuff doesn't even need to know the addressing
mode, except to declare special address mode specific ctors to use for
making the events for output.  For input it's all the same, because
the address mode and necessary address is included in the trace rec.

Unless we do want to put the addressing mode into the table, so we can
have the address format specifics implied by the event type, and not
have to include the address mode separately.

That seems better right?  [826:

Sun May 31 04:44:19 2020 No, we're making the TraceAddress completely
separate.  The idea is that a TraceType should imply how to read the
TraceRec of that type, independent of any address saying where it is.

So the table-driven stuff should be all uniform.  There's no
auto-generated calls on intermediate classes between TraceBase and the
specific TraceType subclass.[827:

Sun May 31 04:47:49 2020 But then how do we do writeBody?  We set up
an address first?  And we'll say an address is always supposed to be
enough info to get us from T2Tile::get() to whatever specific thing
we're writeBody()-ing?  Is that the idea?

Let's try it anyway.[828:

Sun May 31 06:01:31 2020 So, umm, how is a 'trace address' going to
resolve us all the way down to a T2PacketBuffer that we want to put
into the body of the trace????? UUMMM?

I think we have to rejigger the Trace API so that it gives us a
ByteSink& that the trace event creator can do whatever they want
with.  But yeah that helps the writing side but then where do the
unpacked pieces go on the reading side?  The symmetry was to have a
subclass to hold the pieces and then do reading and writing from the
subclass pieces.

[829:

Sun May 31 06:33:40 2020 What if instead of having options for custom
readbody and writebody we have custom ctors for output and input evts?
Or do we need both?  Or what if the state table automation doesn't set
up the subclasses at all?  How about that?  We've got to get off our
butts here and get SOMETHING working and pop the foggen stack.

How about we JUST have an enum for types, and we have a macro to
register our subclass with its type, and we do everything else by
hand.  No XX macro at all, how about that?

:829]

:828]

:827]

:826]Is there a point to having multiple address
modes for the same trace type?  Well foo: active vs passive EWs.  If
we wanted to reuse the EW trace types for both active and passive EWs
we'd need to include the mode.

Could we pack the mode and the address into a single u8?

0x00 : illegal
0x80|(slotnum&0x1f) : active EW
0x40|((dir6&0x7)<<...

guess probably not.

0x0000 : illegal
0x0100 | (slotnum&0x1f) : active EW
0x0200 | ((dir6&0x7)<<4) | (cn&0xf) : passive EW
0x0300 | (itcdir6&0x7) : itc

u8[4] for the whole thing type + address

[0] evt type
[1] addr mode    0x00 illegal  0x01 itc      0x02 active    0x03 passive
[2] addr arg 1        0x00          itcDir6       slotnum        itcDir6
[3] addr arg 2        0x00          statenum      statenum       cn


:825]
[830:

Tue Jun  2 03:17:40 2020 OK so we finally are getting close to log
file alignment.  We are now:

DONE - Scanning files for sync info included in select packets

DONE - Matching sync tags between files

DONE - Accumulating time disparities in both directions between instances
   of matching tags.

DONE - Assembling mean and variance of the estimates.

Right now we're just printing that stuff out.  We still need to:

 - Find the earliest starting time of any file

 - Compute and store the offset between that time and the timebase of
   each file, to shift the origin of all times in all files to the
   earliest start time of any file.

 - Develop a metaiterator in Alignment that advances all files in time
   order according to their renormalized times.

Also as a practical matter we need to

 - Do a checkpoint commit of all this stuff

 - Pull it onto a neighboring tile (or two?)

 - Gather some data into MULTIPLE FILES to try genuine merging.

:830]
