{254}  -*- text -*-
[0:
[3:
[35:
[36:

Thu Feb  6 14:20:38 2020 And here we are.

:36]
Thu Feb  6 14:19:30 2020 MOVING THIS TO
/home/t2/T2-12/pru/itcio/notes/ since we're now about LKM hacking
again.

:35]
[4:

Sun Feb  2 01:29:46 2020 And here we are.

:4]
Sun Feb  2 01:28:16 2020 MOVING THIS TO
/home/t2/MFM/src/drivers/itcSpike/ where we've been working for a
while now..

:3]


Sat Feb  1 04:15:53 2020 So, starting in to a spike to get more real
about ITC state machines for the levels and so forth.

First question: Are we going to redo the itc_pkt to break out the
packet channels?  Right now, MFM/src/drivers/mfmt2/include/MFMIO.h is
opening MFM_DEV_PATH == /dev/itc/mfm and that's that.[1:

Sat Feb  1 04:48:19 2020 And we're already doing a loop, in
mfmt2/src/main.cpp, to ship flash traffic, since we have to customize
the packet headers.  With separate devices I suppose we could even
have the LKM slug the src/dst info into the pkt hdr.

Well I think it's pretty clear we're thinking of making
/dev/itc/mfm/{ET..NE} devices, so why don't we get on down to
~/T2-12/pru/itcio/module/ and see what that might involve.  One think
to think about is that packet writes will still need to be merged into
the outbound queue for the appropriate pru, so the locking on that
could start actually getting stressed, since there will be six (well,
three) separate devices that might be trying to a given outbound kfifo
at once.

But nap first.[2:

Sat Feb  1 10:00:37 2020 OK, let's have some

TODO

[5: Sun Feb  2 01:30:16 2020
DONE :5] - Make a tiny little stub that we'll grow into the itc level
   sequencer.

[12: Wed Feb  5 04:34:28 2020
DONE :12] - Change boot sequence to start the stub INSTEAD of mfm, so the
   former can grab /dev/itc/mfm

[13: MFMIO.h/cpp was already that, so
DONE :13] - Maybe let's make a little abstraction that wraps /dev/itc/mfm and
   turns it into a like pollable pseudo-device?  So we could start our
   level sequencing code without immediately doing the LKM stuff?

[14:
DONE:14] - Rough up some packet formats for the levels

[15:
DONE :15] - Demo first-cut on-tile level sequencer talking on loop-back then
   between tiles, with results visible ONLY in the log file -- NO
   DISPLAY HACKING ALLOWED :)

:2]

:1]

:0]
[6:

Sun Feb  2 05:01:08 2020 OK we're at ITC::sendLevelPacket() so we need
a packet format.  What do cache updates currently use?  Let's just get
OoB wrt that?[7:

Sun Feb  2 05:04:16 2020 In src/core/include/Packet.h, we have like
PacketType::UPDATE_BEGIN == 'b'.[8:

Sun Feb  2 05:25:31 2020 But that's the second byte.  The packet
actually starts with

      u8 cmd = 0xa0|dir8; // STD MFM pkt hdr
      packet.Printf("%c",cmd);

according to src/drivers/mfmt2/src/main.cpp:262

So let's just keep going with the second byte scheme, I guess.  The
cache processing code appears to be using second byte types [ucea].
We notice they're all 7 bit ASCII.  If we take the high bit for our
level scheme we can pack the level and stage all into the second byte,
with room leftover..

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1 | L1| L0| S1| S0|RV0|RV1|RV2|
   +---+---+---+---+---+---+---+---+

Three bits left over, if we say no more than three levels.
[9:

Sun Feb  2 05:41:39 2020 Well let's do that.  We can always change it
if pressing needs come up.[10:

Sun Feb  2 05:45:26 2020 Uhhhhm except flash traffic is already using
the top bit of byte 1.

      if (amt > 1 && (buf[1] & 0x80)) // byte 1 MSB set is MFM SPECIAL, clear is

So we'll need to rethink.  Probably just draft 'l' or 'L' for Level
packet, and take another byte and not worry about it.

But first nap.


:10]

:9]
:8]

:7]

:6]
[11:

Sun Feb  2 12:21:36 2020 OK, so we're sending 'l' packets to ourselves
via loopback cable, and handling them a little, and are getting quite
close to the frontier of chnlSim.pl's implemented behavior.  But it's
time to move the flag, so we've got to get this stuff actually into
the tree for safety..

:11]
[16:

Wed Feb  5 04:35:19 2020 OK so we're post-t2sup#269 and want to get
some thoughts down while they still don't seem to suck.

A LEVEL has

 - SUPPORTS.  These are things that must be true to remain in or at
   the LEVEL.  The level code should check all these things every time
   it runs, and if any are untrue the level crashes.

 - PROPERTIES.  These are things that can be accessed, and can affect
   processing both within level code and by other entities

 - Triggers? Advancers? Exiters?  These are the conditions that allow
   advancing from one level to another.

[17:

Wed Feb  5 04:58:46 2020 So the problem with levels is that you can't
fork states, because you have this one dimensional notion of altitude,
of progress, of sequence.  So you have to fold all cases at a given
level into the properties of that level -- like COMPATIBLE vs
INCOMPATIBLE physics.

The good thing about levels is you can do altitude comparisons.  You
can say 'if (foo.level >= ACTIVE)' or whatever, and have that be a
meaningful thing.

[18:

Wed Feb  5 05:07:06 2020 There's also the interlock implied by the
stages, reflecting the distributed aspect of the state machine.  In
principle we could be looking to stage-interlock not just ITC<->ITC
but also the ITC<->TileModel.

Could there be a cross-entity global notion of levels?  And things
might but at different levels on that scale, but they'd still be
commensurate.

MFMT2 can be:

  CLOSED - not running, or starting up or loading or ..
  OPEN - running events under whatever circumstances prevail

ITCs can be

  CLOSED - not connected, or negotiating physics, or incompatible physics
  OPEN - handling locks and cache updates between compatible MFMT2s

[19:

Wed Feb  5 06:29:54 2020 In addition, entities might be stable or
unstable within a level.  Entering/stable/leaving?  What is the
purpose(s) of stability?

 - Coordination with remote entities
 - Non-atomic processing internal to level

Externally we say something isn't really AT a level until they are at
least STABLE in that level.

:19]

:18]

:17]
:16]
[20:

Wed Feb  5 06:51:12 2020

TILE
  Coordination tasks:
  (1) Host PRUs
  (2) Host ..
  Computation tasks

ITC
  Coordination tasks:
   (1) Host Tile
   (2) Peer ITC
   (3) Host MFM
  Computation tasks:
   (1) Compatibility check

MFM
  Coordination tasks:
   (1) Local ITCs (limited)



                          TIMEOUT       RCVE
 ITC::CLOSED::ENTER       reannounce    ITC::CLOSED::ENTER -> ITC::CLOSED::STABLE
                          + remain

 ITC::FAILED::

:20]
[21:

Wed Feb  5 07:28:34 2020 What if we move the compatibility negotiation
into the kernel???  That would certainly establish the decoupling of
the ITCs from MFMT2.

How might it work?

Open /dev/mfmctl for read/write.  It's single user so that's how mfmt2
locks out any other userspace competitors.  Write MFZ fingerprint to
it?  Poll to read it for events?  Do we even believe in events?  Vs
states?  Perhaps advisory events just to speed things up, but the
event just triggers reading states, rather than trusting the advice.
Everything should still work, just slower, even if all events (other
than timeouts) are ignored.
[22:

Wed Feb  5 08:54:16 2020 So an event is really just like a wake-up,
rather than a real event.  Even a timeout is really just a wake-up,
and the entity checks its own internal clock to see if it's a 'real'
timeout.

I do think we're going to go to actual time-based intervals for
timeouts and such, though, rather than the count-based stuff from this
weekend.  After all, that's counting wake-ups, which we JUST SAID
weren't supposed to matter if they happened or not.

But we only want intervals, not absolute times, and only at say
millisecond res.

[23:

Wed Feb  5 09:26:12 2020 When we accumulate state, like advancing a
level, we associate a rate at which we expect that state to be
refreshed.  And indeed, maybe we do not think in terms of a single
timeout for an entity, but in terms of a timeout for refreshing each
bit of state it is maintaining.

But first nap.

:23]

:22]


:21]
[24:

Wed Feb  5 12:48:58 2020 Suppose we try to rough out an LKM approach
to mfm configuration and cache updates.  Goals:

 - Userspace informs LKM of its ability to run events of some given
   MFZ and no other.  After that returns successfully, all KITC fds
   have been put into an error state, and userspace must close and
   reopen those connections before they can be used.

 - User space sees 'only' cache updates (and flash traffic?) via the
   new device.  And KITC status, OPEN/CLOSED, with open implying
   'ready for events'.   'And like everything,' we should somehow get
   a wake-up when a KITC changes, or we can interrogate it at our own
   rate.

When mfm considers an event window it tries for locks on the ITCs it
believes to be OPEN, and goes from there.

[25:

Wed Feb  5 15:58:17 2020 Are we saying we'd just expand itc_pkt for
this, or would there be a separate LKM?  I guess we're saying expand
itc_pkt.  We don't want to figure out how to call between LKMs for
example.

So,

TODO
[29: Thu Feb  6 11:13:11 2020

DONE :29] - Review itc_pkt.[ch] to remember what we're dealing with.

[37: Thu Feb  6 14:20:58 2020
DONE :37] - Make an expanded struct for each direction, and

[50: Fri Feb  7 14:45:10 2020
DONE :50] - Make a struct for mfm info like the mfzversion.

[45: Fri Feb  7 12:03:33 2020
DONE :45] - Review packet formats to see where we could fit it the inter-itc
   negotiation stuff (aka 'level packets').

[38:
DONE :38] - Also review for expanding to per-ITC packet-IO devices to
   userspace.  Like /dev/itc/mfm/ET../dev/itc/mfm/NE or whatever.

:25]

:24]
[26:

Thu Feb  6 01:15:57 2020 So for starters, we're talking about a bunch
of new minors, right?  For the record, here's what we're using now:

    t2@beaglebone:~/T2-12/pru/itcio/module$ ls -l /dev/itc/* | sort -k 1.1,1.2 -k 5n -k 6n
    crw------- 1 root root 237, 0 Feb  5 01:23 /dev/itc/pru0
    crw------- 1 root root 237, 1 Feb  5 01:23 /dev/itc/pru1
    crw------- 1 root root 237, 2 Feb  5 01:23 /dev/itc/packets
    crw------- 1 root root 237, 3 Feb  5 01:23 /dev/itc/mfm
    crw------- 1 root root 237, 4 Feb  5 01:23 /dev/itc/pktevents
    crw------- 1 root root 238, 0 Feb  5 01:23 /dev/itc/locks
    crw------- 1 root root 238, 1 Feb  5 01:23 /dev/itc/lockevents
    t2@beaglebone:~/T2-12/pru/itcio/module$

so we'd be talking SIX more minors under /dev/itc?  And does this mean
they ALL need/want to be DIRECTLY under /dev/itc?  Well, maybe not.
The makeITCCharDeviceState code like at itc_pkt.c:2129 does:

  switch (minor_obtained) {
  case PKT_MINOR_ITC: snprintf(devname,BUFSZ,"itc!packets"); break;
  case PKT_MINOR_MFM: snprintf(devname,BUFSZ,"itc!mfm"); break;
  case PKT_MINOR_EVT: snprintf(devname,BUFSZ,"itc!pktevents"); break;

so perhaps we could 'just' do "itc!mfm!ET" ?  Except that would imply
/dev/itc/mem is a directory not a device.  But maybe "itc!bydir!ET" or
whatever.  Or maybe device /dev/itc/mfm does become a directory -- do
we still need it as a device if we're exploding the itcs by direction?
Bulk traffic still goes by /dev/itc/packets; flash traffic will appear
in the by-direction queues (?), along with the 'mfm' traffic.  So

Assuming we really can go more than one '!' deep in that naming
scheme.
[27:

Thu Feb  6 02:54:13 2020 So anyway.  I think itc_pkt.[ch] isn't in
terrible shape for adding another chunk of minors.  For now, let's
preserve /dev/itc/mfm and try going with /dev/itc/bydir/ET..[28:

Thu Feb  6 11:00:15 2020 Post coffee with Melanie and Chris Thachuk.

[30:

Thu Feb  6 11:13:32 2020 So let's go for more minors.  This part of
the hack is basically about demuxing the inbound mfm packets on a
per-direction basis, and we can do that separately from moving
additional protocol negotiation into the kernel.[31:

Thu Feb  6 14:00:25 2020 OK so we theoretically have six more minors
being built and torn down, all untested.  Wait, where did we actually
name their paths?[32:

Thu Feb  6 14:05:21 2020 And their paths have been named.  All, as
previously mentioned, untested.

We have a new script on the workstation,
CDM-TGZS-BACKUP/scripts/PullT2HomeDir, that just rsyncs /home/t2, with
no versioning or extra redundancy on the workstation side.  But trying
that now because I think we're facing

BITS OFF

:32]

:31]

:30]

:28]

:27]
:26]
[33:

Thu Feb  6 14:17:05 2020 OK well we seem to have survived
install+reboot okay so far.  No logoops that I can see.  And we see
this:

    root@beaglebone:~# ls /dev/itc
    bydir  lockevents  locks  mfm  packets	pktevents  pru0  pru1
    root@beaglebone:~# ls /dev/itc/bydir
    ET  NE	NW  SE	SW  WT
    root@beaglebone:~# ls -l /dev/itc/bydir
    total 0
    crw------- 1 root root 237,  5 Feb  6 14:10 ET
    crw------- 1 root root 237, 10 Feb  6 14:10 NE
    crw------- 1 root root 237,  9 Feb  6 14:10 NW
    crw------- 1 root root 237,  6 Feb  6 14:10 SE
    crw------- 1 root root 237,  7 Feb  6 14:10 SW
    crw------- 1 root root 237,  8 Feb  6 14:10 WT
    root@beaglebone:~#

which all seems plausible.

[34:

Thu Feb  6 14:18:43 2020 But, this file is currently in ~/MFM, which
seems wrong since we're now into LKM stuff over in ~/T2-12/pru.

:34]
:33]
[39:

Thu Feb  6 14:44:59 2020 So let's see if we can demux inbound MFM
packets to our new devices, while still sending them to /dev/itc/mfm
as well.[40:

Fri Feb  7 02:45:27 2020 Well, we'd have to introduce a new packet
copying thing to do that, so maybe let's just bite the bullet and
stop sending to /dev/itc/mfm.  However, we're wondering if while we're
tearing all this up, we might make yet another minor to represent
flash traffic.  With the desired semantics being that flash traffic
reads are not demuxed per-dir6, but perhaps flash writes are
automatically broadcast in all active dir6s.

Actually now that I say it perhaps /dev/itc/mfm could be repurposed
for flash traffic, rather than creating yet another minor?  So we'd

(1) Insert a diversion around itc_pkt.c:1768 where we'd fall through
    on flash traffic, but go off to some new demux handler for
    everything else.

(2) Change the code around itc_pkt.c:1399 to broadcast flash traffic
    rather than routing it.

[41:

Fri Feb  7 06:26:56 2020 So how do we distinguish flash traffic, and
'ITC level' traffic, at the LKM level?



:41]

:40]

:39]
[42:

Fri Feb  7 10:33:48 2020 OK, well I spent a couple hours, here, making
T2-12/doc/T2-Packet-Header-Formats-11.ods and .pdf files.  It presumes
we're going to take byte 1 bit 7 on routed standard packets to mean
'MFM traffic', as opposed to 'flash traffic', so itc_pkt can split
those streams before delivery to userspace.

It further presumes we're going to take byte 1 bit 6 on MFM traffic to
mean 'ITC level traffic', which is to be handled by itc_pkt.c and
never delivered to userspace, directly, at all.  That leaves only six
bits for the the cache packet type code, so we can't just be happy and
use 7 bit ASCII.  Now, according to MFM/core/include/Packet.h, we
currently have cache type codes [bucea] in use, and none of them fit
in six bits.

But I'm thinking now might be the time to support merging cache
'minipackets' together for transport anyway, in which case we might
not even be using the remaining six bits of byte 1, and might just be
starting at byte 2.

[43:

Fri Feb  7 10:49:26 2020 Let's see.

 Format: UPDATE_BEGIN + s16:CX + s16:CY          --5 bytes
 Format: UPDATE + u8:SITENO + T:ATOM             --14 bytes
 Format: CHECK + u8:SITENO + T:ATOM              --14 bytes
 Format: UPDATE_END                              --1 bytes
 Format: UPDATE_ACK + u8:CONSISTENT_ATOM_COUNT   --2 bytes

So we could fit like (/ 250 14) ~16 site updates anyway in a single
packet, and a DReg- or Res-like diffuser would be (+ 5 14 14 1) < 40
bytes all done, if no check atoms were needed.  (Or alternatively,
more than a dozen check atoms could be included and still fit in one
packet.)

Worst case, if we had to ship absolutely the whole event window, we'd
be talking (+ 5 (* 41 14) 1) == 580 bytes, meaning three packets.

:43]

:42]
[44:

Fri Feb  7 11:52:08 2020 So where are we?  Have we got some to-do to
check off?[46:

Fri Feb  7 12:03:45 2020 Well, all that's left on the most recent
to-do is an mfm struct to capture downward state information.  Let's
knock that out.[47:

Fri Feb  7 12:53:19 2020 So, what ARE we going to use as the real 'MFZ
version string'?  The question drives the issue of what kind of
intertile security -- if any -- are we going to have in these
'research-only prototype tiles'.  About the best we could do, if we
wanted to, was to have some kind of private key inside the MFZ, and do
a challenge-response during KITC level negotiation.  But that would be
BS because it would only prove that the peer tile HAD POSSESSION of
some particular MFZ secret key, and not also that the peer tile WAS
RUNNING THE ASSOCIATED CODE unmodified.

So we shouldn't pretend we're getting intertile SECURITY here, and
just focus on avoiding intertile ACCIDENTS.  Seems like a hash of the
whole damn MFZ file would be the obvious way to go.  A SHA256 is 64
bytes in hex.  Suppose we make the max length 127 bytes.[48:

Fri Feb  7 13:14:03 2020 Actually, what does cdm.pl do?[49:

Fri Feb  7 13:22:40 2020 cdm.pl appears to use the FIRST HALF (16
bytes/32 hex) of the (32 bytes/64 hex) sha256 result.

Suppose we do this:

(1) Take the whole sha256 result as the id, but handle it in binary,
    taking 32 bytes.

(2) Make the max id string like 50 bytes.

(3) As part of leveling up, after we establish matching ids, we
    exchange a random token of perhaps 2 or 4 bytes.  That's what
    we'll use in later status announcements.  So a lower level is
    supported by matching ids, but a higher level is supported by
    matching side-specific tokens.  Maybe 2 bytes each, and the
    confirmation packet supplies our two bytes and our belief about
    their two bytes.  And we pick a random non-zero starting point
    when the LKM inits, and then increment-skipping-zero from there.


:49]

:48]

:47]

:46]

:44]
[51:

Fri Feb  7 14:45:33 2020 OK, made an mfmstate thing and initted it.
How do we set the config?  'echo $id > /sys/class/itc_pkt/mfzid'?

Well let's try more

TODO

[53: Fri Feb  7 16:39:14 2020
DONE :53] - Init MFMTileState via /sys/class/itc_pkt/mfzid

[64: Sat Feb  8 15:28:06 2020
DONE :64] - Draft the KITC levels considering the mfzid/seqno distinction

[54:
DONE :54] - Make code to open ITCMFMDeviceStatuss.  Ensure they are exclusive use.

[55:
DONE :55] - Mod ITCMFMDeviceStatus to have an invalid flag to set forcing reopen

[99: Thu Feb 13 13:38:13 2020
DONE :99] - Rename /dev/itc/mfm to /dev/itc/flash and route flash traffic there.

:51]
[52:

Fri Feb  7 16:38:45 2020 OK time to break for cooking dinner, but we
have some cargo cult progress at least.
[56:

Fri Feb  7 16:39:40 2020 All that crab builds but is totally untested
at present.

:56]
:52]
[57:

Sat Feb  8 00:08:42 2020 So, the levels, the levels, let's try again.

Level 0: ALONE
  Requires:        Nothing
  Announce stages: false
  Entry timeout:   1000+-100ms
  On timeout:      Re-enter
  Update on:       ITCCHANGE, L rcvd, timeout
  Stage1 on:       PacketSync
  Stage2 on:       PacketSync
  Advance on:      PacketSync

Level 1: KITC
  Requires:        PacketSync
  Announce stages: true
  Entry timeout:   300+-100ms
  On timeout:      Re-enter
  Update on:       ITCCHANGE, L rcvd, timeout
  Stage0 argument: None
  Stage1 on:       t>=1.0 && t<2.0
  Stage2 on:       t>=1.0 && t<2.0
  Advance on:      t>=1.1 && u==1.2

Level 2: CONFIG
  Requires:        t>=1.1
  Announce stages: true
  Entry timeout:   300+-100ms
  On timeout:      if u==2.1, Backoff else Retreat
  Update on:       ITCCHANGE, L rcvd, timeout
  Stage0 argument: MFZId
  Stage1 on:       t>=2.0 && t.MFZId!=u.MFZId
  Stage2 on:       t>=2.0 && t.MFZId==u.MFZId
  Stage2 argument: mfm.seqno
  Advance on:      t>=2.2 && u==2.2

Level 3: MFM
  Requires:        t>=2.2 && mfm.seqno == t.seqno
  Announce stages: true
  Entry timeout:   1000+-100ms
  On timeout:      if u>=3.1 backoff else re-enter
  Update on:       ITCCHANGE, L rcvd, timeout
  Stage0 argument: mfm.seqno t.seqno
  Stage1 on:       t>=3.0 && mfm.seqno == t.seqno
  Stage2 on:       false
  Advance on:      false

:57]
[58:

Sat Feb  8 07:24:45 2020 Well I presume stages 0..3, there, in part
because of compat/incompat but also because we gave two bits for stage
in the level packet, but I'm thinking we should go back to just stages
0..2 and do compat/incompat with additional state, like we're already
kind of doing for their seqno.  Or something.

[59: Sat Feb  8 07:32:13 2020

 - KITCs are updated on: ITCCHANGE, L rcvd, timeout

 - Level confirmation packet data is cumulative.

 - update begins with requirements check.  Level requirements are
   cumulative.  If currently supported level < previous level, enter
   at currently supported level, stage 0.  Otherwise enter at previous
   level, previous stage.

 - All timeouts are randomized +- 25%

 - Most recently received peer level info is stored in 't'.  't' data
   is reset on restart or if T timeout expires.

DEFAULT LEVEL VALUES:
  Requires:        t>=(L-1).1
  U timeout:       100ms, re-enter
  T timeout:       500ms, retreat
  Exchange:        nothing
  Decide:          true
  Confirm:         nothing
  Advance:         t>=L.1 && u==L.2

Level 0 CONTACT
  Requires:        Nothing
  U timeout:       10000ms, restart
  T timeout:       10000ms, restart
  Advance:         PacketSync

Level 1 COMMUNICATION
  Requires:        PacketSync
  Exchange:        u.seqno
  Confirm:         u.seqno + t.seqno

Level 2 COMPATIBILITY
  Exchange:        MFZId
  Decide:          d = u.MFZId == t.MFZId
  Confirm:         d

Level 3 COMPUTATION
  U timeout:       10000ms, re-enter
  T timeout:       50000ms, retreat
  Advance:         false

:59]

:58]
[60:

Sat Feb  8 09:33:59 2020 OK, so :59: seems to have some potential.
Separate Us-vs-Them timeouts seems pretty key, in the spirit of
output strict, input generous.  Was picking times so we'd send our
stuff at least twice, and probably three times, before giving up for
lack of their stuff in response.

Could we start going to code here?  Flesh out 'class' structs and
'method' funcs?  We're going to try to go array-of-structs-of-fncptrs,
right?  What might the functions be?

  enum LevelAction { DO_REENTER, DO_RESTART, DO_RETREAT, DO_ADVANCE, DO_CONTINUE };
  bool levelRequires(ITCMFMDeviceState * itc) ;
  LevelAction levelTimeout(ITCMFMDeviceState * itc, bool usNotThem, u32 & nextTimeoutAroundMs) ;
  u32 levelSend(ITCMFMDeviceState * itc, bool exchangeNotConfirm, char * pkt, u32 startIndex) ;
  u32 levelReceive(ITCMFMDeviceState * itc, bool exchangeNotConfirm, char * pkt, u32 startIndex) ;
  LevelAction levelDecide(ITCMFMDeviceState * itc) ;

:60]
[61:

Sat Feb  8 15:01:08 2020 Urgh just did a big reorg including renaming
itc_pkt.[ch] to itcpkt.[ch] to get the 'multiple source file building
into one ko module' working.  It now appears to be building but I'm
terrified to try it.

I guess we do our risky 'rsync pull' to get our

BITS OFF

:61][62:

Sat Feb  8 15:08:26 2020 Well, 'make install'ing..

:62]
[63:

Sat Feb  8 15:13:45 2020 Well we appear to have survived reboot
without oops.

Soooo can we check some stuff off heah?
[65:

Sat Feb  8 15:28:57 2020 Well, I still don't really want to rename
/dev/itc/mfm to /dev/itc/flash, so let's instead make up some new

TODO

[68: Sat Feb  8 22:19:51 2020
DONE :68] - Finish setting up the structs for the draft levels

[80: Mon Feb 10 15:57:31 2020
DONE :80] - Detect and divert on whatever now counts as 'L' packets

[98: Thu Feb 13 13:37:55 2020 Anyway basically
DONE :98] - Make a generic level update() function for externals to call.

[81:
DONE :81] - Get some level-related crab appearing in the log file.

:65]

:63]
[66:

Sat Feb  8 17:24:29 2020 OK having been doing horrible XX YY macro
hackery, and have gotten as far as declaring the needed 'custom level
functions', but not yet defined them:

      CC [M]  /home/t2/T2-12/pru/itcio/module/itcmfm.o
    /home/t2/T2-12/pru/itcio/module/itcmfm.c:43:48: warning: ‘ilsRequireCONTACT’ used but never defined
     #define YY1(NM,TYPE) static Level##TYPE##_func ils##TYPE##NM;
                                                    ^~~
    /home/t2/T2-12/pru/itcio/module/itcmfm.c:46:3: note: in expansion of macro ‘YY1’
       YY##REQ(NAM,Require)                \
       ^~
    /home/t2/T2-12/pru/itcio/module/itcmfm.c:33:9: note: in expansion of macro ‘XX’
     /* 0 */ XX(CONTACT,      1,  1,   0,   0,            _)    \
             ^~
    /home/t2/T2-12/pru/itcio/module/itcmfm.c:51:1: note: in expansion of macro ‘ALL_LEVELS_MACRO’
     ALL_LEVELS_MACRO();
     ^~~~~~~~~~~~~~~~
    /home/t2/T2-12/pru/itcio/module/itcmfm.c:43:48: warning: ‘ilsTimeoutCONTACT’ used but never defined
     #define YY1(NM,TYPE) static Level##TYPE##_func ils##TYPE##NM;

etc

So that's where to pick up.  But it's Saturday evening so break
  time.[67:

Sat Feb  8 22:19:20 2020 OK, so log-only versions of the level
customizations are building.

:67]

:66]
[69:

Sun Feb  9 08:06:14 2020 Well, so finally went back and systematized
the dir8-vs-dir6 distinction more thoroughly, which meant hitting tons
of stuff all over the place.  But it's building again; untested.

We've theoretically detected when a KITC packet has arrived, but we're
just logging when it hits.

Perhaps we should head back down to loopback-only and then give this a
try?  We haven't done much on the send side yet so we could probably
handmake a KITC packet and inject it.[70:

Sun Feb  9 08:35:00 2020 Well since we're blowing it all up we also
did the device renaming.  Now we have:

  /dev/itc/bulk
  /dev/itc/flash
  /dev/itc/pru/0
  /dev/itc/pru/1
  /dev/itc/mfm/ET
    ..
  /dev/itc/mfm/NE

but userspace still can't read or write anything via /dev/itc/mfm/*

[71:

Sun Feb  9 08:44:36 2020 We need to merge itc_pkt_write and
itc_mfmitc_write.  They might end up being the same or nearly so.  We
could have itc_mfmitc slug in the correct destination automatically
before dishing off to the factored-out guts of itc_pkt_write.

But first, business of the day.

:71]

:70]

:69]
[72:

Sun Feb  9 11:48:54 2020 Well, risky

BITS OFF

:72]
[73:

Sun Feb  9 12:12:26 2020 OK so had some BUG_ONs hit due to error
checking in mapPruAndPruDirToDir8, but hacked around that and now
appear to be coming up again.

Have rehacked cdm.pl to look for /dev/itc/bulk.

TODO

[74: Mon Feb 10 12:50:02 2020
DONE :74] - Rehack MFMIO (MFM/src/drivers/itcSpike11) to open all six
   /dev/itc/mfm/* devices!

:73]
[75:

Mon Feb 10 12:50:22 2020 OK, userspace is now hitting the fact that
itc_mfmitc_write returns -EOPNOTSUPP so we need to implement that.

:75]
[76:

Mon Feb 10 13:19:00 2020 Well trying that write implementation after

BITS OFF

:76]
[77:

Mon Feb 10 13:23:15 2020 OK we're back.  We have an ET-WT loopback
plugged in, and itcSpike is seeing their PS, but not deciding they are
compatible.  Let's dig in.

:77]
[78:

Mon Feb 10 14:39:22 2020 OK it was 'user error' -- we're writing 'l00'
packets from itcSpike11, and they are now, 'correctly', being
delivered to /dev/itc/flash, because they do not have the MFM bit
(0x80) set on byte 1.

So we need to send proper MFM packets!  Buut, actually, officially, we
don't want to be sending 'l' packets from userspace at all, we want to
be having itcmfm.c doing that.  Are we getting to the point where we
go back to that?

:78]
[79:

Mon Feb 10 15:55:29 2020 OK, finally we got to this:

    root@beaglebone:/home/t2/T2-12/pru/itcio/module# tail /var/log/syslog
    Feb 10 15:55:04 beaglebone kernel: [ 5519.721844] (ET) HANDLE ITC TRAFFIC HERE (2) packet
    Feb 10 15:55:04 beaglebone kernel: [ 5519.756940] (WT) HANDLE ITC TRAFFIC HERE (2) packet
    Feb 10 15:55:04 beaglebone kernel: [ 5519.819234] (ET) HANDLE ITC TRAFFIC HERE (2) packet
    Feb 10 15:55:04 beaglebone kernel: [ 5519.832708] (WT) HANDLE ITC TRAFFIC HERE (2) packet

meaning we have successfully diverted on level packets and gotten crab
into the log file..
[82:

Mon Feb 10 15:57:51 2020 So now let's get an itcmfm dispatch to call
there, and foggen call it.

:82]
:79]
[83:

Mon Feb 10 17:06:00 2020 Quick evening break.  On return, I think
ready to try touching some of the ITCMFMDeviceState unique data
members.  [84:

Mon Feb 10 18:58:12 2020 Well, that worked for what little it was
doing.  It's getting to be time to have an idea how timeouts are
supposed to be generated.  Hoping we don't need another kthread,
right? [85:

Mon Feb 10 19:09:07 2020 Well, we probably do need another kthread,
but I don't want to try to get into that now.

Couldn't we get a fair chunk going just with responses to packets?

:85]

:84]

:83]
[86:

Mon Feb 10 19:21:21 2020 OK, so one thing we need right away is to
ACTUALLY GENERATE A STRUCT TO HOLD OUR ITC STATE.  That's a leftover
undone bit from the XX hackery.[87: Mon Feb 10 19:24:32 2020 Or, did
we decide to ditch that for the hardcoded ITCLevelState that we
already see in itcmfm.h?[88:

Mon Feb 10 19:26:28 2020 I think we did but if we didn't let's do that
now.  [89:

Mon Feb 10 19:33:05 2020 Trying to implement from :59:

:89]

:88]  :87]

:86]
[90:

Wed Feb 12 06:55:56 2020 Well, let's set up a KITC timing thread in
  itcmfm.c[91:

Wed Feb 12 07:46:48 2020 Getting there.  Abstracted the thread
creation stuff.  Still need the threadrunner routine, though wow:

    make[1]: Entering directory '/usr/src/linux-headers-4.19.79-ti-r30'
      CC [M]  /home/t2/T2-12/pru/itcio/module/itcpkt.o
      LD [M]  /home/t2/T2-12/pru/itcio/module/itc_pkt.o
      Building modules, stage 2.
      MODPOST 1 modules
    WARNING: "itcLevelThreadRunner" [/home/t2/T2-12/pru/itcio/module/itc_pkt.ko] undefined!
      CC      /home/t2/T2-12/pru/itcio/module/itc_pkt.mod.o
      LD [M]  /home/t2/T2-12/pru/itcio/module/itc_pkt.ko
    make[1]: Leaving directory '/usr/src/linux-headers-4.19.79-ti-r30'

"Successful build, exit status 0"

:91]

:90]
[92:

Wed Feb 12 15:46:45 2020 OK, so we have some of the level callbacks
kind of implemented.  Need more.  Also need to start handling level
packets.  How do we do that?

TODO

 - Review the update requirements check.  In particular,

 - Deal with the 'entering' clauses in :59:.

 - Deal with the timeout randomization and mTimeout management

[97: Thu Feb 13 13:37:17 2020
DONE:97] - Deal with storing the most recently received peer level info in 't'

 - Finish implementing the default requires, using 't'

 - Finish implementing the default advance, using 't'

 - Flesh out non-default cb's of CONTACT

 - Flesh out non-default cb's of COMMUNICATION

 - Flesh out non-default cb's of COMPATIBILITY

 - Flesh out non-default cb's of COMPUTATION

 - See this stuff BEGIN to work.

:92]
[93:

Wed Feb 12 16:22:47 2020 OK, in handleKITCPacket, do we know we're
dealing with a 'level packet'?[94:

Wed Feb 12 16:24:20 2020 Yes, we do, because itc_pkt_cb checked URG &
MFM & ITC before it dispatched to us.  So that means we have a
LevelStage in the bottom five bits of packet[1];

:94]

:93]
[95:

Thu Feb 13 08:50:40 2020 OK we need to reboot so long overdue to get
our

BITS OFF

:95]
[96:

Thu Feb 13 13:36:48 2020 All right it's time to move the flag again.
Let's see where we are here.[100:

Thu Feb 13 13:38:32 2020 Well didn't get much in the latest set of
to-dos but there you are.  Have still been doing infrastructure ahead
of that stuff.  We have the ITCLevelState structs getting implemented
with at least some plausibility now, etc.

BITS OFF

:100]

:96]
[101:

Thu Feb 13 16:07:08 2020 OK, flag moved.

:101]
[102:

Thu Feb 13 16:34:58 2020 OK, so :59: says 'KITCs are updated on:
ITCCHANGE, L rcvd, timeout'.  We've implemented a cut at updating on
timeout, but how do we update on 'L rcvd'?  The idea, such as it was,
was to call the .packetio callback at that time.  But is that an
'update'?  Like do the level support checks happen at that time?

Or do we perhaps imagine that level packets 'arrive between' updates
and are always handled wrt the cached state at that time?

That seems bad, like we'll end up leaning on the timeout when we
wanted that just to be a backstop.  So that says we DO want to update
as part of packet handling.  Do we update before or after the
.packetio callback?  Or do we somehow let the update call that
callback?  Right now updateKITC() doesn't have the arguments to know
about any possible packet.. But that seems wrong anyway.

So that says we should call .packetio 'asynchronously', but also call
update.  Before or after?  [103:

Fri Feb 14 01:27:35 2020 Let's say before.  Handle the packet, then
update.  What's the downside, handling a packet without realizing a
timeout had already occurred?  If there actually is a packet you'd
think we want to deal with it.  And again, we're trying to avoid
leaning on timeouts at all on error-free paths.

:103]

:102]
[104:

Fri Feb 14 06:06:55 2020 Trying to get to the point of using
.packetio, and starting to think the interface is stupid.  As I
understand it, the distinction between 'exchange' and 'confirm' is
supposed to be strictly determined by what stage we're in within the
level.  So why not just have a single 'handleInboundLevelPacket' sort
of callback, and let the callee decide how to interpret it?

But nap now.
[105:

Fri Feb 14 11:00:35 2020 Because we were going to use .packetio also
for generating outbound packet args?  How was that going to work?[106:

Fri Feb 14 11:03:15 2020 Well, in :60: we had TWO functions listed:

  u32 levelSend(ITCMFMDeviceState * itc, bool exchangeNotConfirm, char * pkt, u32 startIndex) ;
  u32 levelReceive(ITCMFMDeviceState * itc, bool exchangeNotConfirm, char * pkt, u32 startIndex) ;

each with the exchangeNotConfirm, which would cover the four cases of
sending and receiving during exchange and confirm.  But that somehow
folded down to .packetio with only two cases, how?[107:

Fri Feb 14 11:48:56 2020 Let's change that bool to recvNotSend and let
the callback decide what to expect/generate based on its own view of
the level state.

:107]

:106]

:105]

:104]
[108:

Fri Feb 14 15:27:24 2020 OK, so, what happens after we do the
requirements check in update?  :59: is kind of silent on this matter.

We update mUCurrentLS based on level requirements and the :59:
language.  ..Then we call the .decide callback?  And it does,
something, maybe?  ..And then call the .advance callback?  And if it
returns true we do like mUCurrentLS.level++, mUCurrentLS.stage=0?
When do we send a level packet?[109:

Fri Feb 14 15:57:23 2020 Well, in :57: we have an 'Announce stages:
BOOL' row, but that didn't make it into :59:.  Was there going to be
some kind of special return from something?  Is that something that
LevelAction is supposed to cover?[110:

Fri Feb 14 16:06:54 2020 So I think the idea was auto-announce the
level when it changes?  Or whenever the level or stage changes?  Maybe
that's it.  Then we'd need to be checking that in the update
requirements check loop.  But that was probably it.

:110]

:109]

:108]
[111:

Fri Feb 14 17:22:00 2020 OK, so, now the question is: Why do we have
both a .advance callback, and a DO_ADVANCE LevelAction coming back
from .decide?
[112:

Fri Feb 14 17:39:03 2020 So it's about the stage numbers.  We enter at
LX0 for some level X.  When that's a new LS for us, we send a LX0
packet that includes the 'exchange' data.  After we receive an LX0
packet (ignoring L(X-1)2 packets), we go to LX1, run the .decide, and
(if we DO_CONTINUE anyway), we send a LX1 packet including the
'confirm' data.  When we get an LX1 packet (ignoring LX0 packets), we
confirm it matches (HOW??), and go to LX2.

Each step along the way there, we were running the .advance callback
as well?  And by default it was saying false until they're at least at
LX1 and we're at LX2?

STILL NOT CLEAR AGAIN.  But time to cook.

:112]
:111]
[113:

Fri Feb 14 23:01:52 2020 OK,

recv packet:

 - Modify state based on packet and current expectations.  State
   includes mTLastLS plus whatever you parsed out of the packet.

 - Then call update

update:

 - Compute newly supported level based on packet sync, TLastLS, and so
   forth

 - Compare to mUCurrentLS.

 - If different, attempt to send level packet.  Custom sendPacket can
   return 0 to abort packet send.

 - If packet send apparently succeeds, set mUCurrentLS to new LS.  If
   packet send apparently fails, do not change mUCurrentLS (but
   shorten utimeout?  But we need to avoid getting into a tight
   spamming-a-full-outbound-buffer loop.  )

..and that's it?  That's all?  The rest is magic?

 - Update is also called on timeout and ITCCHANGE.  (ITCCHANGE will be
   caught by the requirements check so nothing special is needed
   there.)

:113]
[114:

Sat Feb 15 05:39:25 2020 Where in update do we check the timeouts?
Before or after computing the support?  Perhaps after?  So that we
could be.. ..should we be saying that 'still time available' is
implicitly part of the support for the current level?

So that if there's a mismatch, we're going to reset the timeouts based
on entering a new state anyway


[115:

Sat Feb 15 06:36:06 2020 Restate premises.

update:
 - Find supported level by requirements
   - If the now-supported level is below our previous level, attempt
     to enter that level.  After that attempt, the update is done,
     regardless if it succeeded or failed.

 - If our previous level is still supported, determine action:
   - If our timeout has expired, the action is our UTimeout action.
   - If not, see if their timeout has expired.  If so, the action is
     our TTimeout action.
   - If not, call .advance to see if we can advance.  If so, the
     action is DO_ADVANCE.  Otherwise the action is DO_CONTINUE.

 - After the action has been determined, do that action.  DO_CONTINUE
   means stay at the current level, otherwise compute the new level
   implied by the action and attempt to enter that level.

 - DONE


attempting to enter a level:
 - start a packet for that level
 - call the level-specific packet writer (for exchange or confirm as
   depending on the stage we're attempting to enter) to complete or
   abort it
 - if completed, attempt to send it.
 - If packet aborted or send succeeds, enter the level
 - Otherwise remain in previous level


enter a level:
 - set mUCurrentLS to the level
 - push U and T timeouts based on the level

recv packet:
 - Parse their LS from packet, store it in TLastLS

 - Call exchange or confirm parser as appropriate to TLastLS -- THEIR
   LEVEL, not ours.

 - Push our TTimeout for them based on OUR level, not theirs. (?)

 - Then call update

[116:

Sat Feb 15 14:53:33 2020 OK, after sleep.

So I'm wondering if it might not be stupid to have two full copies of
the ITCLevelState for each ITC, one representing US and one
representing THEM.  Instead of having like both UCurrentLS and TLastLS
in one struct.

Doesn't that seem like it wants to be a 'no brainer'?  The idea would
be that received level packets would just get parsed into THEM's
ITCLevelStruct no questions asked..

Could we ditch the UTimeout vs TTimeout distinction as well, and have
a single timeout per ITCLevelState?  That seems more questionable,
because we'd be using THEM.mTimeout to represent when WE'RE going to
time them out, not anything about what they're going to do.

Although I suppose possibly if we switched from notion of a stored
timeout to a stored 'last activity', setting THEM.mLastActivity based
on packet arrival time isn't that bogus.

But we still need someone to say when 'that long ago' becomes 'too
long ago'.  How would the thread runner decide who to update?[117:

Sat Feb 15 15:18:09 2020 If we're willing to callback for the timeout
inside the thread runner -- which we already are, right? -- the
previous activity is all we need?  Well, I guess we'd need to compare
both US (last and timeout) and THEM (last and timeout) to determine
whether an update is warranted.
[118:

Sat Feb 15 15:23:18 2020 Aand, do we set US 'lastActivity' based on
when we last (apparently successfully) sent a packet?  That would be
most symmetric with setting THEM lastActivity based on receiving one.

It also has the nice flavor that it's explicitly about packets and
traffic and communications.

And it makes it so that if we failed to send a packet due to buffer
exhaustion say, we won't push back our (effective) timeout by changing
lastActivity.

So.. could we do this?  Let's at least look at the structs.[119:

Sat Feb 15 16:20:03 2020 Well jeez yeah I think so.  Maybe switch to
something like:

typedef struct {
  ITCSideState mUs;
  ITCSideState mThem;
} ITCLevelState;

typedef struct {
  unsigned long mLastAnnounce;  /* Time in jiffies */
  MFMToken   mToken;            /* Physics ID from MFM */
  MFZId      mMFZId;            /* MFZId from */
  LevelStage mLevelStage;       /* Endpoint LevelStage from Them */
  bool       mCompat;           /* True if Them and Us are known compatible */
} ITCSideState;

[120:

Sat Feb 15 16:28:21 2020 What happened to the seqno in all this?  No
hits in itcmfm.[ch].  And didn't the seqno thing also suggest we were
going to stack the packet generators and parsers?  So that every level
packet at L1.0+ will have a seqno..  Do we still want to go that
route?

Time to cook.

[121:

Sat Feb 15 22:30:22 2020 So an argument against seqnos is that we're
trying to be robust in the face of packet loss, by asserting our LS in
every packet and minimizing shared state.

(If we did the packet-stacking idea we could still have the levels
append different state depending on the level of the packet they are
appending to.  That's how we wouldn't have to have the MFZId in every
L2.1+ packet, for example, and how we could have just the 'd' residue
going forward.  Just have to tell the .packetio guys what the actual
packet level is, separate from the level they are 'prime' for.)

What were the seqnos supposed to accomplish?  We were worried about
enough stuff getting dropped in transit that the recipient could miss
an entire physics bounce or something, and end up indefinitely out of
sync.  And seqnos were supposed to avoid that because we'd best-effort
know if we missed packets.  And what do we do if we miss a packet?
DO_RESTART, I guess, which will block us from going forwards until we
pick and agree on new seqnos.  That almost makes some sense.
[122:

Sat Feb 15 23:20:09 2020 Now, what good does receiving their ack of
our seqno do?  In TCP that's what allows us to dump the buffers we'd
been saving in case we needed to retransmit, but we're not talking a
retransmit/reliable stream here, are we?

We'd thought it would be handy to give cache updates confidence the
far side was indeed responding to the request we thought they were --
and as we contemplate the possibilities of doing precision
event-window locking, rather than edge and corner locking, we could
conceivably have a number of transactions in progress and not know
what order the far side was going to respond to them.  And at that
point we'd really need some kind of transaction tags to match up --
but they wouldn't be seqnos, so...

:122]
:121]

:120]
:119]

:118]
:117]

:116]

:115]

:114]
[123:

Sat Feb 15 23:41:00 2020 Well fog it let's just do along the lines of
:119: -- plus a seqno -- and see where it gets us.

:123]
[124:

Sun Feb 16 16:16:39 2020 Jeez we compiled clean.  But I'm sure there's
horrible gaps all over the place.[125:

Sun Feb 16 16:18:05 2020

RISKY BITS OFF

:125]

:124]
[126:

Mon Feb 17 09:52:05 2020 OK time to move the flag again.  We've made a
bunch of progress but there's still lots of gaps and confusion in the
code.  Current status is do like:

    # echo f00 > /sys/class/itc_pkt/debug ; sleep 10 ; echo 0 >/sys/class/itc_pkt/debug

to flash debugging, and see stuff like:

    [14054.095675] (NW) UPDATE ss->mLevelStage=L00 advance=false
    [14054.107739] diffToNext=-3499100, jifTil=-3499079
    [14054.119011] final diffToNext=-3499100
    [14054.643753] kitc=0, timeout=3438240, now=3438416
    [14054.651715] (ET) UPDATE KITC them=L10
    [14054.661984] (ET) UPDATE reqmts level=0, ops=91665ae0
    [14054.673107] (ET) UPDATE reqmts level=1, ops=86da6820
    [14054.683718] (ET) UPDATE post reqmts enterlevel=1, enterstage=0
    [14054.698782] (ET) UPDATE ss->mLevelStage=L10 decideAction=5
    [14054.711049] (ET) MORE ME UPDATE newLS=L10 nextls=L10
    [14054.722806] (ET) UPDATE ss->mLevelStage=L10 advance=false
    [14054.735310] ilsPacketIO_CONTACT recv=false startIdx=0 len=255
    [14054.747751] ilsPacketIO_COMMUNICATE recv=false startIdx=2 len=255
    [14054.762948] sendLevelPacket us=L10 them=L10, len=2
    [14054.774857] ET00000000: a2 c4                                            ..
    [14054.789850] itcSideStateSetLastAnnounceToNow: timeoutVar=100, now=3438452, nextTo=3438575
    [14054.798268] recvLevelPacket us=L10 them=L10, pkt=L10
    [14054.803309] WT00000000: a6 c4                                            ..
    [14054.810337] ilsPacketIO_CONTACT recv=true startIdx=0 len=2
    [14054.815876] itcSideStateSetLastAnnounceToNow: timeoutVar=500, now=3438459, nextTo=3438851
    [14054.824119] ilsPacketIO_COMMUNICATE recv=true startIdx=2 len=2
    [14054.830004] (WT) UPDATE KITC them=L10
    [14054.833714] (WT) UPDATE reqmts level=0, ops=91665ae0
    [14054.838743] (WT) UPDATE reqmts level=1, ops=86da6820
    [14054.843758] (WT) UPDATE post reqmts enterlevel=1, enterstage=0
    [14054.849659] (WT) UPDATE ss->mLevelStage=L10 decideAction=5
    [14054.855197] (WT) MORE ME UPDATE newLS=L10 nextls=L10
    [14054.860210] (WT) UPDATE ss->mLevelStage=L10 advance=false
    [14054.865659] ilsPacketIO_CONTACT recv=false startIdx=0 len=255
    [14054.871456] ilsPacketIO_COMMUNICATE recv=false startIdx=2 len=255
    [14054.877603] sendLevelPacket us=L10 them=L10, len=2
    [14054.882441] WT00000000: a6 c4                                            ..
    [14054.889470] itcSideStateSetLastAnnounceToNow: timeoutVar=100, now=3438477, nextTo=3438572
    [14054.897710] sendLevelPacket (pushto=T) hdr=0xa6 got 2
    [14054.902812] (WT) REANNOUNCED L10, now=3438471, uto=3438259, new=3438572
    [14054.912141] recvLevelPacket us=L10 them=L10, pkt=L10
    [14054.917243] ET00000000: a2 c4                                            ..
    [14054.924279] ilsPacketIO_CONTACT recv=true startIdx=0 len=2
    [14054.929824] itcSideStateSetLastAnnounceToNow: timeoutVar=500, now=3438487, nextTo=3438884
    [14054.938064] ilsPacketIO_COMMUNICATE recv=true startIdx=2 len=2
    [14054.943948] (ET) UPDATE KITC them=L10
    [14054.947654] (ET) UPDATE reqmts level=0, ops=91665ae0
    [14054.952667] (ET) UPDATE reqmts level=1, ops=86da6820
    [14054.957678] (ET) UPDATE post reqmts enterlevel=1, enterstage=0
    [14054.963561] (ET) UPDATE ss->mLevelStage=L10 decideAction=5
    [14054.969107] (ET) MORE ME UPDATE newLS=L10 nextls=L10
    [14054.974120] (ET) UPDATE ss->mLevelStage=L10 advance=false
    [14054.999793] sendLevelPacket (pushto=T) hdr=0xa2 got 2
    [14055.011620] (ET) REANNOUNCED L10, now=3438438, uto=3438240, new=3438575
    [14055.026905] diffToNext=0, jifTil=159
    [14055.035909] kitc=1, timeout=4294906276, now=3438416
    [14055.047735] (SE) UPDATE KITC them=L00

with an ET-WT loopback cable.

:126]
[127:

Mon Feb 17 23:12:49 2020 OK.  I really really have to be working on
OTHER STUFF but we're finally making 'progress' here and I'm loathe to
give up on the state that I am still managing to hold in my head.

So going again here.[128:

Mon Feb 17 23:14:31 2020 Changing the default timeouts to 300/1000.

:128]

:127]
[129:

Mon Feb 17 23:26:07 2020 Implementing .require default

:129]
[130:

Tue Feb 18 01:50:26 2020 So one current issue is we don't announce if
advance returns false, even if we've changed stages.

We're wondering if we really need .advance at all.  At the moment it's
only used by the limiting cases:

    #define ALL_LEVELS_MACRO()                                    \
    /*         name   cust req tmo, pio, dcd, adv, state (NOT USED) */ \
    /* 0 */ XX(CONTACT,      1,  1,   1,   0,   1,            _)       \
    /* 1 */ XX(COMMUNICATE,  1,  0,   1,   0,   0,   _/*u16 ttoken*/)  \
    /* 2 */ XX(COMPATIBILITY,0,  0,   1,   1,   0, _/*MFZId tMFZId*/)  \
    /* 3 */ XX(COMPUTATION,  0,  1,   0,   0,   1,            _)       \

..but ilsAdvance_CONTACT is where we check for packet sync, so that is
pretty important.  ilsAdvance_COMPUTATION just returns false, but it
wouldn't be so bad to automatically infer that on the last level
anyway.

But the first advance matters.  Is it that we want .advance to be ||'d
with LS change, to decide when to announce?  That seems wrong.  We
want to announce every LS change once we have packet sync.  And it
almost seems like we'd prefer to announce all LS changes, period, with
some understanding that the announcement getting tossed somewhere
below when there's no packet sync.

But in any case it seems we definitely want to decouple announcements
from advancements.

:130]
[131:

Tue Feb 18 03:14:39 2020 So we have an awful lot of fingers in the
changing-the-LS pie inside updateKITC:

 - We begin with 'prevLS' captured on entry to updateKITC.  Now, could
   that have been changed, during recvLevelPacket, since the last
   updateKITC?  Or does recvLevelPacket just manipulate other state --
   like mThem -- but leave mUs alone?[132: Seems only mThem is touched..  :132]

 - The .require loop produces a maximum supported level[133: Tue Feb
   18 03:42:06 2020  ..that's in local 'newLS' and immediately stored
   in mUs.mLevelStage.  Not sure if we want to commit that fast but
   we'll see.

 - We then run .decide JUST FOR THAT NOW-STORED newLS, and get an
   action which leads to 'nextLS'.  So now there's 'prevLS', 'newLS',
   and 'nextLS', all at least potentially different.

 - Then we run .advance based on the then-prevailing mUs (== newLS
   ATM).  If it returns true, we set 'advanceLS' by incrementing
   newLS, if there's any headroom left considering MAX_LEVEL_NUMBER.

 - Then, AND ONLY THEN, we announce, if advanceLS ends up different
   than (effectively) newLS.

So that's clearly messed up.  We won't ever announce downshifts?

We should make whatever decisions about LS we want -- and that
obviously needs to be thought through again -- but then at the end of
updateKITC we should announce based only on the final LS vs the prevLS
we captured on entering.
[134:

Tue Feb 18 06:26:20 2020 So, post walk: How should the post-updateKITC
LS be determined?  Consider the factors:

 0: prevLS: The LS we had at the beginning of the updateKITC
 1: supportLS: The LS determined by the prev LS and the current support
 2: uTimeoutLS: The LS implied by the .timeout LevelAction if mUs timeout occured
 3: tTimeoutLS: The LS implied by the .timeout LevelAction if mThem timeout occured
 4: decideLS: The LS implied by the .decide LevelAction
 5: advanceLS: The LS implied by the .advance LevelAction

Derive:
 downLS : The min of whichever 1-3 are applicable.

If downLS < prevLS, then resultLS = downLS.
else {
   compute decideLS
   if decideLS < prevLS, then result = decideLS
   else {
     compute advanceLS
     if advanceLS > prevLS, then result = advanceLS
   }
}

then if resultLS != prevLS {
  mUs.mLevelStage = resultLS
  sendLevelPacket
}
[135:

Tue Feb 18 13:59:53 2020 So could we make it a find-first-down-LS loop
and only check advance if no downs are found?  And simplify things
that way?

:135]
:134]

:133]

:131]
[136:

Tue Feb 18 17:03:06 2020 Well, building clean again.  Now updateKITC
is basically just a loop and a check and a send:

    void updateKITC(ITCMFMDeviceState * mds)
    {
 ..
      for (i = 0; i < sizeof(lsEvals)/sizeof(lsEvals[0]); ++i) {
        LSEvaluator eval = lsEvals[i];
        nextLS = (*eval)(mds,prevLS);
        if (nextLS != prevLS) break; /* found a move, stop */
      }
      if (nextLS != prevLS) {
        ss->mLevelStage = nextLS;
        sendLevelPacket(mds,false); /*pushes timeout if sent*/
      }
    }

with the idea that '.advance' is last in the lsEvals:

    static LSEvaluator lsEvals[] = {
      &lsEvaluatorSupport,
      &lsEvaluatorUTimeout,
      &lsEvaluatorTTimeout,
      &lsEvaluatorDecide,
      &lsEvaluatorAdvance
    };

..and it's the only one that might go up in LS; all the rest go down
or stay the same.

With this 'clean' scheme, we may be going to sendLevelPacket when
there isn't PS, what will happen there?  [137:

Tue Feb 18 17:09:54 2020 What will happen is ilsPacketIO_CONTACT will
detect no PS and return 0, causing sendLevelPacket to NOT attempt to
send a packet but YES TO update the utimeout as if we had.

And ilsTimeout_CONTACT appears to set everybody's timeouts to 10k
jiffies (which is probably 10s?) which seems plenty long to come back
around and check PS.[138:

Tue Feb 18 17:26:52 2020 Hmm,

    root@beaglebone:~# getconf CLK_TCK
    100
    root@beaglebone:~#

and

/usr/include/asm-generic/param.h:6

    #ifndef HZ
    #define HZ 100
    #endif

suggest on my BBG, a jiffy is 1/100s, so 10k jiffies would be 100s..

:138]

:137]

:136]
[139:

Tue Feb 18 17:42:56 2020

RISKY BITS OFF

:139]
[140:

Tue Feb 18 17:51:53 2020 Have to break for cooking; just started
debugging.  Got to where ET and WT advanced to L01, but then it seems
that WT is thinking it's still L00 and is announcing L01 again..[141:

Wed Feb 19 01:13:39 2020 Added more logging to follow along closer.

RISKY BITS OFF

:141]

:140]
[142:

Wed Feb 19 03:08:44 2020 Still tracing through.  Bug in
lsEvaluatorSupport wasn't dropping us back when level support failed.
Still fussing with timeout and timedifferences.  Going again.

RISKY BITS OFF

:142]
[143:

Wed Feb 19 03:44:33 2020 OK so the lsEvals[] iteration has the problem
that it's not (necessarily or usually) pushing expired timeouts, so
they keep happening.

We wanted to tie the timeout push to sending level announcements but
that seems unreliable at least at present.  Could we say that just
returning the mTimeoutAction is grounds enough for pushing the
timeout, then it's somebody else's problem if they didn't do a send or
whatever due to that mTimeoutAction?[144:

Wed Feb 19 03:49:19 2020 Well, trying that.  But that still won't deal
with multiple timeouts hitting in a single updateKITC

:144]

:143]
[145:

Wed Feb 19 13:27:34 2020 OK, so we've made yet another new minor for
/dev/itc/itcevents.  If we can find a useful 9 bit code for itc
events, we can back-fit them into the existing itcpktevent.h framework
with a minimum of fuss.

Things we might like to know:

LS: dir6:3 + op0:1 + LS:5
  dir6:3 bits with 6,7 reserved
  op:  2 bits
  LS:  5 bits as 3+2 for L00..L72

    op0
     0 + newus
     1 + newthem

fmt6: 110:3 + op6:3 + dir6:3
    op6
     000 ITCDN
     001 ITCUP
     010 UPBEG
     100 UPEND
     101
     110
     111

fmt7: 111:3 + spec:6
    spec
     0000 RSRV
     0001 DO_REENTER
     0010 DO_RESTART
     0011 DO_RETREAT
     0100 DO_ADVANCE
     0101 DO_CONTINUE
     0110 TIMEOUT
     0111..1111 rsrv

:145]
[146:

Wed Feb 19 14:44:08 2020 So what's the deal here?  addPktEvent very
ominously says:

    /*MUST BE CALLED ONLY AT INTERRUPT LEVEL OR WITH INTERRUPTS DISABLED*/
    void addPktEvent(ITCPktEventState* pes, u32 event) {

but then all through itcpkt.c there are calls on ADD_PKT_EVENT, and no
calls on ADD_PKT_EVENT_IRQ, but only the latter disables interrupts..

itcpkt.c:304
  if (ret == 0)
    ADD_PKT_EVENT(makePktXfrEvent(PEV_XFR_TO_PRU, ipb->mPriority, log2in3(pktlen), prudev->mTempPacketBuffer[0]&0x7));

doesn't look to be at interrupt level -- it's (indirectly) called from
itcOBPktThreadRunner.

itcpkt.c:1678
      if (ret == 0)
        ADD_PKT_EVENT(makePktXfrEvent(PEV_XFR_FROM_USR, minor != PKT_MINOR_BULK, log2in3(copied), tmp[0]&0x7));

doesn't either -- it's (indirectly) called from itc_pkt_write.

So who's wrong: All those calls, or the scary comment (or both)?
[147:

Wed Feb 19 14:50:19 2020 So in 20190901333-pkt-traceevent-notes.txt, I
see this:

    Mon Sep  2 03:32:38 2019 Hmm for one thing we need to be calling
    ADD_PKT_EVENT_IRQ not ADD_PKT_EVENT..  I doubt that's our current
    issue though.

ah but then I also see:

    Mon Sep  2 05:29:13 2019 So we really have no explanation for the
    original page fault we saw.  We don't actually think we even need to
    use ADD_PKT_EVENT_IRQ either, because we're not doing interrupt stuff
    on the itc_pkt side.

So I think it's the scary comment that's (currently) wrong.
[148:

Wed Feb 19 14:53:37 2020 Changed the scary addPktEvent comment to:

    /*WARNING: IF INTERRUPT HANDLERS ARE IN USE (which they are evidently
      NOT in itcpkt), THEN THIS MUST BE CALLED ONLY AT INTERRUPT LEVEL OR
      WITH INTERRUPTS DISABLED */

[149:

Wed Feb 19 14:54:29 2020 OK, back to trying to sprinkle around some
ADD_IT_EVENT callshere..

:149]:148]
:147]
:146]
[150:

Wed Feb 19 15:25:01 2020 OK a first cut at /dev/itc/itcevents is
building successfully.  Time for

RISKY BITS OFF

:150]
[151:

Wed Feb 19 16:16:19 2020 Yikes, apparently the itc_pkt userspace event
decoder never made it into the T2-12 repo?!  I just copied (a version
of) it off of the old 4.4.54 keymaster --- which I had carefully NOT
yet reflashed --- and will stick in the repo now, but, yow.  That
could have been significant work lost.

RISKY BITS OFF

:151]
[152:

Thu Feb 20 05:31:20 2020 OK, well we've finally gotten t2trace working
plausibly here on 4.19.79.  And now we can START modifying it to read
/dev/itc/itcevents too.  It was a pretty big hack to force two event
streams together and it will be an even bigger gross hack to force a
third in the same way, so we'll need to smooth out the
next-event-picking logic, I'd think, in this process.

:152]
[153:

Thu Feb 20 16:08:07 2020 OK, time to make install and reboot and see
how the events trace out.  Committing this stuff.

:153]
[154:

Thu Feb 20 16:25:25 2020 OK so we're starting to get plausible KITC
trace data, and it's tending to confirm a suspicion I had before.
Check this out:

    0134  8.639570sec   +0usec 19a:K (SW) UPEND: update end

..Random unconnected itc (SW) updateKITC ends

    0135  8.639570sec   +0usec 193:K (WT) UPBEG: update begin

WT updateKITC begins.  WT and ET are on loopback.

    0136  8.639570sec   +0usec 1c7:K     [TIMEOUT: timeout]

Some kind of timeout happens..  Not a super useful report. :(

    0137  8.639574sec   +4usec 0e1:K (WT) u->L01

WT announces L01 (which just means it's got packet sync).

    0138  8.644826sec   +5msec 0d6:P   <WT to PRU 2-4>

And that packet gets pushed to the PRUs immediately (!?).  Note that
the WT updateKITC is apparently still in progress.

    0139  8.644956sec +130usec 001:K (ET)  t->L01

And ET receives the packet, and updates its 'them' to L01

    0140  8.644956sec   +0usec 1c7:K     [TIMEOUT: timeout]

Another timeout.  I think this means (ET) just pushed its 't' timeout
in response to receiving the WT level packet.

    0141  8.644960sec   +4usec 190:K (ET) UPBEG: update begin

Now ET begins an updateKITC, called from recvLevelPacket

    0142  8.644960sec   +0usec 1c7:K     [TIMEOUT: timeout]
    0143  8.644964sec   +4usec 021:K (ET) u->L01

..and announces L01

    0144  8.650093sec   +5msec 198:K (ET) UPEND: update end

and its updateKITC ends.

    0145  8.650278sec +185usec 0d2:P   <ET to PRU 2-4>

and that packet ships..

    0146  8.650318sec  +40usec 19b:K (WT) UPEND: update end

and ONLY NOW the original? WT updateKITC FINALLY ends

    0147  8.650387sec  +69usec 0c1:K (WT)  t->L01

and the ET LP is received

    0148  8.650387sec   +0usec 1c7:K     [TIMEOUT: timeout]

and the WT t timeout is pushed.

    0149  8.650392sec   +4usec 193:K (WT) UPBEG: update begin

and WT begins another updateKITC..

[155:

Thu Feb 20 16:46:49 2020 So the surprising part of that for me is that
we didn't get (WT) UPEND before 0138 or 0139 at the latest.

:155]
:154]
[156:

Fri Feb 21 01:06:29 2020 OK so we're trying to understand the timeout
code we wrote in itcLevelThreadRunner, but we're not getting very far.
Can we review our intentions here?

 - We want to find the nearest future timeout over all the KITCs,

 - Taking into consideration that when we updateKITC one, that may
   change its timeout, and we want to consider its post-update
   timeout.

But waaaait.  Just back in :154: we were complaining about apparent
recursive entries into updateKITC, and we changed code like this:

      /* handle the packet */
      recvLevelPacket(ds,packet,len);

      /* then update their state machine*/
      updateKITC(ds);

to code like this:

      /* handle the packet */
      recvLevelPacket(ds,packet,len);

      /* then update their state machine*/
      wakeITCLevelRunner(); /*by waking the level runner?*/

but that doesn't make much sense: The level runner is only calling
updateKITC when the KITC timeout has expired.  Receiving a level
packet desires consideration of an immediate response, but just waking
the backstop timeout thread won't do that.

We either want to accept recursive entry to updateKITC, or explicitly
expire the timeout before calling wakeITCLevelRunner.

But we don't really want to expire the timeout, because we have
semantics associated with handling expired timeouts that we don't want
to do.

No, we kind of must want to call updateKITC directly when we have new
information for a KITC to consider.

We still don't understand how we ended up reentering updateKITC.  We
have like:

 updateKITC ->
   sendLevelPacket ->
     trySendUrgentRoutedKernelPacket ->
       kfifo_in to buffer
       wakeOBPktShipper ->
         wake_up_process
       <-
     <-
   <-
 <-

but we really think that path should end there and we'd exit
updateKITC before seeing any packets handled..

And we have:

 itc_pkt_cb ->
   handleKITCPacket ->
     recvLevelPacket
     updateKITC ->
       (as above)

Although.. rpmsg does interrupt us, doesn't it, when there's a buffer
to deliver.  Is that somehow what's going on?  Does itc_pkt_cb really
run at interrupt level?  I don't think so?  [157:

Fri Feb 21 03:17:44 2020 Or yes?  There's some random user process,
say, running when the PRU signals a packet incoming to linux.  That
causes an interrupt, which traps to the kernel (which is mapped into
all address spaces), and itc_pkt_cb runs?  But the interrupt has
already been dismissed by that point?  If so, what process or thread
or whatever got context-switched to to 'own' the callback processing?
I really don't understand this stuff.

:157]

:156]
[158:

Fri Feb 21 06:45:22 2020 OK but we have to do SOMETHING about the
timeout handling in the level runner; currently, we're instantly
blowing out our KITC buffer with as many of these as needed:

    2028  0.001372sec   +0usec 1cb:K             [LATE: going again]
    2029  0.001374sec   +2usec 1c9:K             [BITR: begin iteration]
    2030  0.001374sec   +0usec 1cb:K             [LATE: going again]
    2031  0.001374sec   +0usec 1c9:K             [BITR: begin iteration]
    2032  0.001376sec   +2usec 1cb:K             [LATE: going again]
    2033  0.001376sec   +0usec 1c9:K             [BITR: begin iteration]

:158]
[159:

Fri Feb 21 14:04:27 2020 Try again.  High-level timeout-related
functions of updateKITC:

 - ..

What if we got more explicit about being like a priority queue?  That
would mean we could simplify the loop to just 'sleep until nearest
timeout, pull off soonest thing, update it, reinsert it'.  But mainly
I'm thinking we probably really need to be thinking about locking
access to the (however real) priority queue, so that callbacks at
interrupt level can't step on in-progress pq ops.

I guess that was part of the rationale to want to have receiving
packets just kick the level runner rather than calling updateKITC
directly.  If the idea is that we understand the 'them' state is ONLY
modified at interrupt level by packet reception (modulo init and
timeout), but the level runner is the only place that calls
updateKITC..  And we have 'them' include a 'last modified' time, and
the us include a 'last examined' time, and updateKITC begins by
checking if the former is newer than the latter, and ends by setting
the latter to 'now'.

Then we can have the level runner call updateKITC on everybody at any
time, and then go to sleep for a say fixed amount of time, counting on
packet receptions and status changes to wake us early.

[160:

Fri Feb 21 14:41:00 2020 And this is a THIRD time-related field in the
KITC structs??  Or it's somehow a reinterpretation of what we have?

 mThem.mModTime  last time Them status was written
 mThem.mTimeout  when we'll act for them being overdue

   mUs.mModTime  last time Us status was checked
   mUs.mTimeout  when we'll act for us being overdue

and level runner iterates over the kitcs, and calls updateKITC on each
one whose mThem.mModTime is newer than them mUs.mModTime, and sets the
mUs.mModTime to now after each updateKITC is done.

[161:

Fri Feb 21 15:43:49 2020 But how does that deal with the timeouts?  It
seems like it doesn't at all.  And maybe it's not supposed to,
somehow?  After the level runner iterates over the KITCs, how long
does it sleep?

It does seem like it must be the level runner's job to ALSO deal with
noticing the timeouts, since really nobody else can.  But it would be
nice if we could at least pull that apart from the 'modtime'
considerations.

Could we 'just' also run the updateKITC if mModTime is older than
mTimeout, for either mUs or mThem? [162: Well that doesn't make sense
assuming the mTimeout is mostly supposed to be in the future and
mModtime is always <= now..  :162]

level runner:
  PHASE 1: REACT
  kitc iterator:
    if mThem.mModTime > mUs.mModtime  // world changed
       || mThem.mTimeout < now        // or world isn't going to change
       || mUs.mTimeout < now          // time for us to try again
      updateKITC
      mUs.mModtime = now

  PHASE 2:
  kitc iterator:
    find nearest future mThem.mTimeout or mUs.mTimeout

  PHASE 3:
  if negative, warn and pick 100ms
  if >1s pick 1s
  schedule_timeout(forthattime);


:161]

:160]

:159]
[163:

Fri Feb 21 16:53:31 2020 Looking around the web, this seems like a
potentially explanatory factoid:

    wake_up_sync and wake_up_interruptible_sync

    wake_up_sync(&wq);

    wake_up_interruptible_sync(&wq);

    Normally, a wake_up call can cause an immediate reschedule to
    happen, meaning that other processes might run before wake_up
    returns. The “synchronous” variants instead make any awakened
    processes runnable, but do not reschedule the CPU. This is used to
    avoid rescheduling when the current process is known to be going
    to sleep, thus forcing a reschedule anyway.

Now, I can't find a wake_up_sync identifier in bootlin 4.19, though
wake_up_interruptible_sync is there.. but I'm currently using
wake_up_process and I don't understand the relationship there.

:163]
[164:

Fri Feb 21 17:38:49 2020 But also, suppose we reinterpret mTimeout as
an offset rather than an absolute time.  So the absolute timeout is
mModTime+mTimeout.  But then when do we rerandomize the
mTimeoutOffset?  If we do it whenever mModTime changes what have we
gained?  If we only do it when it expires aren't we risking long-term
dirt-at-the-edge-of-the-road bias for lucky long time outs?

:164]
[165:

Sat Feb 22 03:55:28 2020 So ITCSideState already has:

  unsigned long mLastAnnounce;  /* Time in jiffies (by local clock) */

which is currently declared, initted, updated by
'itcSideStateSetLastAnnounceToNow':

    ./itcmfm.h 71:  unsigned long mLastAnnounce;  /* Time in jiffies (by local clock) */
    ./itcmfm.c 497:  ss->mLastAnnounce = now - (prandom_u32_max(50)+(isUs ? 100 : 10));
    ./itcmfm.c 69:  ss->mLastAnnounce = now;

and never otherwise referenced.  Could we rename/use that as mModTime?

:165]
[166:

Sat Feb 22 04:53:36 2020 Well, renamed mLastAnnounce to mModTime and
did a cut at :161: above.

RISKY BITS OFF

:166]
[167:

Sat Feb 22 05:18:39 2020 Well have to travel today, so committing all
this as a WIP.  Starting to get there..

:167]
[168:

Mon Feb 24 14:58:22 2020 All right, so back from Denver trip and
trying to figure out where we are.

For example, we are recording an 'INCOMPLETE CODE' event at
itcmfm.c:246, and we're really unsure what is supposed to go there.

Let's recap.

 - We are in recvLevelPacket <- handleKITCPacket <- itc_pkt_cb.

 - We have just gone through the levels calling .packetio, letting
   each applicable level have a(n incremental) crack at parsing the
   packet.

 - After recvLevelPacket returns we are going to wake the level runner
   and then call the processing of that packet done.

 - The level runner will always call updateKITC if 'them' have a more
   recent mModtime than 'us', so if recvLevelPacket updated
   mThem.mModtime, then we should get updated on the next level runner
   opportunity.

So, questions:

 - Who guarantees that mThem.mModTime gets touched by that process?

 - What if anything else needs to happen at packet reception time?

We're increasingly leaning to thinking the answer to the latter
question is: Nothing.  That the purpose of packet reception time is
just to parse info from the packet into itcSideState mThem, update
mThem.mModTime, and kick the level runner.

So maybe there's nothing more to do there?

Maybe.

And who does guarantee mThem gets touched?[169:

Mon Feb 24 15:17:00 2020 Right now that's happening in
ilsPacketIO_CONTACT:

itcmfm.c:389
    /* Pick up their info*/
    ss = &ds->mLevelState.mThem;
    ss->mLevelStage = byte1 & 0x1f;

    ADD_ITC_EVENT(makeItcLSEvent(ds->mDir6,IEV_LST,ss->mLevelStage));
    itcSideStateTouch(ss);

So from one point of view that's a pretty random place, but it kind of
makes sense too.. and with the 'accumulating levels' approach to
packet generation and parsing, we're pretty much guaranteed to pass
through that sequence.

So, way back in :59: we show the COMMUNICATION layer sending and
receiving 'seqno's.  Are we still going to do that?  What was the
intended semantics?[170:

Mon Feb 24 16:10:19 2020 So from :57: it seems like seqno is the
randomized MFZid write count, used to reduce the risk of missing a
mfm restart of the same physics.  It seems we could maybe go ahead and
give that a try..

One thing about it, though, we were planning on send a 'confirm' level
packet containing both our seqno and our belief about theirs.  How
would that work with this recv-just-dumps-to-mThem strategy?  It would
seem like the confirmation would have to happen at parse time rather
than during updateKITC?  But at this point we're pretty scared of
making any decisions outside of updateKITC, since we see the level
runner getting suspended in the middle of one updateKITC pretty often.

I guess we could just send u.seqno on both exchange and confirm.

We also need to understand how the exchange vs confirm idea interacts
with the 'accumulating packets' idea.  It seems like we'd send the
exchange info for a level only when we're below .2 on that level..
[171:

Mon Feb 24 16:31:38 2020 So, wait, isn't the sender's level part of
every level packet?  Where does that fact appear in :59:?  [172:

Mon Feb 24 16:34:24 2020 Contrary to :59:, itcmfm.c is currently
exchanging LS in ilsPacketIO_CONTACT..  Not quite sure how that
interacts advancing on packet sync, though..[173:

Mon Feb 24 16:41:03 2020 Maybe we should ditch the exchange/confirm
thing, and use moving-on-to-next-level as a confirm.  The next level
obviously has a different packet format, so that's all okay.

Ah and the reason ilsPacketIO_CONTACT can send LS is because it gets
called for EVERY level packet, not just when we are at level CONTACT.
[174:

Mon Feb 24 16:57:26 2020 So let's try a :59: redo with our 'more
modrun' thinking and see what it looks like.
[175:

Mon Feb 24 16:58:04 2020

 - KITCs are updated ONLY from the level runner.
   = External triggers (ITCCHANGE, L rcvd) only store state in mThem
     and wake the level runner.

 - Level packet generation and parsing is cumulative, however, the
   CONTENTS of the per-level data can change depending on the current
   actual level at the time of packet generation.  .packetio parsers
   must consider the LS supplied in the packet when determining how to
   parse.[176: Mon Feb 24 22:19:58 2020 Call it the 'active' content
   vs the 'residual' content.  [177: Tue Feb 25 06:44:43 2020

 - Most recently received peer level info is stored in 't', and 't's
   mModTime is then set to jiffies iff the peer level info ACTUALLY
   CHANGED.  mModTime is NOT CHANGED IF packet 't' data is the same as
   currently stored.  We're taking this as an invariant to get the
   system to settle SO DON'T FOG THIS UP during debugging scrambles.

 - 't' data is reset on restart or [MAYBE?] if T timeout expires.

 - update phases are:
   = Check REQUIREMENTS from 0 to current level.  If currently
     supported level < previous level, enter at currently supported
     level, stage 0.  Otherwise enter at previous level, previous
     stage.
   = If mThem.mModTime is newer than mUs.mModTime, REACT at current
     level.  Reaction involves examining level-appropriate mThem data,
     making computations and decisions based on that, and yielding a
     new LS for mUs.
   = Otherwise (mThem.mModTime is not newer than mUs.mModTime), check
     timeouts.

     - If mUs.mTimeout has expired, we think maybe there was a lost
       packet, and we resend our current LS, and push our timeout

     - If mThem.mTimeout has expired, we think they're dead and we
       restart (drop to L00).

       [178: Tue Feb 25 10:52:11 2020 Now it does kind of seem like if
       we're saying that's the meaning of the two timeouts, we could
       fold that down to like one timeout plus a count.  Which isn't
       really less state so much as it is less flexible state, which
       is of course good if it's enough.[179:

       Tue Feb 25 16:02:01 2020 So this line is suggesting that
       there's only two underlying causes of timeouts -- transient
       packet loss and durable peer loss -- and we're trying to
       distinguish those two cases and respond differentially.

       Do we believe that framing of the issue?  What else could it
       be?  [180: Tue Feb 25 16:09:03 2020 Well, not immediately
       coming up with other possibilities...  Peer is temporarily
       delayed?  But we'd handle that but setting these timeouts
       fairly generously anyway?[184: Tue Feb 25 17:08:49 2020 What
       about the case "Everything seems fine but (I believe,
       apparently) I have the initiative so I should advance"?  If
       that is NOT determined by a timeout, what IS it determined
       by?[186:

       Wed Feb 26 06:40:08 2020 I guess the point is, except for the
       very beginning, in the error-free case it should all be
       ping-pong, with nobody needing to decide to spontaneously 'do
       something'.  So maybe it is the timeout error case..  Which
       would mean we do need custom timeout code grrr? :186]

       (Urgh time to cook.) :184]

       I'm thinking we should go with mTimeout + mRetries as part of
       this round's redo..  And could we please get rid of the
       .timeout callback and make it two per-level constants -- a
       timeout and a retry count? :180]

       :179] :178]


 mThem.mTimeout has expired, drop back
     level packet after possibly changing LS.

     jiffies is later than mUs.mTimeout, then resend current level
     packet, and push our timeout.

:177]  :176]

:175]

:174]

:173]

:172]

:171]

:170]

:169]

:168]
[181:

Tue Feb 25 16:40:08 2020 So let's take a run at the tables again.

ALL_LEVELS_MACRO args:
  name
  timeoutms
  retrycount
  customreq
  customactive   ? implies ilsActivePacketWrite_LEVEL and ilsActivePacketRead_LEVEL
  customresidual ? implies ilsResidualPacketWrite_LEVEL and ilsResidualPacketRead_LEVEL
  customreact    run when mThem is newer than mUs
  customact      [183: hmm.  :183]

[182: Tue Feb 25 16:50:34 2020 Or how about just

  custompacket   implies ilsPacketWrite_LEVEL(bool act) and ilsPacketRead_LEVEL(bool act)

for active and residual.

:182]

:181]
[185: Wed Feb 26 06:38:06 2020 Go again.

ALL_LEVELS_MACRO args:
  name
  timeoutms
  retrycount
  customreq
  custompacket   implies ilsPacketWrite_LEVEL(bool active) and ilsPacketRead_LEVEL(bool active)
  customreact    run when mThem.mod is newer than mUs.mod
  customact      run when mUs.timeout*retrycount expires?

:185]
[187: Wed Feb 26 13:52:10 2020 Again.

ALL_LEVELS_MACRO args:
  name
  customreq
  customtalk     implies ilsPacketWrite_LEVEL(bool active) and ilsPacketRead_LEVEL(bool active)
  customreact    run when mThem.mod is newer than mUs.mod
  customact      run when mUs.timeout expires; may originate, retry, ...
  timeoutms
  retrycount

ACTIONS:
 ENTER:   S = 0
 ENGAGE:  S = 1
 EXIT:    S = 2
 INIT:    LS = 0.0
 CONTINUE: nothing
 DEFAULT: call default processing

DEFAULT LEVEL VALUES:
  Requires:      t>=(L-1).1
  Talk:          nothing
  React:         (1) L++,S=0 if t>=L.1 && u==L.2; (2) S++ if u <= L.2 && t>=L.0; CONTINUE
  Act:           ENTER if retries-- > 0, else INIT
  TimeoutMS:     500ms
  RetryCount:    3

Level 0 CONTACT
  Requires:      t>=0.0 (always true)
  Talk:          write u.LS, read t.LS
  React:         DEFAULT
  Act:           ENGAGE if S==0 && PacketSync; START if !PacketSync
  TimeoutMS:     1000ms
  RetryCount:    1

Level 1 COMMUNICATION
  Requires:      PacketSync
  Talk:          write u.seqno+u.oseqno, read t.seqno+t.oseqno
  React:         INIT if u.oseqno != t.seqno || u.seqno != t.oseqno, else DEFAULT
  Act:           DEFAULT

Level 2 COMPATIBILITY
  Requires:      DEFAULT
  Talk:          if active, write u.MFZId, read t.MFZId, else write u.d, read t.d
  React:         INIT if u.oseqno != t.seqno || u.seqno != t.oseqno, else DEFAULT
  Act:           DEFAULT


:187]
[188:

Fri Feb 28 04:46:02 2020 Results of fresh thinking yesterday
afternoon: Instead of focusing on turn-taking, avoiding races, and
using rare large timeouts, suppose we should focus on synchronization,
CAUSING races, and using frequent small timeouts.

Ideally you'd like to always have matching packets passing each other
mid-flight; both sides would send and then receive the matching
packet, in that order.

Elaboration: Instead of having arbitrary timeouts with random
variation to avoid races, have fixed timeouts with adaptive phase
shifting to cause races.

So, let's do a synchronization spike.

s1: On PS, pick a random # and send it once a second.  Agree who got
    the bigger number, and have the smaller sync to the larger.

s2: Add a /sys/class/itc/syncstats or something to show recent sync
    accuracy

[189:

Fri Feb 28 13:07:14 2020 So how would kitc sync work?  When we detect
packet sync we pick a non-zero 8 bit random #, and store it in mUs
ITCSideState.  We send a (level) packet containing that # plus a 0,
indicating that we haven't learned the other side's # yet.

When we get such a packet, we check if its number is different than
ours.  If it happens to be the same we start over and repick ours.  If
it's different we store it in mThem ITCSideState.

Then we decide who wins based on wraparound distance between the
numbers -- the one that's 'forward' from the other is the leader.  If
we're the leader we send a 'leader announcement' packet and then set a
timeout in the future by the full period for this interaction.  If
we're the follower we wait to receive one.

When we receive a leader announcement packet we note the time and
schedule a timeout at half the fixed period for this interaction.  At
that time we reply with the matching follower announcement packet of our
own.  When the leader

:189]

:188]
[190:

Fri Feb 28 13:36:35 2020

LRru         reset.  r=my reset generation; u=my rnd byte.  reset in reply
LLrusv       I am leader given r=us resgen, u=us rnd byte; sv=them
Lxrusv       I am x=L:leader|F:follower given rusv (== your svru)
LIsmfz       I am on seqno s and running mfzid mfz
LCsr

:190][191:

Fri Feb 28 14:07:30 2020 Ah, so one advantage of just setting a
timeout and replying in tempo, rather than replying immediately, is
that you get a chance to soak up repeated packets that may have ended
up delayed in the channel somewhere.  If the other guy is repeatedly
sending a reset then timing out and sending another, because we're
still booting or something, then we might get a pile of those resets
in a row, but we'll likely only reply to the last one, because the
the previous ones will just keep pushing back our timeout.[192:

Fri Feb 28 14:31:12 2020 So come on.  How could we set up to implement
this real quick.  The point of it is to agree as quickly as possible
on a half-period spread based on Leader/Follower, and then expect that
for all subsequent interactions, the follower's reply to the leader's
previous packet will have arrived before the leader runs again.

So the level runner loop is:

 - While stop not requested,

   = Pick nearest timeout.

   = If that's now or past, do it, then continue.

   = Otherwise, sleep til the nearer of when it's due or for some max
     sleep, then continue.

and the packet receive handler is:

 - Call packet-specific processing

 - Packet-specific processing generally updates internal state, but it
   does not send packets.  It may adjust the timeout (and it wakes the
   level runner if it shortens any timeout).

Packet-specific processing:

 o On asynchronous reset condition:
   (1) Clear urnd and trnd
   (2) set state to RESET
   (3) set timeout to random small

 = timeout in state RESET
   (1) (Tie do-over)
       if urnd!=0 && trnd!=0 && urnd == trnd then
         async reset, end
   (2) (Election)
       if urnd!=0 && trnd!=0 && urnd != trnd
          && urnd == turnd then
         LEADER = beats(urnd,trnd)
         set state to CONFIG
         clear tmfzid
         push timeout a whole period, end
   (3) (Vote)
       if urnd==0 then
         pick urnd
   (4) send RESET urnd trnd
   (5) push timeout a full period

                                                 - recv RESET trnd turnd:
                                                   (1) captures trnd and turnd
                                                   (2) sets state to RESET
                                                   (3) if turnd==0 then
                                                         clear urnd
                                                   (4) push timeout half-period


                                                  = timeout in state RESET
                                                       ..as above..


 = timeout in state CONFIG
   (1) (Compatibility)
       if LEADER && tmfzid == mfzid
   (2) ()

   (3) send CONFIG mfzid

 - recv CONFIG mfzid
   (1) captures tmfzid = mfzid
   (2)




         if LEADER then
           send CONFIG mfzid



                      async reset->s==?
                         urnd = trnd = 0
                         s = RESET
            +small                             0.0
                      to RESET
                         urnd=3
                         send LR30
                         wait whole     +small    LR30->s==?
                                                    trnd=3, turnd=0
                                                    s=RESET
                                                    urnd=0
                                                    wait half

                                         +half  0.5
                                                    to RESET
                                                       urnd=4
                                                       send LR43
                                                       wait whole
                                         +small

                      LR43->
                        trnd=4, turnd=3
                        s=RESET
                        wait half

                                         +half  1.0
                      to RESET
                         LEADER=beats(3,4)=false
                         s=CONFIG
                         wait whole
                                         +half  1.5 to RESET
                                                       LEADER=beats(4,3)=true
                                                       s=CONFIG
                                         +small        wait whole
                       LCdreg3->



:192]

:191]
[193:

Sat Feb 29 01:58:46 2020

reset
   go LEAD
   randomwait

to LEAD
   send
   go WLEAD                    rc LEAD
   fullwait                       if in(WLEAD) and onein(2) then
                                    reset
to (WLEAD,WCONFIG)                go FOLLOW; halfwait
   reset


                               to FOLLOW
                                  send
                                  go WFOLLOW
                                  fullwait

rc FOLLOW                      to WFOLLOW
   if !in(WLEAD) then             reset
     reset
   else
     go CONFIG; halfwait

to CONFIG
   send config                 rc CONFIG config
   go WCONFIG                     if !in(WFOLLOW) then
   fullwait                         reset
                                  tconfig = config
                                  go CHECK
                                  halfwait


                                to CHECK
to WCONFIG                         send uconfig
   reset                           if uconfig == tconfig then
                                     go COMPATIBLE
                                   else
                                     go INCOMPATIBLE
                                   fullwait


rc CHECK config
   if !in(WCONFIG) then reset
   tconfig = config
   if uconfig == tconfig then
     go COMPATIBLE
   else
     go INCOMPATIBLE
   fullwait

                        to (COMPATIBLE,INCOMPATIBLE)
                          send
                          longwait

rc COMPATIBLE
  if !in(COMPATIBLE) then reset

rc INCOMPATIBLE
  if !in(INCOMPATIBLE) then reset

rc MFMTRAFFIC
  if !in(COMPATIBLE) then drop
  else forward

[194:

Sat Feb 29 03:28:03 2020 OK, well, could that trace actually imply a
pretty heavily simplified but possibly actually workable complete
scheme?  Key ideas are:

 - Whoever resets first tries to be the leader.

 - If a leader race is detected, half the time we accept the later one
   and half the time we re-reset.  Hmm if we both accept the later one
   couldn't we have a FOLLOW-FOLLOW stalemate and lose the reset?[195:
   Sat Feb 29 03:33:38 2020  Well we'll still re-reset a little bit
   later, when 'to FOLLOW' sends, leading to 'rc FOLLOW' when not in
   WLEAD.  "So maybe it's okay?" [196: Sat Feb 29 03:37:25 2020

 - Leader and follower have nearly disjoint sets of states, up until
   COMPATIBLE and INCOMPATIBLE.  That seems a handy way to keep things
   separate, and since the simplified path is so short, the state
   duplication isn't so so much.

 - There's several 'transient' states (at least WLEAD,WFOLLOW,WCONFIG)
   that aren't expected to timeout, so they all just reset if timeout
   does occur.  But they want to be different states to detect
   sequence problems while receiving packets.

:196]:195]


:194]
:193]
[197:

Sat Feb 29 04:15:32 2020 OK so let's try infrastructure to implement
the :193: approach.

 XX(NAME,DESC,CUSTO,CUSRC)

enum StateNumber {
  S_##NAME,
};

enum StateMask {
  M_##NAME = 1<<S_##NAME,
};

const char * stateNames[] = {
 #NAME,
};

const char * stateDesc[] = {
 #DESC,
};

 YY0 void timeoutDefault_KITC(ITCMFMDeviceState * mds) ;
 YY1 void timeout_##NAME##_KITC(ITCMFMDeviceState * mds) ;

 YY##CUSTO(NAME)

 YY0 void receiveDefault_KITC(ITCMFMDeviceState * mds, const u8 * packet, u32 len) ;
 YY1 void receive_##NAME##_KITC(ITCMFMDeviceState * mds, const u8 * packet, u32 len) ;

 YY##CUSRC(NAME)



Default TO: reset
Default TC: reset

Packet format:
 byte[0] 1010SDR  3 bit source/dest dir
 byte[1] 110STNM  5 bit state number
 byte[2]+ optarg

Wait codes
  WC_RANDOM    -> 10..1000ms
  WC_HALF      -> 150ms
  WC_FULL      -> 300ms
  WC_LONG      -> 10000ms

Helper functions:

 void goToStateKITC(ITCMFMDeviceState * mds, StateNumber sn, WaitCode wc) ;
 u32 initPacketKITC(ITCMFMDeviceState * mds, const char * pb) ;
 void resetKITC(ITCMFMDeviceState *mds) ;
 void pushTimeoutKITC(ITCMFMDeviceState * mds, u32 msFromNow) ;

 bool passingMFMTrafficKITC(ITCMFMDeviceState * mds) ;

:197]
[198:

Sun Mar  1 03:55:59 2020 OK, back after diverting to push the Michael
Frank Computing Up.  I have MAYBE one more day I can spend on this.
Based on :193: and :197: we should be able to get to passing MFM
packets only when compatible.  Let's get foggen kraken:

TODO

[199: Sun Mar  1 04:53:38 2020
DONE :199] - Redo XX macros based on :197:

[200: Sun Mar  1 04:57:27 2020
DONE :200] - Redo side struct

[201: Sun Mar  1 04:57:40 2020 
DONE :201] - Redo state ops struct

[202: Sun Mar  1 05:34:20 2020
DONE, first cut :202] - Redo level runner.

[204: Sun Mar  1 16:06:11 2020
DONE :204] - Implement default behaviors

[205:
DONE :205] - Implement custom behaviors

 - Redo event tracing

[226: Mon Mar  2 04:30:37 2020
DONE :226] - See loopback events to compatibility

:198]
[203:

Sun Mar  1 16:05:58 2020 Well, it built..[206: Sun Mar  1 16:06:32
2020  Next up is pull bits off and trying it, but about it's time to
cook so that'll be after the evening.  :206]

:203]
[207:

Mon Mar  2 00:48:31 2020 'Real quick' let's add a state at the
beginning that waits for PS.

reset
   go WAITPS
   randomwait

to WAITPS
   if PS go LEAD   
   longwait

[208:

Mon Mar  2 01:26:05 2020 OK well did that.

Left it so the 'if PS go LEAD' doesn't actually push the timeout, so
it'll (race to) retimeout and do 'to LEAD' immediately.  Seems
inefficient but rare.

Well, I think we're at

RISKY BITS OFF

:208]
:207]
[209:

Mon Mar  2 01:31:37 2020 OK trying make install.[210:

Mon Mar  2 01:34:24 2020 Well, modprobe itc_pkt blew up with 

    Mar  2 01:33:49 beaglebone kernel: [582362.953671] kernel BUG at /home/t2/T2-12/pru/itcio/module/itcpkt.c:2126!

I think because we still have issues with minor devices not getting
cleaned up quite right, or something..

..so rebooting.. we shall see.

:210]

:209]
[211:

Mon Mar  2 01:38:27 2020 Well we're alive..  Not sure what if anything
we'll be able to see, here, before we redo the kitc event
tracing.. but about to try plugging in the loopback..[212:

Mon Mar  2 01:39:39 2020 Well that was a bit of an anticlimax:

    Mar  2 01:39:22 beaglebone mfm.sh[1767]: ITCSPIKE-92103199200283: MSG: Tile Level 2: Accepting events
    Mar  2 01:39:22 beaglebone kernel: [  190.884393] ITCCHANGE:UP:WT
    Mar  2 01:39:22 beaglebone kernel: [  190.887379] ITCCHANGE:UP:ET
    Mar  2 01:39:25 beaglebone mfm.sh[1767]: ITCSPIKE-92103199200284: MSG: Tile Level 0: Quitting
    Mar  2 01:39:25 beaglebone mfm.sh[1767]: ITCSPIKE-92103199200285: MSG: Tile Level 1: Starting MFZ1
    Mar  2 01:39:26 beaglebone mfm.sh[1767]: ITCSPIKE-92103199200286: MSG: Tile Level 2: Accepting events
    Mar  2 01:39:28 beaglebone cdm.sh[1768]: WT is alive
    Mar  2 01:39:31 beaglebone kernel: [  199.643244] ITCCHANGE:DOWN:ET
    Mar  2 01:39:32 beaglebone kernel: [  200.065467] ITCCHANGE:DOWN:WT
    Mar  2 01:39:42 beaglebone mfm.sh[1767]: ITCSPIKE-92103199200287: MSG: Tile Level 0: Quitting

[213:

Mon Mar  2 01:43:31 2020 OK!  This is more like it:

    root@beaglebone:~# echo f00 > /sys/class/itc_pkt/debug ; sleep 10; echo 0 > /sys/class/itc_pkt/debug 
    Mar  2 01:43:01 beaglebone kernel: [  409.703717] set debug f00
    Mar  2 01:43:05 beaglebone kernel: [  413.731031] ITCCHANGE:UP:WT
    Mar  2 01:43:05 beaglebone kernel: [  413.733950] recvLevelPacket us=WAITPS pkt=CHECK+3
    Mar  2 01:43:05 beaglebone kernel: [  413.738857] ITCCHANGE:UP:ET
    Mar  2 01:43:05 beaglebone kernel: [  413.741684] recvLevelPacket us=WAITPS pkt=LEAD+2
    Mar  2 01:43:05 beaglebone kernel: [  413.746414] ====================
    Mar  2 01:43:05 beaglebone kernel: [  413.898190] ====================
    Mar  2 01:43:05 beaglebone kernel: [  413.901718] recvLevelPacket us=WAITPS pkt=FOLLOW+2
    Mar  2 01:43:05 beaglebone kernel: [  413.916777] ====================
    Mar  2 01:43:05 beaglebone kernel: [  413.962188] ====================
    Mar  2 01:43:05 beaglebone kernel: [  413.965505] ====================
    Mar  2 01:43:05 beaglebone kernel: [  413.979559] ====================
    Mar  2 01:43:05 beaglebone kernel: [  413.983064] recvLevelPacket us=WFOLLOW pkt=LEAD+2
    Mar  2 01:43:06 beaglebone kernel: [  414.138215] ====================
    Mar  2 01:43:06 beaglebone kernel: [  414.141727] recvLevelPacket us=WLEAD pkt=FOLLOW+2
    Mar  2 01:43:06 beaglebone kernel: [  414.155589] ====================
    Mar  2 01:43:06 beaglebone cdm.sh[1768]: ET is alive
    Mar  2 01:43:06 beaglebone kernel: [  414.298356] ====================
    Mar  2 01:43:06 beaglebone kernel: [  414.301886] recvLevelPacket us=WFOLLOW pkt=CONFIG+3
    Mar  2 01:43:06 beaglebone kernel: [  414.312771] ====================
    Mar  2 01:43:06 beaglebone kernel: [  414.458326] ====================
    Mar  2 01:43:06 beaglebone kernel: [  414.461871] recvLevelPacket us=WCONFIG pkt=CHECK+3
    Mar  2 01:43:06 beaglebone kernel: [  414.470568] ====================
    Mar  2 01:43:06 beaglebone kernel: [  414.618371] ====================
    Mar  2 01:43:06 beaglebone kernel: [  414.621929] recvLevelPacket us=COMPATIBLE pkt=COMPATIBLE+2
    Mar  2 01:43:06 beaglebone kernel: [  414.635653] ====================
    Mar  2 01:43:07 beaglebone kernel: [  415.250604] ====================
    Mar  2 01:43:07 beaglebone kernel: [  415.253913] ====================
    Mar  2 01:43:07 beaglebone kernel: [  415.270779] ====================
    Mar  2 01:43:07 beaglebone kernel: [  415.286664] ====================
    Mar  2 01:43:07 beaglebone kernel: [  415.289939] ====================
    Mar  2 01:43:09 beaglebone kernel: [  417.696325] recvLevelPacket us=COMPATIBLE pkt=INIT+2
    Mar  2 01:43:09 beaglebone kernel: [  417.701777] ====================
    Mar  2 01:43:09 beaglebone kernel: [  417.878615] ITCCHANGE:DOWN:ET
    Mar  2 01:43:09 beaglebone kernel: [  417.881780] ====================
    Mar  2 01:43:10 beaglebone kernel: [  418.227540] ====================
    Mar  2 01:43:10 beaglebone kernel: [  418.230850] ====================
    Mar  2 01:43:10 beaglebone kernel: [  418.304749] ITCCHANGE:DOWN:WT
    Mar  2 01:43:10 beaglebone kernel: [  418.931750] ====================
    Mar  2 01:43:11 beaglebone kernel: [  419.115792] ====================
    Mar  2 01:43:11 beaglebone kernel: [  419.119101] ====================
    root@beaglebone:~# Mar  2 01:43:11 beaglebone kernel: [  419.740930] set debug 0


:213]
:212]

:211]
[214:

Mon Mar  2 02:16:13 2020 Buncha quick tweaks

RISKY BITS OFF[215:

Mon Mar  2 02:17:26 2020 No good, minor blow-up again..  Rebooting.

:215]

:214]
[216:

Mon Mar  2 02:23:13 2020 OK, this is more interesting:

    root@beaglebone:~# echo f00 > /sys/class/itc_pkt/debug ; sleep 10; echo 0 > /sys/class/itc_pkt/debug 
    Mar  2 02:20:59 beaglebone kernel: [  182.866584] set debug f00
    Mar  2 02:21:02 beaglebone kernel: [  185.064507] ITCCHANGE:UP:WT
    Mar  2 02:21:02 beaglebone kernel: [  185.067449] ITCCHANGE:DOWN:WT
    Mar  2 02:21:02 beaglebone kernel: [  185.070445] ITCCHANGE:UP:WT
    Mar  2 02:21:02 beaglebone kernel: [  185.073386] ITCCHANGE:UP:ET
    Mar  2 02:21:02 beaglebone kernel: [  185.076247] ITCCHANGE:DOWN:ET

I bobbled plugging the loopback connection creating some realistic
chatter.. 

    Mar  2 02:21:02 beaglebone kernel: [  185.079237] ITCCHANGE:UP:ET
    Mar  2 02:21:02 beaglebone kernel: [  185.082116] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.090002] ITC ET i11 -> i01

..lock stuff is happening as well..

    Mar  2 02:21:02 beaglebone kernel: [  185.167550] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.173910] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.187595] sendKITCPacket pkt=LEAD len=2 (to=WT)

WT reached 'to LEAD' first.  (That should be '(src=WT)' rather than
'to').

    Mar  2 02:21:02 beaglebone kernel: [  185.199410] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.511405] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.517749] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.548236] recvKITCPacket pkt=LEAD len=2 (us=[ET]WAITPS)

Packet arrives via loopback.  It took (- 185.548236 185.187595) ==
360ms, but hoping that's somehow got to do with 'WC_FULL_MS = 300,'...

Note that ET is in the 'new, last minute' WAITPS state -- it hasn't
even noticed the '[ 185.079237] ITCCHANGE:UP:ET' yet..

    Mar  2 02:21:02 beaglebone kernel: [  185.553866] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.619470] ITC ET i11 -> i01
    Mar  2 02:21:02 beaglebone kernel: [  185.703457] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:02 beaglebone kernel: [  185.709836] sendKITCPacket pkt=FOLLOW len=2 (to=ET)

ET agrees it's the follower.

    Mar  2 02:21:02 beaglebone kernel: [  185.714890] recvKITCPacket pkt=FOLLOW len=2 (us=[WT]WAITPS)

This packet arrives a bit faster:  (- 185.714890 185.709836) == 5ms.

But why is WT in WAITPS?  It sent 'LEAD': We expect it to be in
WLEAD.  Not sure what's going on there -- WAITPS is now entered
asynchronously through resetKITC(), but what caused the reset?

    Mar  2 02:21:02 beaglebone kernel: [  185.727470] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.055463] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.063535] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.179476] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.185812] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.203717] recvKITCPacket pkt=LEAD len=2 (us=[WT]WAITPS)

That's confusing too.  ET now thinking it's the cheese?

    Mar  2 02:21:03 beaglebone kernel: [  186.209285] sendKITCPacket pkt=LEAD len=2 (to=ET)

And are we having a race or something?

    Mar  2 02:21:03 beaglebone kernel: [  186.229741] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.359494] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.365897] sendKITCPacket pkt=FOLLOW len=2 (to=WT)
    Mar  2 02:21:03 beaglebone kernel: [  186.370957] recvKITCPacket pkt=FOLLOW len=2 (us=[ET]WLEAD)

ET was in WLEAD this time, seems like some sanity is coming.. 

    Mar  2 02:21:03 beaglebone kernel: [  186.389138] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.527493] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.533878] sendKITCPacket pkt=CONFIG len=3 (to=ET)
    Mar  2 02:21:03 beaglebone kernel: [  186.538932] recvKITCPacket pkt=CONFIG len=3 (us=[WT]WFOLLOW)

We've gotten to CONFIG!  (Note the 'len=3' means userspace never
actually wrote us a config, so we're just sending the null byte after
the header.. so this really should fail, but..)
    
    Mar  2 02:21:03 beaglebone kernel: [  186.561834] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone mfm.sh[1770]: ITCSPIKE-92103199826940: MSG: Tile Level 0: Quitting
    Mar  2 02:21:03 beaglebone kernel: [  186.695534] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.703682] sendKITCPacket pkt=CHECK len=3 (to=WT)

WT has gotten to CHECK!  It's sending the empty config too!

    Mar  2 02:21:03 beaglebone kernel: [  186.708670] recvKITCPacket pkt=CHECK len=3 (us=[ET]WCONFIG)
    Mar  2 02:21:03 beaglebone kernel: [  186.730005] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.863525] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:03 beaglebone kernel: [  186.869654] sendKITCPacket pkt=COMPATIBLE len=2 (to=ET)

ET has gotten to COMPATIBLE!  Neither of us has a config?  Let's rock!

    Mar  2 02:21:03 beaglebone kernel: [  186.875116] recvKITCPacket pkt=COMPATIBLE len=2 (us=[WT]COMPATIBLE)
    Mar  2 02:21:03 beaglebone kernel: [  186.890726] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:04 beaglebone kernel: [  187.209416] ITCCHANGE:DOWN:ET

And I apparently yanked the cable before longwait had passed for west..

    Mar  2 02:21:04 beaglebone kernel: [  187.212613] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:04 beaglebone mfm.sh[1770]: ITCSPIKE-92103199826941: MSG: Tile Level 1: Starting MFZ2
    Mar  2 02:21:04 beaglebone mfm.sh[1770]: ITCSPIKE-92103199826942: MSG: Tile Level 2: Accepting events
    Mar  2 02:21:04 beaglebone kernel: [  187.610711] ITCCHANGE:DOWN:WT
    Mar  2 02:21:04 beaglebone kernel: [  187.613950] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:05 beaglebone kernel: [  188.327645] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:05 beaglebone kernel: [  188.333930] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:05 beaglebone kernel: [  188.839689] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:05 beaglebone kernel: [  188.845978] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:07 beaglebone kernel: [  190.247923] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:07 beaglebone kernel: [  190.254410] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:07 beaglebone kernel: [  190.271865] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:07 beaglebone kernel: [  190.287912] ===kitcTimeoutThreadRunner===
    Mar  2 02:21:07 beaglebone kernel: [  190.299931] ===kitcTimeoutThreadRunner===
    root@beaglebone:~# Mar  2 02:21:09 beaglebone kernel: [  192.901094] set debug 0
    Mar  2 02:21:22 beaglebone mfm.sh[1770]: ITCSPIKE-92103199826943: MSG: Tile Level 0: Quitting

[217:

Mon Mar  2 02:47:34 2020 So this is all very promising.  Lots to fix
up; first up we mostly need better state machine transition logging.

But only a couple more scant hours on this before we have to switch to
science for the next two weeks!

:217]
:216]
[218:

Mon Mar  2 02:59:12 2020 RISKY BITS OFF

:218]
[219:

Mon Mar  2 03:04:50 2020 OK now this:

    Mar  2 03:04:09 beaglebone mfm.sh[1751]: ITCSPIKE-92103197045749: MSG: Tile Level 2: Accepting events
    Mar  2 03:04:13 beaglebone kernel: [  124.060426] ITCCHANGE:UP:WT
    Mar  2 03:04:13 beaglebone kernel: [  124.063410] ITCCHANGE:UP:ET
    Mar  2 03:04:13 beaglebone kernel: [  124.068769] ITC ET i11 -> i01
    Mar  2 03:04:15 beaglebone kernel: [  125.209753] kitcTimeoutThreadRunner: [ET] to WAITPS

ET gets timeout while in WAITPS.

    Mar  2 03:04:15 beaglebone kernel: [  125.217975] setStateKITC: [ET] WAITPS->LEAD

ET advances to LEAD (without pushing the timeout.)

    Mar  2 03:04:15 beaglebone kernel: [  125.237827] kitcTimeoutThreadRunner: [ET] to LEAD

So 'to LEAD' hits after 'only' (- 125.237827 125.217975) ~20ms..

    Mar  2 03:04:15 beaglebone kernel: [  125.253980] sendKITCPacket pkt=LEAD len=2 (src=ET)

ET ships LEAD.

    Mar  2 03:04:15 beaglebone kernel: [  125.258990] recvKITCPacket rc LEAD len=2 (us=[WT]WAITPS)

WT gets it 5ms later.

    Mar  2 03:04:15 beaglebone kernel: [  125.264371] setStateKITC: [WT] WAITPS->FOLLOW

And decides to follow.

    Mar  2 03:04:15 beaglebone kernel: [  125.281238] setStateKITC: [ET] LEAD->WLEAD

This is coming from the same 'to LEAD' that did the send!  The
previous two [WT] events happened at 'interrupt level' via the packet
callback?  

Maybe we should updates states and timeouts first, and send packets
last?  Could we do that?  Just for sanity?[220: Mon Mar  2 03:17:40
2020 No, we can't cleanly, because we pack our current state in during
the send.  Could we have a shipCurrentStateAndSwitchToNewState?  [221:

Mon Mar  2 03:21:10 2020 No actually we can do it as is -- our state
ON ENTRY TO THE TIMEOUT is what's in the PacketHandler.  It IS okay to 
change our state and timeout and then ship the packet.[222:

Mon Mar  2 03:24:27 2020 Although it will be kind of confusing, since
we'll now see the state change to some new state, while broadcasting
its previous state.  So be it, though, for a test anyway.

:222]

:221]:220]

    Mar  2 03:04:15 beaglebone kernel: [  125.417800] kitcTimeoutThreadRunner: [WT] to FOLLOW
    Mar  2 03:04:15 beaglebone kernel: [  125.426123] sendKITCPacket pkt=FOLLOW len=2 (src=WT)
    Mar  2 03:04:15 beaglebone kernel: [  125.431301] recvKITCPacket rc FOLLOW len=2 (us=[ET]WLEAD)
    Mar  2 03:04:15 beaglebone kernel: [  125.436772] setStateKITC: [ET] WLEAD->CONFIG
    Mar  2 03:04:15 beaglebone kernel: [  125.453958] setStateKITC: [WT] FOLLOW->WFOLLOW
    Mar  2 03:04:15 beaglebone kernel: [  125.589892] kitcTimeoutThreadRunner: [ET] to CONFIG
    Mar  2 03:04:15 beaglebone kernel: [  125.597969] sendKITCPacket pkt=CONFIG len=3 (src=ET)
    Mar  2 03:04:15 beaglebone kernel: [  125.603130] recvKITCPacket rc CONFIG len=3 (us=[WT]WFOLLOW)
    Mar  2 03:04:15 beaglebone kernel: [  125.608773] setStateKITC: [WT] WFOLLOW->CHECK
    Mar  2 03:04:15 beaglebone kernel: [  125.625987] setStateKITC: [ET] CONFIG->WCONFIG
    Mar  2 03:04:15 beaglebone kernel: [  125.761876] kitcTimeoutThreadRunner: [WT] to CHECK
    Mar  2 03:04:15 beaglebone kernel: [  125.769932] sendKITCPacket pkt=CHECK len=3 (src=WT)
    Mar  2 03:04:15 beaglebone kernel: [  125.774996] recvKITCPacket rc CHECK len=3 (us=[ET]WCONFIG)
    Mar  2 03:04:15 beaglebone kernel: [  125.780552] setStateKITC: [ET] WCONFIG->COMPATIBLE
    Mar  2 03:04:15 beaglebone kernel: [  125.793901] setStateKITC: [WT] CHECK->COMPATIBLE
    Mar  2 03:04:15 beaglebone kernel: [  125.933963] kitcTimeoutThreadRunner: [ET] to COMPATIBLE
    Mar  2 03:04:15 beaglebone kernel: [  125.941985] sendKITCPacket pkt=COMPATIBLE len=2 (src=ET)
    Mar  2 03:04:15 beaglebone kernel: [  125.947484] recvKITCPacket rc COMPATIBLE len=2 (us=[WT]COMPATIBLE)


:219]
[223:

Mon Mar  2 03:43:59 2020 RISKY BITS OFF

:223]
[224:

Mon Mar  2 03:49:02 2020 Now it looks like this:

    echo f00 > /sys/class/itc_pkt/debug ; sleep 10; echo 0 > /sys/class/itc_pkt/debug 
    Mar  2 03:48:26 beaglebone kernel: [  170.300188] set debug f00
    Mar  2 03:48:29 beaglebone kernel: [  173.076623] ITCCHANGE:UP:WT
    Mar  2 03:48:29 beaglebone kernel: [  173.079592] ITCCHANGE:UP:ET
    Mar  2 03:48:29 beaglebone kernel: [  173.127075] ITC ET i11 -> i01
    Mar  2 03:48:29 beaglebone kernel: [  173.283083] kitcTimeoutThreadRunner: [ET] to WAITPS
    Mar  2 03:48:29 beaglebone kernel: [  173.291328] setStateKITC: [ET] WAITPS->LEAD

ET times out and heads for LEAD.

    Mar  2 03:48:29 beaglebone kernel: [  173.307756] kitcTimeoutThreadRunner: [ET] to LEAD
    Mar  2 03:48:29 beaglebone kernel: [  173.327076] setStateKITC: [ET] LEAD->WLEAD
    Mar  2 03:48:29 beaglebone kernel: [  173.341528] sendKITCPacket pkt=LEAD len=2 (src=ET)

ET heads for WLEAD while sending LEAD.

    Mar  2 03:48:29 beaglebone kernel: [  173.346599] recvKITCPacket rc LEAD len=2 (us=[WT]WAITPS)
    Mar  2 03:48:29 beaglebone kernel: [  173.351996] setStateKITC: [WT] WAITPS->FOLLOW

WT receives ET's LEAD, heads for follow.

    Mar  2 03:48:29 beaglebone mfm.sh[1788]: ITCSPIKE-92103196894224: MSG: Tile Level 0: Quitting
    Mar  2 03:48:29 beaglebone mfm.sh[1788]: ITCSPIKE-92103196894225: MSG: Tile Level 1: Starting MFZ1

    Mar  2 03:48:29 beaglebone kernel: [  173.507069] kitcTimeoutThreadRunner: [WT] to FOLLOW
    Mar  2 03:48:29 beaglebone kernel: [  173.519151] setStateKITC: [WT] FOLLOW->WFOLLOW
    Mar  2 03:48:29 beaglebone kernel: [  173.535187] sendKITCPacket pkt=FOLLOW len=2 (src=WT)

WT times out and heads for WFOLLOW, while sending FOLLOW

    Mar  2 03:48:29 beaglebone kernel: [  173.540366] recvKITCPacket rc FOLLOW len=2 (us=[ET]WLEAD)
    Mar  2 03:48:29 beaglebone kernel: [  173.545854] setStateKITC: [ET] WLEAD->CONFIG

ET sees the follow and heads for CONFIG.

    Mar  2 03:48:29 beaglebone mfm.sh[1788]: ITCSPIKE-92103196894226: MSG: Tile Level 2: Accepting events
    Mar  2 03:48:29 beaglebone kernel: [  173.699093] kitcTimeoutThreadRunner: [ET] to CONFIG
    Mar  2 03:48:29 beaglebone kernel: [  173.707174] setStateKITC: [ET] CONFIG->WCONFIG
    Mar  2 03:48:29 beaglebone kernel: [  173.719198] sendKITCPacket pkt=CONFIG len=3 (src=ET)

ET times out and heads for WCONFIG, while sending its (still
non-existent) CONFIG.

    Mar  2 03:48:29 beaglebone kernel: [  173.724385] recvKITCPacket rc CONFIG len=3 (us=[WT]WFOLLOW)
    Mar  2 03:48:29 beaglebone kernel: [  173.730041] setStateKITC: [WT] WFOLLOW->CHECK

WT sees the CONFIG and heads for CHECK.

    Mar  2 03:48:29 beaglebone kernel: [  173.883075] kitcTimeoutThreadRunner: [WT] to CHECK
    Mar  2 03:48:29 beaglebone kernel: [  173.891053] setStateKITC: [WT] CHECK->COMPATIBLE
    Mar  2 03:48:29 beaglebone kernel: [  173.913417] sendKITCPacket pkt=CHECK len=3 (src=WT)

WT times out and heads for COMPATIBLE, while sending its non-existent
config in a CHECK packet.

    Mar  2 03:48:29 beaglebone kernel: [  173.918517] recvKITCPacket rc CHECK len=3 (us=[ET]WCONFIG)
    Mar  2 03:48:29 beaglebone kernel: [  173.924078] setStateKITC: [ET] WCONFIG->COMPATIBLE

ET sees the CHECK and heads for COMPATIBLE.

    Mar  2 03:48:30 beaglebone kernel: [  174.079151] kitcTimeoutThreadRunner: [ET] to COMPATIBLE
    Mar  2 03:48:30 beaglebone kernel: [  174.087220] sendKITCPacket pkt=COMPATIBLE len=2 (src=ET)

ET times out and sends COMPATIBLE, remaining in that state.

    Mar  2 03:48:30 beaglebone kernel: [  174.092712] recvKITCPacket rc COMPATIBLE len=2 (us=[WT]COMPATIBLE)

WT sees the COMPATIBLE, and remains in that state too.

 ..
    Mar  2 03:48:32 beaglebone mfm.sh[1788]: ITCSPIKE-92103196894241: MSG: Tile EVENT INPUT?
    Mar  2 03:48:33 beaglebone kernel: [  177.271330] ITCCHANGE:DOWN:ET

I pull the loopback and ET goes down..

    Mar  2 03:48:33 beaglebone kernel: [  177.274375] setStateKITC: [ET] COMPATIBLE->WAITPS

..and ET goes back to WAITPS

    Mar  2 03:48:33 beaglebone kernel: [  177.595304] kitcTimeoutThreadRunner: [ET] to WAITPS

ET times out in WAITPS, but just remains there.

    Mar  2 03:48:33 beaglebone kernel: [  177.636014] ITCCHANGE:DOWN:WT
    Mar  2 03:48:33 beaglebone kernel: [  177.639036] setStateKITC: [WT] COMPATIBLE->WAITPS

WT goes down and heads for WAITPS

    Mar  2 03:48:33 beaglebone kernel: [  177.687386] kitcTimeoutThreadRunner: [WT] to WAITPS

WT times out, remains in WAITPS.

    Mar  2 03:48:36 beaglebone kernel: [  180.219495] kitcTimeoutThreadRunner: [NW] to WAITPS
    Mar  2 03:48:36 beaglebone kernel: [  180.227764] kitcTimeoutThreadRunner: [SW] to WAITPS
    Mar  2 03:48:36 beaglebone kernel: [  180.249677] kitcTimeoutThreadRunner: [NE] to WAITPS
    Mar  2 03:48:36 beaglebone kernel: [  180.265854] kitcTimeoutThreadRunner: [SE] to WAITPS

Then, we see the other dirs timing out too -- making their first and
only appearances since we turned on debug output.

    root@beaglebone:~# Mar  2 03:48:36 beaglebone kernel: [  180.331808] set debug 0

Which we then turned off, 10 seconds after we started..

:224]
[225:

Mon Mar  2 04:03:22 2020 Well, so that's all pretty damn satisfying.
I think we can leave it there for a while without undue shame.

Cleaning up for commit.  Actually, committing dirty and then cleaning
up. 

:225]
[227:

Mon Mar  2 04:54:11 2020 Randomizing WC_LONG.. Seeing repeated
patterns in the 'to WAITPS' that I don't like just on principle.

:227]
[228:

Mon Mar  2 04:56:40 2020 OK, I have to let this go.  For when we get
back, let's now do some

TODO

 - t2trace is rotted

[240: Sat Mar 21 10:48:59 2020
DONE, simplified :240] - There's a design question about the whole sidestate mUs/mThem
   thing.  We're using hardly any of it.  Do we really want to keep
   it?  If so can we simplify it.

[241: Sat Mar 21 10:49:12 2020
DONE, ditched :241] - There's a lot of 'level' nomenclature that mostly doesn't make
   sense now that we've simplified the protocol.

 - The MFMToken is not being used at all.  Should we exchange it in
   CONFIG/CHECK or some other packet?

 - Should we have a randomized-on-reset one byte nonce for all
   packets, to help ensure we're on the same page regardless of huge
   packet losses or whatever?

Committing and switching to science.

:228]
[229:

Sat Mar 21 04:18:10 2020 OK, well, now it's 19 days later.  It's
COVID-19 days later, and we're in a different world.  The ALIFE2020
conference has become an online-only 'virtual' conference, and the
paper deadline has been pushed back to May 1, so we're back on
intertile events here for the next few days anyway.

Right now I'd like to see a clean up in itc_pkt and then a userspace
spike that demonstrates event locking.  And in particular I'd like to
see userspace design heading towards having multiple events in
progress with fine-grained locks.

Rule is once itc_pkt opens the gate, we can no longer touch any
visible sites without having an event window lock covering that site.
We can try to grab non-overlapping event window locks--even intertile
ones perhaps involving other tiles with which we already have active
locks.
[230:

Sat Mar 21 09:59:51 2020 OK, mini-

TODO

[231: Sat Mar 21 10:08:05 2020
DONE :231] - Merge ITCSideState into ITCLevelState, ditching unused fields

[232: Sat Mar 21 10:11:13 2020
DONE :232] - Get that building

[233: Sat Mar 21 10:18:43 2020
DONE :233] - Rename ITCLevelState to (just) ITCState?

[237: Sat Mar 21 10:44:00 2020
DONE :237] - Get that working

[238: Sat Mar 21 10:46:55 2020
DONE :238] - Commit

[242: Sat Mar 21 11:00:02 2020 
DONE :242] - Make more to-do

:230]
:229]
[234:

Sat Mar 21 10:23:15 2020 OK so I guess we need to test this, so it's
time once again to set up for our checklist-mandated procedure:

RISKY BITS OFF
[235:

Sat Mar 21 10:26:39 2020 Installing..

:235]
:234]
[236:

Sat Mar 21 10:43:18 2020 Seems okay after rebooting.  

:236]
[239:

Sat Mar 21 10:47:05 2020 OK, so after that palate cleanser, more

TODO

[251: Sat Mar 21 14:20:07 2020
DONE :251] - Unrot t2trace

[252: Sat Mar 21 14:20:11 2020
DONE :252] - Observe successful ITC negotiation with it

 - Observe failed ITC negotiation with it

 - Refresh brain on state of userspace spike

 - Commit

 - Make more todo

:239]
[243:

Sat Mar 21 11:04:05 2020 OK digging into t2trace.  Looks like the
events for KITC are pretty limited and incomplete, so a first task
here might be to list what sort of stuff we want, exactly.

But first, blunch.
[244:

Sat Mar 21 11:40:27 2020 OK, so we want timeout-in-state and
type-of-packet-received events at the least.  Let's just get that
going and see what else if anything we might want.[245:

Sat Mar 21 11:52:18 2020 OK, at the moment so we have

    static inline __u32 makeItcLSEvent(__u32 dir6, __u32 usNotThem, __u32 ls) {
      return ((dir6&0x7)<<6) | ((usNotThem&0x1)<<5) | ((ls&0x1f)<<0);
    }

    static inline __u32 makeItcDirEvent(__u32 dir6, __u32 op) {
      return ((6&0x7)<<6) | ((op&0x7)<<3) | ((dir6&0x7)<<0);
    }

    static inline __u32 makeItcSpecEvent(__u32 spec) {
      return ((7&0x7)<<6) | ((spec&0x3f)<<0);
    }

but since level-stage has gone away we get to repurpose those states.
So I guess it's really a full 6 bits (==64) of KITC-specific events,
plus 2 * 6 bits (==128) of non-spatial 'special' events.

Seems like super-overkill sitting here now.  We'll see.  
[246:

Sat Mar 21 12:13:53 2020 Given that we've got 11 states, let's go with
4 bits for state and have 2 bits for op-within-state -- although
beyond just 'ENTER' I'm not sure what we'll have for 'op'.

:246]
:245]

:244]
:243]
[247:

Sat Mar 21 13:10:29 2020 Well, now perhaps generating some new-style
KITC state events for ENTER, TIMEOUT, and RECEIVE...  Let's push on
t2trace.cpp some.[248:

Sat Mar 21 13:29:38 2020 OK, going for a try.

RISKY BITS OFF

:248]

:247]
[249:

Sat Mar 21 14:00:54 2020 Tweaking events.  Getting there.

RISKY BITS OFF

:249]
[250:

So okay, getting plausible traces:

    0009 5.691466sec   +3msec 18b:K (WT) ITCUP: packet sync acquired
    0010 5.694419sec   +2msec 188:K (ET) ITCUP: packet sync acquired

Plugged in the loopback..

    0011 5.717148sec  +22msec 037:L     [WT sSYNC01]
    0012 5.717148sec   +0usec 0b8:L         WT_ORQLK-
    0013 5.717152sec   +4usec 18e:L LALST: all locks settled
    0014 5.717176sec  +24usec 080:L -ET_IRQLK
    0015 5.717176sec   +0usec 007:L     [ET sSYNC01]
    0016 5.717176sec   +0usec 088:L         ET_ORQLK-
    0017 5.717176sec   +0usec 18e:L LALST: all locks settled
    0018 5.717185sec   +8usec 0b0:L -WT_IRQLK
    0019 5.717189sec   +4usec 033:L     [WT sIDLE]
    0020 5.717189sec   +0usec 0bc:L         WT_OGRLK-
    0021 5.717189sec   +0usec 18e:L LALST: all locks settled
    0022 5.717197sec   +8usec 084:L -ET_IGRLK
    0023 5.717197sec   +0usec 003:L     [ET sIDLE]
    0024 5.717197sec   +0usec 08c:L         ET_OGRLK-
    0025 5.717197sec   +0usec 18e:L LALST: all locks settled
    0026 5.717209sec  +12usec 0b4:L -WT_IGRLK

Lock negotiation happened next..

    0027 6.977343sec   +1secs 0d1:K [WT:WAITPS] TIMEOUT

A whole second later West KITC finally timed out..

    0028 6.977348sec   +4usec 0c2:K [WT:LEAD] ENTER
    0029 6.977348sec   +0usec 0d2:K [WT:LEAD] TIMEOUT

..entered LEAD and timed out again immediately..

    0030 6.977352sec   +4usec 0c3:K [WT:WLEAD] ENTER

..and entered WLEAD (waiting after lead)..

    0031 6.977368sec  +16usec 0f2:K [WT:LEAD] SEND

..after (?) announcing its LEAD state.

    0032 6.977421sec  +53usec 0d6:P   <WT to PRU 2-4>

..that packet ships..

    0033 6.977581sec +159usec 021:K [ET:WAITPS] RECEIVE

..East KITC gets notified..

    0034 6.977585sec   +4usec 004:K [ET:FOLLOW] ENTER
    0035 7.129379sec +151msec 014:K [ET:FOLLOW] TIMEOUT

..enters FOLLOW and times out again..

    0036 7.129383sec   +4usec 005:K [ET:WFOLLOW] ENTER
    0037 7.129399sec  +16usec 034:K [ET:FOLLOW] SEND

..and enters waiting after follow while announcing follow.

    0038 7.129457sec  +57usec 0d2:P   <ET to PRU 2-4>

..the packet ships..

    0039 7.129616sec +159usec 0e3:K [WT:WLEAD] RECEIVE

Same deal.  West, waiting after lead, receives it

    0040 7.129620sec   +4usec 0c6:K [WT:CONFIG] ENTER
    0041 7.281406sec +151msec 0d6:K [WT:CONFIG] TIMEOUT
    0042 7.281410sec   +4usec 0c7:K [WT:WCONFIG] ENTER
    0043 7.281426sec  +16usec 0f6:K [WT:CONFIG] SEND
    0044 7.281480sec  +53usec 0d6:P   <WT to PRU 2-4>

..and enters waiting after config while announcing config.

    0045 7.281619sec +139usec 025:K [ET:WFOLLOW] RECEIVE
    0046 7.281623sec   +4usec 008:K [ET:CHECK] ENTER
    0047 7.433462sec +151msec 018:K [ET:CHECK] TIMEOUT
    0048 7.433466sec   +4usec 009:K [ET:COMPATIBLE] ENTER
    0049 7.433474sec   +8usec 038:K [ET:CHECK] SEND
    0050 7.433507sec  +32usec 0d2:P   <ET to PRU 2-4>

..receiving the config, East determines we have compatibility, while
announcing CHECK.

    0051 7.433613sec +106usec 0e7:K [WT:WCONFIG] RECEIVE
    0052 7.433617sec   +4usec 0c9:K [WT:COMPATIBLE] ENTER
    0053 7.585563sec +151msec 0d9:K [WT:COMPATIBLE] TIMEOUT
    0054 7.585579sec  +16usec 0f9:K [WT:COMPATIBLE] SEND
    0055 7.585649sec  +69usec 0d6:P   <WT to PRU 2-4>

..West receives check, determines we have compatibility, and announces
compatibility.. 

    0056 7.585780sec +131usec 029:K [ET:COMPATIBLE] RECEIVE

..East notices West noticed we have compatibility.

    0057 8.194359sec +608msec 111:K [NW:WAITPS] TIMEOUT
    0058 8.599642sec +405msec 086:L +ET_IGRLK
    0059 8.599654sec  +12usec 082:L +ET_IRQLK
    0060 8.599654sec   +0usec 00b:L     [ET sFAILED]
    0061 8.599658sec   +4usec 08a:L         ET_ORQLK+
    0062 8.599658sec   +0usec 08e:L         ET_OGRLK+
    0063 8.599658sec   +0usec 18e:L LALST: all locks settled
    0064 8.629645sec  +29msec 000:L     [ET sRESET]
    0065 8.629649sec   +4usec 18e:L LALST: all locks settled
    0066 8.664035sec  +34msec 180:K (ET) ITCDN: packet sync lost

Oh no, packet sync has failed (I pulled the loopback cable.)

    0067 8.664035sec   +0usec 001:K [ET:WAITPS] ENTER

..and East resets

    0068 9.245925sec +581msec 183:K (WT) ITCDN: packet sync lost
    0069 9.245929sec   +4usec 0c1:K [WT:WAITPS] ENTER

..so does West

    0070 9.465790sec +219msec 011:K [ET:WAITPS] TIMEOUT
    0071 10.369974sec +904msec 0d1:K [WT:WAITPS] TIMEOUT

..and so the story ends, we're told.

:250]
[253:

Sat Mar 21 14:20:54 2020 OK, to observe a satisfyingly failed
negotiation, we really ought to jump ahead to a/the userspace spike,
so that there'd be a natural way for things to fail.

So committing this now, then switching to userspace.

:253]
