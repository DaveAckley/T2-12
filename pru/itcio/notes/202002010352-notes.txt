{154}  -*- text -*-
[0:
[3:
[35:
[36:

Thu Feb  6 14:20:38 2020 And here we are.

:36]
Thu Feb  6 14:19:30 2020 MOVING THIS TO
/home/t2/T2-12/pru/itcio/notes/ since we're now about LKM hacking
again.

:35]
[4:

Sun Feb  2 01:29:46 2020 And here we are.

:4]
Sun Feb  2 01:28:16 2020 MOVING THIS TO
/home/t2/MFM/src/drivers/itcSpike/ where we've been working for a
while now..

:3]


Sat Feb  1 04:15:53 2020 So, starting in to a spike to get more real
about ITC state machines for the levels and so forth.

First question: Are we going to redo the itc_pkt to break out the
packet channels?  Right now, MFM/src/drivers/mfmt2/include/MFMIO.h is
opening MFM_DEV_PATH == /dev/itc/mfm and that's that.[1:

Sat Feb  1 04:48:19 2020 And we're already doing a loop, in
mfmt2/src/main.cpp, to ship flash traffic, since we have to customize
the packet headers.  With separate devices I suppose we could even
have the LKM slug the src/dst info into the pkt hdr.

Well I think it's pretty clear we're thinking of making
/dev/itc/mfm/{ET..NE} devices, so why don't we get on down to
~/T2-12/pru/itcio/module/ and see what that might involve.  One think
to think about is that packet writes will still need to be merged into
the outbound queue for the appropriate pru, so the locking on that
could start actually getting stressed, since there will be six (well,
three) separate devices that might be trying to a given outbound kfifo
at once.

But nap first.[2:

Sat Feb  1 10:00:37 2020 OK, let's have some

TODO

[5: Sun Feb  2 01:30:16 2020
DONE :5] - Make a tiny little stub that we'll grow into the itc level
   sequencer.

[12: Wed Feb  5 04:34:28 2020
DONE :12] - Change boot sequence to start the stub INSTEAD of mfm, so the
   former can grab /dev/itc/mfm

[13: MFMIO.h/cpp was already that, so
DONE :13] - Maybe let's make a little abstraction that wraps /dev/itc/mfm and
   turns it into a like pollable pseudo-device?  So we could start our
   level sequencing code without immediately doing the LKM stuff?

[14:
DONE:14] - Rough up some packet formats for the levels

[15:
DONE :15] - Demo first-cut on-tile level sequencer talking on loop-back then
   between tiles, with results visible ONLY in the log file -- NO
   DISPLAY HACKING ALLOWED :)

:2]

:1]

:0]
[6:

Sun Feb  2 05:01:08 2020 OK we're at ITC::sendLevelPacket() so we need
a packet format.  What do cache updates currently use?  Let's just get
OoB wrt that?[7:

Sun Feb  2 05:04:16 2020 In src/core/include/Packet.h, we have like
PacketType::UPDATE_BEGIN == 'b'.[8:

Sun Feb  2 05:25:31 2020 But that's the second byte.  The packet
actually starts with

      u8 cmd = 0xa0|dir8; // STD MFM pkt hdr
      packet.Printf("%c",cmd);

according to src/drivers/mfmt2/src/main.cpp:262

So let's just keep going with the second byte scheme, I guess.  The
cache processing code appears to be using second byte types [ucea].
We notice they're all 7 bit ASCII.  If we take the high bit for our
level scheme we can pack the level and stage all into the second byte,
with room leftover..

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1 | L1| L0| S1| S0|RV0|RV1|RV2|
   +---+---+---+---+---+---+---+---+

Three bits left over, if we say no more than three levels.
[9:

Sun Feb  2 05:41:39 2020 Well let's do that.  We can always change it
if pressing needs come up.[10:

Sun Feb  2 05:45:26 2020 Uhhhhm except flash traffic is already using
the top bit of byte 1.

      if (amt > 1 && (buf[1] & 0x80)) // byte 1 MSB set is MFM SPECIAL, clear is

So we'll need to rethink.  Probably just draft 'l' or 'L' for Level
packet, and take another byte and not worry about it.

But first nap.


:10]

:9]
:8]

:7]

:6]
[11:

Sun Feb  2 12:21:36 2020 OK, so we're sending 'l' packets to ourselves
via loopback cable, and handling them a little, and are getting quite
close to the frontier of chnlSim.pl's implemented behavior.  But it's
time to move the flag, so we've got to get this stuff actually into
the tree for safety..

:11]
[16:

Wed Feb  5 04:35:19 2020 OK so we're post-t2sup#269 and want to get
some thoughts down while they still don't seem to suck.

A LEVEL has

 - SUPPORTS.  These are things that must be true to remain in or at
   the LEVEL.  The level code should check all these things every time
   it runs, and if any are untrue the level crashes.

 - PROPERTIES.  These are things that can be accessed, and can affect
   processing both within level code and by other entities

 - Triggers? Advancers? Exiters?  These are the conditions that allow
   advancing from one level to another.

[17:

Wed Feb  5 04:58:46 2020 So the problem with levels is that you can't
fork states, because you have this one dimensional notion of altitude,
of progress, of sequence.  So you have to fold all cases at a given
level into the properties of that level -- like COMPATIBLE vs
INCOMPATIBLE physics.

The good thing about levels is you can do altitude comparisons.  You
can say 'if (foo.level >= ACTIVE)' or whatever, and have that be a
meaningful thing.

[18:

Wed Feb  5 05:07:06 2020 There's also the interlock implied by the
stages, reflecting the distributed aspect of the state machine.  In
principle we could be looking to stage-interlock not just ITC<->ITC
but also the ITC<->TileModel.

Could there be a cross-entity global notion of levels?  And things
might but at different levels on that scale, but they'd still be
commensurate.

MFMT2 can be:

  CLOSED - not running, or starting up or loading or ..
  OPEN - running events under whatever circumstances prevail

ITCs can be

  CLOSED - not connected, or negotiating physics, or incompatible physics
  OPEN - handling locks and cache updates between compatible MFMT2s

[19:

Wed Feb  5 06:29:54 2020 In addition, entities might be stable or
unstable within a level.  Entering/stable/leaving?  What is the
purpose(s) of stability?

 - Coordination with remote entities
 - Non-atomic processing internal to level

Externally we say something isn't really AT a level until they are at
least STABLE in that level.

:19]

:18]

:17]
:16]
[20:

Wed Feb  5 06:51:12 2020

TILE
  Coordination tasks:
  (1) Host PRUs
  (2) Host ..
  Computation tasks

ITC
  Coordination tasks:
   (1) Host Tile
   (2) Peer ITC
   (3) Host MFM
  Computation tasks:
   (1) Compatibility check

MFM
  Coordination tasks:
   (1) Local ITCs (limited)



                          TIMEOUT       RCVE
 ITC::CLOSED::ENTER       reannounce    ITC::CLOSED::ENTER -> ITC::CLOSED::STABLE
                          + remain

 ITC::FAILED::

:20]
[21:

Wed Feb  5 07:28:34 2020 What if we move the compatibility negotiation
into the kernel???  That would certainly establish the decoupling of
the ITCs from MFMT2.

How might it work?

Open /dev/mfmctl for read/write.  It's single user so that's how mfmt2
locks out any other userspace competitors.  Write MFZ fingerprint to
it?  Poll to read it for events?  Do we even believe in events?  Vs
states?  Perhaps advisory events just to speed things up, but the
event just triggers reading states, rather than trusting the advice.
Everything should still work, just slower, even if all events (other
than timeouts) are ignored.
[22:

Wed Feb  5 08:54:16 2020 So an event is really just like a wake-up,
rather than a real event.  Even a timeout is really just a wake-up,
and the entity checks its own internal clock to see if it's a 'real'
timeout.

I do think we're going to go to actual time-based intervals for
timeouts and such, though, rather than the count-based stuff from this
weekend.  After all, that's counting wake-ups, which we JUST SAID
weren't supposed to matter if they happened or not.

But we only want intervals, not absolute times, and only at say
millisecond res.

[23:

Wed Feb  5 09:26:12 2020 When we accumulate state, like advancing a
level, we associate a rate at which we expect that state to be
refreshed.  And indeed, maybe we do not think in terms of a single
timeout for an entity, but in terms of a timeout for refreshing each
bit of state it is maintaining.

But first nap.

:23]

:22]


:21]
[24:

Wed Feb  5 12:48:58 2020 Suppose we try to rough out an LKM approach
to mfm configuration and cache updates.  Goals:

 - Userspace informs LKM of its ability to run events of some given
   MFZ and no other.  After that returns successfully, all KITC fds
   have been put into an error state, and userspace must close and
   reopen those connections before they can be used.

 - User space sees 'only' cache updates (and flash traffic?) via the
   new device.  And KITC status, OPEN/CLOSED, with open implying
   'ready for events'.   'And like everything,' we should somehow get
   a wake-up when a KITC changes, or we can interrogate it at our own
   rate.

When mfm considers an event window it tries for locks on the ITCs it
believes to be OPEN, and goes from there.

[25:

Wed Feb  5 15:58:17 2020 Are we saying we'd just expand itc_pkt for
this, or would there be a separate LKM?  I guess we're saying expand
itc_pkt.  We don't want to figure out how to call between LKMs for
example.

So,

TODO
[29: Thu Feb  6 11:13:11 2020

DONE :29] - Review itc_pkt.[ch] to remember what we're dealing with.

[37: Thu Feb  6 14:20:58 2020
DONE :37] - Make an expanded struct for each direction, and

[50: Fri Feb  7 14:45:10 2020
DONE :50] - Make a struct for mfm info like the mfzversion.

[45: Fri Feb  7 12:03:33 2020
DONE :45] - Review packet formats to see where we could fit it the inter-itc
   negotiation stuff (aka 'level packets').

[38:
DONE :38] - Also review for expanding to per-ITC packet-IO devices to
   userspace.  Like /dev/itc/mfm/ET../dev/itc/mfm/NE or whatever.

:25]

:24]
[26:

Thu Feb  6 01:15:57 2020 So for starters, we're talking about a bunch
of new minors, right?  For the record, here's what we're using now:

    t2@beaglebone:~/T2-12/pru/itcio/module$ ls -l /dev/itc/* | sort -k 1.1,1.2 -k 5n -k 6n
    crw------- 1 root root 237, 0 Feb  5 01:23 /dev/itc/pru0
    crw------- 1 root root 237, 1 Feb  5 01:23 /dev/itc/pru1
    crw------- 1 root root 237, 2 Feb  5 01:23 /dev/itc/packets
    crw------- 1 root root 237, 3 Feb  5 01:23 /dev/itc/mfm
    crw------- 1 root root 237, 4 Feb  5 01:23 /dev/itc/pktevents
    crw------- 1 root root 238, 0 Feb  5 01:23 /dev/itc/locks
    crw------- 1 root root 238, 1 Feb  5 01:23 /dev/itc/lockevents
    t2@beaglebone:~/T2-12/pru/itcio/module$

so we'd be talking SIX more minors under /dev/itc?  And does this mean
they ALL need/want to be DIRECTLY under /dev/itc?  Well, maybe not.
The makeITCCharDeviceState code like at itc_pkt.c:2129 does:

  switch (minor_obtained) {
  case PKT_MINOR_ITC: snprintf(devname,BUFSZ,"itc!packets"); break;
  case PKT_MINOR_MFM: snprintf(devname,BUFSZ,"itc!mfm"); break;
  case PKT_MINOR_EVT: snprintf(devname,BUFSZ,"itc!pktevents"); break;

so perhaps we could 'just' do "itc!mfm!ET" ?  Except that would imply
/dev/itc/mem is a directory not a device.  But maybe "itc!bydir!ET" or
whatever.  Or maybe device /dev/itc/mfm does become a directory -- do
we still need it as a device if we're exploding the itcs by direction?
Bulk traffic still goes by /dev/itc/packets; flash traffic will appear
in the by-direction queues (?), along with the 'mfm' traffic.  So

Assuming we really can go more than one '!' deep in that naming
scheme.
[27:

Thu Feb  6 02:54:13 2020 So anyway.  I think itc_pkt.[ch] isn't in
terrible shape for adding another chunk of minors.  For now, let's
preserve /dev/itc/mfm and try going with /dev/itc/bydir/ET..[28:

Thu Feb  6 11:00:15 2020 Post coffee with Melanie and Chris Thachuk.

[30:

Thu Feb  6 11:13:32 2020 So let's go for more minors.  This part of
the hack is basically about demuxing the inbound mfm packets on a
per-direction basis, and we can do that separately from moving
additional protocol negotiation into the kernel.[31:

Thu Feb  6 14:00:25 2020 OK so we theoretically have six more minors
being built and torn down, all untested.  Wait, where did we actually
name their paths?[32:

Thu Feb  6 14:05:21 2020 And their paths have been named.  All, as
previously mentioned, untested.

We have a new script on the workstation,
CDM-TGZS-BACKUP/scripts/PullT2HomeDir, that just rsyncs /home/t2, with
no versioning or extra redundancy on the workstation side.  But trying
that now because I think we're facing

BITS OFF

:32]

:31]

:30]

:28]

:27]
:26]
[33:

Thu Feb  6 14:17:05 2020 OK well we seem to have survived
install+reboot okay so far.  No logoops that I can see.  And we see
this:

    root@beaglebone:~# ls /dev/itc
    bydir  lockevents  locks  mfm  packets	pktevents  pru0  pru1
    root@beaglebone:~# ls /dev/itc/bydir
    ET  NE	NW  SE	SW  WT
    root@beaglebone:~# ls -l /dev/itc/bydir
    total 0
    crw------- 1 root root 237,  5 Feb  6 14:10 ET
    crw------- 1 root root 237, 10 Feb  6 14:10 NE
    crw------- 1 root root 237,  9 Feb  6 14:10 NW
    crw------- 1 root root 237,  6 Feb  6 14:10 SE
    crw------- 1 root root 237,  7 Feb  6 14:10 SW
    crw------- 1 root root 237,  8 Feb  6 14:10 WT
    root@beaglebone:~#

which all seems plausible.

[34:

Thu Feb  6 14:18:43 2020 But, this file is currently in ~/MFM, which
seems wrong since we're now into LKM stuff over in ~/T2-12/pru.

:34]
:33]
[39:

Thu Feb  6 14:44:59 2020 So let's see if we can demux inbound MFM
packets to our new devices, while still sending them to /dev/itc/mfm
as well.[40:

Fri Feb  7 02:45:27 2020 Well, we'd have to introduce a new packet
copying thing to do that, so maybe let's just bite the bullet and
stop sending to /dev/itc/mfm.  However, we're wondering if while we're
tearing all this up, we might make yet another minor to represent
flash traffic.  With the desired semantics being that flash traffic
reads are not demuxed per-dir6, but perhaps flash writes are
automatically broadcast in all active dir6s.

Actually now that I say it perhaps /dev/itc/mfm could be repurposed
for flash traffic, rather than creating yet another minor?  So we'd

(1) Insert a diversion around itc_pkt.c:1768 where we'd fall through
    on flash traffic, but go off to some new demux handler for
    everything else.

(2) Change the code around itc_pkt.c:1399 to broadcast flash traffic
    rather than routing it.

[41:

Fri Feb  7 06:26:56 2020 So how do we distinguish flash traffic, and
'ITC level' traffic, at the LKM level?



:41]

:40]

:39]
[42:

Fri Feb  7 10:33:48 2020 OK, well I spent a couple hours, here, making
T2-12/doc/T2-Packet-Header-Formats-11.ods and .pdf files.  It presumes
we're going to take byte 1 bit 7 on routed standard packets to mean
'MFM traffic', as opposed to 'flash traffic', so itc_pkt can split
those streams before delivery to userspace.

It further presumes we're going to take byte 1 bit 6 on MFM traffic to
mean 'ITC level traffic', which is to be handled by itc_pkt.c and
never delivered to userspace, directly, at all.  That leaves only six
bits for the the cache packet type code, so we can't just be happy and
use 7 bit ASCII.  Now, according to MFM/core/include/Packet.h, we
currently have cache type codes [bucea] in use, and none of them fit
in six bits.

But I'm thinking now might be the time to support merging cache
'minipackets' together for transport anyway, in which case we might
not even be using the remaining six bits of byte 1, and might just be
starting at byte 2.

[43:

Fri Feb  7 10:49:26 2020 Let's see.

 Format: UPDATE_BEGIN + s16:CX + s16:CY          --5 bytes
 Format: UPDATE + u8:SITENO + T:ATOM             --14 bytes
 Format: CHECK + u8:SITENO + T:ATOM              --14 bytes
 Format: UPDATE_END                              --1 bytes
 Format: UPDATE_ACK + u8:CONSISTENT_ATOM_COUNT   --2 bytes

So we could fit like (/ 250 14) ~16 site updates anyway in a single
packet, and a DReg- or Res-like diffuser would be (+ 5 14 14 1) < 40
bytes all done, if no check atoms were needed.  (Or alternatively,
more than a dozen check atoms could be included and still fit in one
packet.)

Worst case, if we had to ship absolutely the whole event window, we'd
be talking (+ 5 (* 41 14) 1) == 580 bytes, meaning three packets.

:43]

:42]
[44:

Fri Feb  7 11:52:08 2020 So where are we?  Have we got some to-do to
check off?[46:

Fri Feb  7 12:03:45 2020 Well, all that's left on the most recent
to-do is an mfm struct to capture downward state information.  Let's
knock that out.[47:

Fri Feb  7 12:53:19 2020 So, what ARE we going to use as the real 'MFZ
version string'?  The question drives the issue of what kind of
intertile security -- if any -- are we going to have in these
'research-only prototype tiles'.  About the best we could do, if we
wanted to, was to have some kind of private key inside the MFZ, and do
a challenge-response during KITC level negotiation.  But that would be
BS because it would only prove that the peer tile HAD POSSESSION of
some particular MFZ secret key, and not also that the peer tile WAS
RUNNING THE ASSOCIATED CODE unmodified.

So we shouldn't pretend we're getting intertile SECURITY here, and
just focus on avoiding intertile ACCIDENTS.  Seems like a hash of the
whole damn MFZ file would be the obvious way to go.  A SHA256 is 64
bytes in hex.  Suppose we make the max length 127 bytes.[48:

Fri Feb  7 13:14:03 2020 Actually, what does cdm.pl do?[49:

Fri Feb  7 13:22:40 2020 cdm.pl appears to use the FIRST HALF (16
bytes/32 hex) of the (32 bytes/64 hex) sha256 result.

Suppose we do this:

(1) Take the whole sha256 result as the id, but handle it in binary,
    taking 32 bytes.

(2) Make the max id string like 50 bytes.

(3) As part of leveling up, after we establish matching ids, we
    exchange a random token of perhaps 2 or 4 bytes.  That's what
    we'll use in later status announcements.  So a lower level is
    supported by matching ids, but a higher level is supported by
    matching side-specific tokens.  Maybe 2 bytes each, and the
    confirmation packet supplies our two bytes and our belief about
    their two bytes.  And we pick a random non-zero starting point
    when the LKM inits, and then increment-skipping-zero from there.


:49]

:48]

:47]

:46]

:44]
[51:

Fri Feb  7 14:45:33 2020 OK, made an mfmstate thing and initted it.
How do we set the config?  'echo $id > /sys/class/itc_pkt/mfzid'?

Well let's try more

TODO

[53: Fri Feb  7 16:39:14 2020
DONE :53] - Init MFMTileState via /sys/class/itc_pkt/mfzid

[64: Sat Feb  8 15:28:06 2020
DONE :64] - Draft the KITC levels considering the mfzid/seqno distinction

[54:
DONE :54] - Make code to open ITCMFMDeviceStatuss.  Ensure they are exclusive use.

[55:
DONE :55] - Mod ITCMFMDeviceStatus to have an invalid flag to set forcing reopen

[99: Thu Feb 13 13:38:13 2020
DONE :99] - Rename /dev/itc/mfm to /dev/itc/flash and route flash traffic there.

:51]
[52:

Fri Feb  7 16:38:45 2020 OK time to break for cooking dinner, but we
have some cargo cult progress at least.
[56:

Fri Feb  7 16:39:40 2020 All that crab builds but is totally untested
at present.

:56]
:52]
[57:

Sat Feb  8 00:08:42 2020 So, the levels, the levels, let's try again.

Level 0: ALONE
  Requires:        Nothing
  Announce stages: false
  Entry timeout:   1000+-100ms
  On timeout:      Re-enter
  Update on:       ITCCHANGE, L rcvd, timeout
  Stage1 on:       PacketSync
  Stage2 on:       PacketSync
  Advance on:      PacketSync

Level 1: KITC
  Requires:        PacketSync
  Announce stages: true
  Entry timeout:   300+-100ms
  On timeout:      Re-enter
  Update on:       ITCCHANGE, L rcvd, timeout
  Stage0 argument: None
  Stage1 on:       t>=1.0 && t<2.0
  Stage2 on:       t>=1.0 && t<2.0
  Advance on:      t>=1.1 && u==1.2

Level 2: CONFIG
  Requires:        t>=1.1
  Announce stages: true
  Entry timeout:   300+-100ms
  On timeout:      if u==2.1, Backoff else Retreat
  Update on:       ITCCHANGE, L rcvd, timeout
  Stage0 argument: MFZId
  Stage1 on:       t>=2.0 && t.MFZId!=u.MFZId
  Stage2 on:       t>=2.0 && t.MFZId==u.MFZId
  Stage2 argument: mfm.seqno
  Advance on:      t>=2.2 && u==2.2

Level 3: MFM
  Requires:        t>=2.2 && mfm.seqno == t.seqno
  Announce stages: true
  Entry timeout:   1000+-100ms
  On timeout:      if u>=3.1 backoff else re-enter
  Update on:       ITCCHANGE, L rcvd, timeout
  Stage0 argument: mfm.seqno t.seqno
  Stage1 on:       t>=3.0 && mfm.seqno == t.seqno
  Stage2 on:       false
  Advance on:      false

:57]
[58:

Sat Feb  8 07:24:45 2020 Well I presume stages 0..3, there, in part
because of compat/incompat but also because we gave two bits for stage
in the level packet, but I'm thinking we should go back to just stages
0..2 and do compat/incompat with additional state, like we're already
kind of doing for their seqno.  Or something.

[59: Sat Feb  8 07:32:13 2020

 - KITCs are updated on: ITCCHANGE, L rcvd, timeout

 - Level confirmation packet data is cumulative.

 - update begins with requirements check.  Level requirements are
   cumulative.  If currently supported level < previous level, enter
   at currently supported level, stage 0.  Otherwise enter at previous
   level, previous stage.

 - All timeouts are randomized +- 25%

 - Most recently received peer level info is stored in 't'.  't' data
   is reset on restart or if T timeout expires.

DEFAULT LEVEL VALUES:
  Requires:        t>=(L-1).1
  U timeout:       100ms, re-enter
  T timeout:       500ms, retreat
  Exchange:        nothing
  Decide:          true
  Confirm:         nothing
  Advance:         t>=L.1 && u==L.2

Level 0 CONTACT
  Requires:        Nothing
  U timeout:       10000ms, restart
  T timeout:       10000ms, restart
  Advance:         PacketSync

Level 1 COMMUNICATION
  Requires:        PacketSync
  Exchange:        u.seqno
  Confirm:         u.seqno + t.seqno

Level 2 COMPATIBILITY
  Exchange:        MFZId
  Decide:          d = u.MFZId == t.MFZId
  Confirm:         d

Level 3 COMPUTATION
  U timeout:       10000ms, re-enter
  T timeout:       50000ms, retreat
  Advance:         false

:59]

:58]
[60:

Sat Feb  8 09:33:59 2020 OK, so :59: seems to have some potential.
Separate Us-vs-Them timeouts seems pretty key, in the spirit of
output strict, input generous.  Was picking times so we'd send our
stuff at least twice, and probably three times, before giving up for
lack of their stuff in response.

Could we start going to code here?  Flesh out 'class' structs and
'method' funcs?  We're going to try to go array-of-structs-of-fncptrs,
right?  What might the functions be?

  enum LevelAction { DO_REENTER, DO_RESTART, DO_RETREAT, DO_ADVANCE, DO_CONTINUE };
  bool levelRequires(ITCMFMDeviceState * itc) ;
  LevelAction levelTimeout(ITCMFMDeviceState * itc, bool usNotThem, u32 & nextTimeoutAroundMs) ;
  u32 levelSend(ITCMFMDeviceState * itc, bool exchangeNotConfirm, char * pkt, u32 startIndex) ;
  u32 levelReceive(ITCMFMDeviceState * itc, bool exchangeNotConfirm, char * pkt, u32 startIndex) ;
  LevelAction levelDecide(ITCMFMDeviceState * itc) ;

:60]
[61:

Sat Feb  8 15:01:08 2020 Urgh just did a big reorg including renaming
itc_pkt.[ch] to itcpkt.[ch] to get the 'multiple source file building
into one ko module' working.  It now appears to be building but I'm
terrified to try it.

I guess we do our risky 'rsync pull' to get our

BITS OFF

:61][62:

Sat Feb  8 15:08:26 2020 Well, 'make install'ing..

:62]
[63:

Sat Feb  8 15:13:45 2020 Well we appear to have survived reboot
without oops.

Soooo can we check some stuff off heah?
[65:

Sat Feb  8 15:28:57 2020 Well, I still don't really want to rename
/dev/itc/mfm to /dev/itc/flash, so let's instead make up some new

TODO

[68: Sat Feb  8 22:19:51 2020
DONE :68] - Finish setting up the structs for the draft levels

[80: Mon Feb 10 15:57:31 2020
DONE :80] - Detect and divert on whatever now counts as 'L' packets

[98: Thu Feb 13 13:37:55 2020 Anyway basically
DONE :98] - Make a generic level update() function for externals to call.

[81:
DONE :81] - Get some level-related crab appearing in the log file.

:65]

:63]
[66:

Sat Feb  8 17:24:29 2020 OK having been doing horrible XX YY macro
hackery, and have gotten as far as declaring the needed 'custom level
functions', but not yet defined them:

      CC [M]  /home/t2/T2-12/pru/itcio/module/itcmfm.o
    /home/t2/T2-12/pru/itcio/module/itcmfm.c:43:48: warning: ‘ilsRequireCONTACT’ used but never defined
     #define YY1(NM,TYPE) static Level##TYPE##_func ils##TYPE##NM;
                                                    ^~~
    /home/t2/T2-12/pru/itcio/module/itcmfm.c:46:3: note: in expansion of macro ‘YY1’
       YY##REQ(NAM,Require)                \
       ^~
    /home/t2/T2-12/pru/itcio/module/itcmfm.c:33:9: note: in expansion of macro ‘XX’
     /* 0 */ XX(CONTACT,      1,  1,   0,   0,            _)    \
             ^~
    /home/t2/T2-12/pru/itcio/module/itcmfm.c:51:1: note: in expansion of macro ‘ALL_LEVELS_MACRO’
     ALL_LEVELS_MACRO();
     ^~~~~~~~~~~~~~~~
    /home/t2/T2-12/pru/itcio/module/itcmfm.c:43:48: warning: ‘ilsTimeoutCONTACT’ used but never defined
     #define YY1(NM,TYPE) static Level##TYPE##_func ils##TYPE##NM;

etc

So that's where to pick up.  But it's Saturday evening so break
  time.[67:

Sat Feb  8 22:19:20 2020 OK, so log-only versions of the level
customizations are building.

:67]

:66]
[69:

Sun Feb  9 08:06:14 2020 Well, so finally went back and systematized
the dir8-vs-dir6 distinction more thoroughly, which meant hitting tons
of stuff all over the place.  But it's building again; untested.

We've theoretically detected when a KITC packet has arrived, but we're
just logging when it hits.

Perhaps we should head back down to loopback-only and then give this a
try?  We haven't done much on the send side yet so we could probably
handmake a KITC packet and inject it.[70:

Sun Feb  9 08:35:00 2020 Well since we're blowing it all up we also
did the device renaming.  Now we have:

  /dev/itc/bulk
  /dev/itc/flash
  /dev/itc/pru/0
  /dev/itc/pru/1
  /dev/itc/mfm/ET
    ..
  /dev/itc/mfm/NE

but userspace still can't read or write anything via /dev/itc/mfm/*

[71:

Sun Feb  9 08:44:36 2020 We need to merge itc_pkt_write and
itc_mfmitc_write.  They might end up being the same or nearly so.  We
could have itc_mfmitc slug in the correct destination automatically
before dishing off to the factored-out guts of itc_pkt_write.

But first, business of the day.

:71]

:70]

:69]
[72:

Sun Feb  9 11:48:54 2020 Well, risky

BITS OFF

:72]
[73:

Sun Feb  9 12:12:26 2020 OK so had some BUG_ONs hit due to error
checking in mapPruAndPruDirToDir8, but hacked around that and now
appear to be coming up again.

Have rehacked cdm.pl to look for /dev/itc/bulk.

TODO

[74: Mon Feb 10 12:50:02 2020
DONE :74] - Rehack MFMIO (MFM/src/drivers/itcSpike11) to open all six
   /dev/itc/mfm/* devices!

:73]
[75:

Mon Feb 10 12:50:22 2020 OK, userspace is now hitting the fact that
itc_mfmitc_write returns -EOPNOTSUPP so we need to implement that.

:75]
[76:

Mon Feb 10 13:19:00 2020 Well trying that write implementation after

BITS OFF

:76]
[77:

Mon Feb 10 13:23:15 2020 OK we're back.  We have an ET-WT loopback
plugged in, and itcSpike is seeing their PS, but not deciding they are
compatible.  Let's dig in.

:77]
[78:

Mon Feb 10 14:39:22 2020 OK it was 'user error' -- we're writing 'l00'
packets from itcSpike11, and they are now, 'correctly', being
delivered to /dev/itc/flash, because they do not have the MFM bit
(0x80) set on byte 1.

So we need to send proper MFM packets!  Buut, actually, officially, we
don't want to be sending 'l' packets from userspace at all, we want to
be having itcmfm.c doing that.  Are we getting to the point where we
go back to that?

:78]
[79:

Mon Feb 10 15:55:29 2020 OK, finally we got to this:

    root@beaglebone:/home/t2/T2-12/pru/itcio/module# tail /var/log/syslog
    Feb 10 15:55:04 beaglebone kernel: [ 5519.721844] (ET) HANDLE ITC TRAFFIC HERE (2) packet
    Feb 10 15:55:04 beaglebone kernel: [ 5519.756940] (WT) HANDLE ITC TRAFFIC HERE (2) packet
    Feb 10 15:55:04 beaglebone kernel: [ 5519.819234] (ET) HANDLE ITC TRAFFIC HERE (2) packet
    Feb 10 15:55:04 beaglebone kernel: [ 5519.832708] (WT) HANDLE ITC TRAFFIC HERE (2) packet

meaning we have successfully diverted on level packets and gotten crab
into the log file..
[82:

Mon Feb 10 15:57:51 2020 So now let's get an itcmfm dispatch to call
there, and foggen call it.

:82]
:79]
[83:

Mon Feb 10 17:06:00 2020 Quick evening break.  On return, I think
ready to try touching some of the ITCMFMDeviceState unique data
members.  [84:

Mon Feb 10 18:58:12 2020 Well, that worked for what little it was
doing.  It's getting to be time to have an idea how timeouts are
supposed to be generated.  Hoping we don't need another kthread,
right? [85:

Mon Feb 10 19:09:07 2020 Well, we probably do need another kthread,
but I don't want to try to get into that now.

Couldn't we get a fair chunk going just with responses to packets?

:85]

:84]

:83]
[86:

Mon Feb 10 19:21:21 2020 OK, so one thing we need right away is to
ACTUALLY GENERATE A STRUCT TO HOLD OUR ITC STATE.  That's a leftover
undone bit from the XX hackery.[87: Mon Feb 10 19:24:32 2020 Or, did
we decide to ditch that for the hardcoded ITCLevelState that we
already see in itcmfm.h?[88:

Mon Feb 10 19:26:28 2020 I think we did but if we didn't let's do that
now.  [89:

Mon Feb 10 19:33:05 2020 Trying to implement from :59:

:89]

:88]  :87]

:86]
[90:

Wed Feb 12 06:55:56 2020 Well, let's set up a KITC timing thread in
  itcmfm.c[91:

Wed Feb 12 07:46:48 2020 Getting there.  Abstracted the thread
creation stuff.  Still need the threadrunner routine, though wow:

    make[1]: Entering directory '/usr/src/linux-headers-4.19.79-ti-r30'
      CC [M]  /home/t2/T2-12/pru/itcio/module/itcpkt.o
      LD [M]  /home/t2/T2-12/pru/itcio/module/itc_pkt.o
      Building modules, stage 2.
      MODPOST 1 modules
    WARNING: "itcLevelThreadRunner" [/home/t2/T2-12/pru/itcio/module/itc_pkt.ko] undefined!
      CC      /home/t2/T2-12/pru/itcio/module/itc_pkt.mod.o
      LD [M]  /home/t2/T2-12/pru/itcio/module/itc_pkt.ko
    make[1]: Leaving directory '/usr/src/linux-headers-4.19.79-ti-r30'

"Successful build, exit status 0"

:91]

:90]
[92:

Wed Feb 12 15:46:45 2020 OK, so we have some of the level callbacks
kind of implemented.  Need more.  Also need to start handling level
packets.  How do we do that?

TODO

 - Review the update requirements check.  In particular,

 - Deal with the 'entering' clauses in :59:.

 - Deal with the timeout randomization and mTimeout management

[97: Thu Feb 13 13:37:17 2020
DONE:97] - Deal with storing the most recently received peer level info in 't'

 - Finish implementing the default requires, using 't'

 - Finish implementing the default advance, using 't'

 - Flesh out non-default cb's of CONTACT

 - Flesh out non-default cb's of COMMUNICATION

 - Flesh out non-default cb's of COMPATIBILITY

 - Flesh out non-default cb's of COMPUTATION

 - See this stuff BEGIN to work.

:92]
[93:

Wed Feb 12 16:22:47 2020 OK, in handleKITCPacket, do we know we're
dealing with a 'level packet'?[94:

Wed Feb 12 16:24:20 2020 Yes, we do, because itc_pkt_cb checked URG &
MFM & ITC before it dispatched to us.  So that means we have a
LevelStage in the bottom five bits of packet[1];

:94]

:93]
[95:

Thu Feb 13 08:50:40 2020 OK we need to reboot so long overdue to get
our

BITS OFF

:95]
[96:

Thu Feb 13 13:36:48 2020 All right it's time to move the flag again.
Let's see where we are here.[100:

Thu Feb 13 13:38:32 2020 Well didn't get much in the latest set of
to-dos but there you are.  Have still been doing infrastructure ahead
of that stuff.  We have the ITCLevelState structs getting implemented
with at least some plausibility now, etc.

BITS OFF

:100]

:96]
[101:

Thu Feb 13 16:07:08 2020 OK, flag moved.

:101]
[102:

Thu Feb 13 16:34:58 2020 OK, so :59: says 'KITCs are updated on:
ITCCHANGE, L rcvd, timeout'.  We've implemented a cut at updating on
timeout, but how do we update on 'L rcvd'?  The idea, such as it was,
was to call the .packetio callback at that time.  But is that an
'update'?  Like do the level support checks happen at that time?

Or do we perhaps imagine that level packets 'arrive between' updates
and are always handled wrt the cached state at that time?

That seems bad, like we'll end up leaning on the timeout when we
wanted that just to be a backstop.  So that says we DO want to update
as part of packet handling.  Do we update before or after the
.packetio callback?  Or do we somehow let the update call that
callback?  Right now updateKITC() doesn't have the arguments to know
about any possible packet.. But that seems wrong anyway.

So that says we should call .packetio 'asynchronously', but also call
update.  Before or after?  [103:

Fri Feb 14 01:27:35 2020 Let's say before.  Handle the packet, then
update.  What's the downside, handling a packet without realizing a
timeout had already occurred?  If there actually is a packet you'd
think we want to deal with it.  And again, we're trying to avoid
leaning on timeouts at all on error-free paths.

:103]

:102]
[104:

Fri Feb 14 06:06:55 2020 Trying to get to the point of using
.packetio, and starting to think the interface is stupid.  As I
understand it, the distinction between 'exchange' and 'confirm' is
supposed to be strictly determined by what stage we're in within the
level.  So why not just have a single 'handleInboundLevelPacket' sort
of callback, and let the callee decide how to interpret it?

But nap now.
[105:

Fri Feb 14 11:00:35 2020 Because we were going to use .packetio also
for generating outbound packet args?  How was that going to work?[106:

Fri Feb 14 11:03:15 2020 Well, in :60: we had TWO functions listed:

  u32 levelSend(ITCMFMDeviceState * itc, bool exchangeNotConfirm, char * pkt, u32 startIndex) ;
  u32 levelReceive(ITCMFMDeviceState * itc, bool exchangeNotConfirm, char * pkt, u32 startIndex) ;

each with the exchangeNotConfirm, which would cover the four cases of
sending and receiving during exchange and confirm.  But that somehow
folded down to .packetio with only two cases, how?[107:

Fri Feb 14 11:48:56 2020 Let's change that bool to recvNotSend and let
the callback decide what to expect/generate based on its own view of
the level state.

:107]

:106]

:105]

:104]
[108:

Fri Feb 14 15:27:24 2020 OK, so, what happens after we do the
requirements check in update?  :59: is kind of silent on this matter.

We update mUCurrentLS based on level requirements and the :59:
language.  ..Then we call the .decide callback?  And it does,
something, maybe?  ..And then call the .advance callback?  And if it
returns true we do like mUCurrentLS.level++, mUCurrentLS.stage=0?
When do we send a level packet?[109:

Fri Feb 14 15:57:23 2020 Well, in :57: we have an 'Announce stages:
BOOL' row, but that didn't make it into :59:.  Was there going to be
some kind of special return from something?  Is that something that
LevelAction is supposed to cover?[110:

Fri Feb 14 16:06:54 2020 So I think the idea was auto-announce the
level when it changes?  Or whenever the level or stage changes?  Maybe
that's it.  Then we'd need to be checking that in the update
requirements check loop.  But that was probably it.

:110]

:109]

:108]
[111:

Fri Feb 14 17:22:00 2020 OK, so, now the question is: Why do we have
both a .advance callback, and a DO_ADVANCE LevelAction coming back
from .decide?
[112:

Fri Feb 14 17:39:03 2020 So it's about the stage numbers.  We enter at
LX0 for some level X.  When that's a new LS for us, we send a LX0
packet that includes the 'exchange' data.  After we receive an LX0
packet (ignoring L(X-1)2 packets), we go to LX1, run the .decide, and
(if we DO_CONTINUE anyway), we send a LX1 packet including the
'confirm' data.  When we get an LX1 packet (ignoring LX0 packets), we
confirm it matches (HOW??), and go to LX2.

Each step along the way there, we were running the .advance callback
as well?  And by default it was saying false until they're at least at
LX1 and we're at LX2?

STILL NOT CLEAR AGAIN.  But time to cook.

:112]
:111]
[113:

Fri Feb 14 23:01:52 2020 OK,

recv packet:

 - Modify state based on packet and current expectations.  State
   includes mTLastLS plus whatever you parsed out of the packet.

 - Then call update

update:

 - Compute newly supported level based on packet sync, TLastLS, and so
   forth

 - Compare to mUCurrentLS.

 - If different, attempt to send level packet.  Custom sendPacket can
   return 0 to abort packet send.

 - If packet send apparently succeeds, set mUCurrentLS to new LS.  If
   packet send apparently fails, do not change mUCurrentLS (but
   shorten utimeout?  But we need to avoid getting into a tight
   spamming-a-full-outbound-buffer loop.  )

..and that's it?  That's all?  The rest is magic?

 - Update is also called on timeout and ITCCHANGE.  (ITCCHANGE will be
   caught by the requirements check so nothing special is needed
   there.)

:113]
[114:

Sat Feb 15 05:39:25 2020 Where in update do we check the timeouts?
Before or after computing the support?  Perhaps after?  So that we
could be.. ..should we be saying that 'still time available' is
implicitly part of the support for the current level?

So that if there's a mismatch, we're going to reset the timeouts based
on entering a new state anyway


[115:

Sat Feb 15 06:36:06 2020 Restate premises.

update:
 - Find supported level by requirements
   - If the now-supported level is below our previous level, attempt
     to enter that level.  After that attempt, the update is done,
     regardless if it succeeded or failed.

 - If our previous level is still supported, determine action:
   - If our timeout has expired, the action is our UTimeout action.
   - If not, see if their timeout has expired.  If so, the action is
     our TTimeout action.
   - If not, call .advance to see if we can advance.  If so, the
     action is DO_ADVANCE.  Otherwise the action is DO_CONTINUE.

 - After the action has been determined, do that action.  DO_CONTINUE
   means stay at the current level, otherwise compute the new level
   implied by the action and attempt to enter that level.

 - DONE


attempting to enter a level:
 - start a packet for that level
 - call the level-specific packet writer (for exchange or confirm as
   depending on the stage we're attempting to enter) to complete or
   abort it
 - if completed, attempt to send it.
 - If packet aborted or send succeeds, enter the level
 - Otherwise remain in previous level


enter a level:
 - set mUCurrentLS to the level
 - push U and T timeouts based on the level

recv packet:
 - Parse their LS from packet, store it in TLastLS

 - Call exchange or confirm parser as appropriate to TLastLS -- THEIR
   LEVEL, not ours.

 - Push our TTimeout for them based on OUR level, not theirs. (?)

 - Then call update

[116:

Sat Feb 15 14:53:33 2020 OK, after sleep.

So I'm wondering if it might not be stupid to have two full copies of
the ITCLevelState for each ITC, one representing US and one
representing THEM.  Instead of having like both UCurrentLS and TLastLS
in one struct.

Doesn't that seem like it wants to be a 'no brainer'?  The idea would
be that received level packets would just get parsed into THEM's
ITCLevelStruct no questions asked..

Could we ditch the UTimeout vs TTimeout distinction as well, and have
a single timeout per ITCLevelState?  That seems more questionable,
because we'd be using THEM.mTimeout to represent when WE'RE going to
time them out, not anything about what they're going to do.

Although I suppose possibly if we switched from notion of a stored
timeout to a stored 'last activity', setting THEM.mLastActivity based
on packet arrival time isn't that bogus.

But we still need someone to say when 'that long ago' becomes 'too
long ago'.  How would the thread runner decide who to update?[117:

Sat Feb 15 15:18:09 2020 If we're willing to callback for the timeout
inside the thread runner -- which we already are, right? -- the
previous activity is all we need?  Well, I guess we'd need to compare
both US (last and timeout) and THEM (last and timeout) to determine
whether an update is warranted.
[118:

Sat Feb 15 15:23:18 2020 Aand, do we set US 'lastActivity' based on
when we last (apparently successfully) sent a packet?  That would be
most symmetric with setting THEM lastActivity based on receiving one.

It also has the nice flavor that it's explicitly about packets and
traffic and communications.

And it makes it so that if we failed to send a packet due to buffer
exhaustion say, we won't push back our (effective) timeout by changing
lastActivity.

So.. could we do this?  Let's at least look at the structs.[119:

Sat Feb 15 16:20:03 2020 Well jeez yeah I think so.  Maybe switch to
something like:

typedef struct {
  ITCSideState mUs;
  ITCSideState mThem;
} ITCLevelState;

typedef struct {
  unsigned long mLastAnnounce;  /* Time in jiffies */
  MFMToken   mToken;            /* Physics ID from MFM */
  MFZId      mMFZId;            /* MFZId from */
  LevelStage mLevelStage;       /* Endpoint LevelStage from Them */
  bool       mCompat;           /* True if Them and Us are known compatible */
} ITCSideState;

[120:

Sat Feb 15 16:28:21 2020 What happened to the seqno in all this?  No
hits in itcmfm.[ch].  And didn't the seqno thing also suggest we were
going to stack the packet generators and parsers?  So that every level
packet at L1.0+ will have a seqno..  Do we still want to go that
route?

Time to cook.

[121:

Sat Feb 15 22:30:22 2020 So an argument against seqnos is that we're
trying to be robust in the face of packet loss, by asserting our LS in
every packet and minimizing shared state.

(If we did the packet-stacking idea we could still have the levels
append different state depending on the level of the packet they are
appending to.  That's how we wouldn't have to have the MFZId in every
L2.1+ packet, for example, and how we could have just the 'd' residue
going forward.  Just have to tell the .packetio guys what the actual
packet level is, separate from the level they are 'prime' for.)

What were the seqnos supposed to accomplish?  We were worried about
enough stuff getting dropped in transit that the recipient could miss
an entire physics bounce or something, and end up indefinitely out of
sync.  And seqnos were supposed to avoid that because we'd best-effort
know if we missed packets.  And what do we do if we miss a packet?
DO_RESTART, I guess, which will block us from going forwards until we
pick and agree on new seqnos.  That almost makes some sense.
[122:

Sat Feb 15 23:20:09 2020 Now, what good does receiving their ack of
our seqno do?  In TCP that's what allows us to dump the buffers we'd
been saving in case we needed to retransmit, but we're not talking a
retransmit/reliable stream here, are we?

We'd thought it would be handy to give cache updates confidence the
far side was indeed responding to the request we thought they were --
and as we contemplate the possibilities of doing precision
event-window locking, rather than edge and corner locking, we could
conceivably have a number of transactions in progress and not know
what order the far side was going to respond to them.  And at that
point we'd really need some kind of transaction tags to match up --
but they wouldn't be seqnos, so...

:122]
:121]

:120]
:119]

:118]
:117]

:116]

:115]

:114]
[123:

Sat Feb 15 23:41:00 2020 Well fog it let's just do along the lines of
:119: -- plus a seqno -- and see where it gets us.

:123]
[124:

Sun Feb 16 16:16:39 2020 Jeez we compiled clean.  But I'm sure there's
horrible gaps all over the place.[125:

Sun Feb 16 16:18:05 2020

RISKY BITS OFF

:125]

:124]
[126:

Mon Feb 17 09:52:05 2020 OK time to move the flag again.  We've made a
bunch of progress but there's still lots of gaps and confusion in the
code.  Current status is do like:

    # echo f00 > /sys/class/itc_pkt/debug ; sleep 10 ; echo 0 >/sys/class/itc_pkt/debug

to flash debugging, and see stuff like:

    [14054.095675] (NW) UPDATE ss->mLevelStage=L00 advance=false
    [14054.107739] diffToNext=-3499100, jifTil=-3499079
    [14054.119011] final diffToNext=-3499100
    [14054.643753] kitc=0, timeout=3438240, now=3438416
    [14054.651715] (ET) UPDATE KITC them=L10
    [14054.661984] (ET) UPDATE reqmts level=0, ops=91665ae0
    [14054.673107] (ET) UPDATE reqmts level=1, ops=86da6820
    [14054.683718] (ET) UPDATE post reqmts enterlevel=1, enterstage=0
    [14054.698782] (ET) UPDATE ss->mLevelStage=L10 decideAction=5
    [14054.711049] (ET) MORE ME UPDATE newLS=L10 nextls=L10
    [14054.722806] (ET) UPDATE ss->mLevelStage=L10 advance=false
    [14054.735310] ilsPacketIO_CONTACT recv=false startIdx=0 len=255
    [14054.747751] ilsPacketIO_COMMUNICATE recv=false startIdx=2 len=255
    [14054.762948] sendLevelPacket us=L10 them=L10, len=2
    [14054.774857] ET00000000: a2 c4                                            ..
    [14054.789850] itcSideStateSetLastAnnounceToNow: timeoutVar=100, now=3438452, nextTo=3438575
    [14054.798268] recvLevelPacket us=L10 them=L10, pkt=L10
    [14054.803309] WT00000000: a6 c4                                            ..
    [14054.810337] ilsPacketIO_CONTACT recv=true startIdx=0 len=2
    [14054.815876] itcSideStateSetLastAnnounceToNow: timeoutVar=500, now=3438459, nextTo=3438851
    [14054.824119] ilsPacketIO_COMMUNICATE recv=true startIdx=2 len=2
    [14054.830004] (WT) UPDATE KITC them=L10
    [14054.833714] (WT) UPDATE reqmts level=0, ops=91665ae0
    [14054.838743] (WT) UPDATE reqmts level=1, ops=86da6820
    [14054.843758] (WT) UPDATE post reqmts enterlevel=1, enterstage=0
    [14054.849659] (WT) UPDATE ss->mLevelStage=L10 decideAction=5
    [14054.855197] (WT) MORE ME UPDATE newLS=L10 nextls=L10
    [14054.860210] (WT) UPDATE ss->mLevelStage=L10 advance=false
    [14054.865659] ilsPacketIO_CONTACT recv=false startIdx=0 len=255
    [14054.871456] ilsPacketIO_COMMUNICATE recv=false startIdx=2 len=255
    [14054.877603] sendLevelPacket us=L10 them=L10, len=2
    [14054.882441] WT00000000: a6 c4                                            ..
    [14054.889470] itcSideStateSetLastAnnounceToNow: timeoutVar=100, now=3438477, nextTo=3438572
    [14054.897710] sendLevelPacket (pushto=T) hdr=0xa6 got 2
    [14054.902812] (WT) REANNOUNCED L10, now=3438471, uto=3438259, new=3438572
    [14054.912141] recvLevelPacket us=L10 them=L10, pkt=L10
    [14054.917243] ET00000000: a2 c4                                            ..
    [14054.924279] ilsPacketIO_CONTACT recv=true startIdx=0 len=2
    [14054.929824] itcSideStateSetLastAnnounceToNow: timeoutVar=500, now=3438487, nextTo=3438884
    [14054.938064] ilsPacketIO_COMMUNICATE recv=true startIdx=2 len=2
    [14054.943948] (ET) UPDATE KITC them=L10
    [14054.947654] (ET) UPDATE reqmts level=0, ops=91665ae0
    [14054.952667] (ET) UPDATE reqmts level=1, ops=86da6820
    [14054.957678] (ET) UPDATE post reqmts enterlevel=1, enterstage=0
    [14054.963561] (ET) UPDATE ss->mLevelStage=L10 decideAction=5
    [14054.969107] (ET) MORE ME UPDATE newLS=L10 nextls=L10
    [14054.974120] (ET) UPDATE ss->mLevelStage=L10 advance=false
    [14054.999793] sendLevelPacket (pushto=T) hdr=0xa2 got 2
    [14055.011620] (ET) REANNOUNCED L10, now=3438438, uto=3438240, new=3438575
    [14055.026905] diffToNext=0, jifTil=159
    [14055.035909] kitc=1, timeout=4294906276, now=3438416
    [14055.047735] (SE) UPDATE KITC them=L00

with an ET-WT loopback cable.

:126]
[127:

Mon Feb 17 23:12:49 2020 OK.  I really really have to be working on
OTHER STUFF but we're finally making 'progress' here and I'm loathe to
give up on the state that I am still managing to hold in my head.

So going again here.[128:

Mon Feb 17 23:14:31 2020 Changing the default timeouts to 300/1000.

:128]

:127]
[129:

Mon Feb 17 23:26:07 2020 Implementing .require default

:129]
[130:

Tue Feb 18 01:50:26 2020 So one current issue is we don't announce if
advance returns false, even if we've changed stages.

We're wondering if we really need .advance at all.  At the moment it's
only used by the limiting cases:

    #define ALL_LEVELS_MACRO()                                    \
    /*         name   cust req tmo, pio, dcd, adv, state (NOT USED) */ \
    /* 0 */ XX(CONTACT,      1,  1,   1,   0,   1,            _)       \
    /* 1 */ XX(COMMUNICATE,  1,  0,   1,   0,   0,   _/*u16 ttoken*/)  \
    /* 2 */ XX(COMPATIBILITY,0,  0,   1,   1,   0, _/*MFZId tMFZId*/)  \
    /* 3 */ XX(COMPUTATION,  0,  1,   0,   0,   1,            _)       \

..but ilsAdvance_CONTACT is where we check for packet sync, so that is
pretty important.  ilsAdvance_COMPUTATION just returns false, but it
wouldn't be so bad to automatically infer that on the last level
anyway.

But the first advance matters.  Is it that we want .advance to be ||'d
with LS change, to decide when to announce?  That seems wrong.  We
want to announce every LS change once we have packet sync.  And it
almost seems like we'd prefer to announce all LS changes, period, with
some understanding that the announcement getting tossed somewhere
below when there's no packet sync.

But in any case it seems we definitely want to decouple announcements
from advancements.

:130]
[131:

Tue Feb 18 03:14:39 2020 So we have an awful lot of fingers in the
changing-the-LS pie inside updateKITC:

 - We begin with 'prevLS' captured on entry to updateKITC.  Now, could
   that have been changed, during recvLevelPacket, since the last
   updateKITC?  Or does recvLevelPacket just manipulate other state --
   like mThem -- but leave mUs alone?[132: Seems only mThem is touched..  :132]

 - The .require loop produces a maximum supported level[133: Tue Feb
   18 03:42:06 2020  ..that's in local 'newLS' and immediately stored
   in mUs.mLevelStage.  Not sure if we want to commit that fast but
   we'll see.

 - We then run .decide JUST FOR THAT NOW-STORED newLS, and get an
   action which leads to 'nextLS'.  So now there's 'prevLS', 'newLS',
   and 'nextLS', all at least potentially different.

 - Then we run .advance based on the then-prevailing mUs (== newLS
   ATM).  If it returns true, we set 'advanceLS' by incrementing
   newLS, if there's any headroom left considering MAX_LEVEL_NUMBER.

 - Then, AND ONLY THEN, we announce, if advanceLS ends up different
   than (effectively) newLS.

So that's clearly messed up.  We won't ever announce downshifts?

We should make whatever decisions about LS we want -- and that
obviously needs to be thought through again -- but then at the end of
updateKITC we should announce based only on the final LS vs the prevLS
we captured on entering.
[134:

Tue Feb 18 06:26:20 2020 So, post walk: How should the post-updateKITC
LS be determined?  Consider the factors:

 0: prevLS: The LS we had at the beginning of the updateKITC
 1: supportLS: The LS determined by the prev LS and the current support
 2: uTimeoutLS: The LS implied by the .timeout LevelAction if mUs timeout occured
 3: tTimeoutLS: The LS implied by the .timeout LevelAction if mThem timeout occured
 4: decideLS: The LS implied by the .decide LevelAction
 5: advanceLS: The LS implied by the .advance LevelAction

Derive:
 downLS : The min of whichever 1-3 are applicable.

If downLS < prevLS, then resultLS = downLS.
else {
   compute decideLS
   if decideLS < prevLS, then result = decideLS
   else {
     compute advanceLS
     if advanceLS > prevLS, then result = advanceLS
   }
}

then if resultLS != prevLS {
  mUs.mLevelStage = resultLS
  sendLevelPacket
}
[135:

Tue Feb 18 13:59:53 2020 So could we make it a find-first-down-LS loop
and only check advance if no downs are found?  And simplify things
that way?

:135]
:134]

:133]

:131]
[136:

Tue Feb 18 17:03:06 2020 Well, building clean again.  Now updateKITC
is basically just a loop and a check and a send:

    void updateKITC(ITCMFMDeviceState * mds)
    {
 ..
      for (i = 0; i < sizeof(lsEvals)/sizeof(lsEvals[0]); ++i) {
        LSEvaluator eval = lsEvals[i];
        nextLS = (*eval)(mds,prevLS);
        if (nextLS != prevLS) break; /* found a move, stop */
      }
      if (nextLS != prevLS) {
        ss->mLevelStage = nextLS;
        sendLevelPacket(mds,false); /*pushes timeout if sent*/
      }
    }

with the idea that '.advance' is last in the lsEvals:

    static LSEvaluator lsEvals[] = {
      &lsEvaluatorSupport,
      &lsEvaluatorUTimeout,
      &lsEvaluatorTTimeout,
      &lsEvaluatorDecide,
      &lsEvaluatorAdvance
    };

..and it's the only one that might go up in LS; all the rest go down
or stay the same.

With this 'clean' scheme, we may be going to sendLevelPacket when
there isn't PS, what will happen there?  [137:

Tue Feb 18 17:09:54 2020 What will happen is ilsPacketIO_CONTACT will
detect no PS and return 0, causing sendLevelPacket to NOT attempt to
send a packet but YES TO update the utimeout as if we had.

And ilsTimeout_CONTACT appears to set everybody's timeouts to 10k
jiffies (which is probably 10s?) which seems plenty long to come back
around and check PS.[138:

Tue Feb 18 17:26:52 2020 Hmm,

    root@beaglebone:~# getconf CLK_TCK
    100
    root@beaglebone:~#

and

/usr/include/asm-generic/param.h:6

    #ifndef HZ
    #define HZ 100
    #endif

suggest on my BBG, a jiffy is 1/100s, so 10k jiffies would be 100s..

:138]

:137]

:136]
[139:

Tue Feb 18 17:42:56 2020

RISKY BITS OFF

:139]
[140:

Tue Feb 18 17:51:53 2020 Have to break for cooking; just started
debugging.  Got to where ET and WT advanced to L01, but then it seems
that WT is thinking it's still L00 and is announcing L01 again..[141:

Wed Feb 19 01:13:39 2020 Added more logging to follow along closer.

RISKY BITS OFF

:141]

:140]
[142:

Wed Feb 19 03:08:44 2020 Still tracing through.  Bug in
lsEvaluatorSupport wasn't dropping us back when level support failed.
Still fussing with timeout and timedifferences.  Going again.

RISKY BITS OFF

:142]
[143:

Wed Feb 19 03:44:33 2020 OK so the lsEvals[] iteration has the problem
that it's not (necessarily or usually) pushing expired timeouts, so
they keep happening.

We wanted to tie the timeout push to sending level announcements but
that seems unreliable at least at present.  Could we say that just
returning the mTimeoutAction is grounds enough for pushing the
timeout, then it's somebody else's problem if they didn't do a send or
whatever due to that mTimeoutAction?[144:

Wed Feb 19 03:49:19 2020 Well, trying that.  But that still won't deal
with multiple timeouts hitting in a single updateKITC

:144]

:143]
[145:

Wed Feb 19 13:27:34 2020 OK, so we've made yet another new minor for
/dev/itc/itcevents.  If we can find a useful 9 bit code for itc
events, we can back-fit them into the existing itcpktevent.h framework
with a minimum of fuss.

Things we might like to know:

LS: dir6:3 + op0:1 + LS:5
  dir6:3 bits with 6,7 reserved
  op:  2 bits
  LS:  5 bits as 3+2 for L00..L72

    op0
     0 + newus
     1 + newthem

fmt6: 110:3 + op6:3 + dir6:3
    op6
     000 ITCDN
     001 ITCUP
     010 UPBEG
     100 UPEND
     101 
     110 
     111 

fmt7: 111:3 + spec:6
    spec
     0000 RSRV
     0001 DO_REENTER
     0010 DO_RESTART
     0011 DO_RETREAT
     0100 DO_ADVANCE
     0101 DO_CONTINUE
     0110 TIMEOUT
     0111..1111 rsrv

:145]
[146:

Wed Feb 19 14:44:08 2020 So what's the deal here?  addPktEvent very
ominously says:

    /*MUST BE CALLED ONLY AT INTERRUPT LEVEL OR WITH INTERRUPTS DISABLED*/
    void addPktEvent(ITCPktEventState* pes, u32 event) {

but then all through itcpkt.c there are calls on ADD_PKT_EVENT, and no
calls on ADD_PKT_EVENT_IRQ, but only the latter disables interrupts..

itcpkt.c:304
  if (ret == 0) 
    ADD_PKT_EVENT(makePktXfrEvent(PEV_XFR_TO_PRU, ipb->mPriority, log2in3(pktlen), prudev->mTempPacketBuffer[0]&0x7));

doesn't look to be at interrupt level -- it's (indirectly) called from
itcOBPktThreadRunner. 

itcpkt.c:1678
      if (ret == 0) 
        ADD_PKT_EVENT(makePktXfrEvent(PEV_XFR_FROM_USR, minor != PKT_MINOR_BULK, log2in3(copied), tmp[0]&0x7));

doesn't either -- it's (indirectly) called from itc_pkt_write.

So who's wrong: All those calls, or the scary comment (or both)?
[147:

Wed Feb 19 14:50:19 2020 So in 20190901333-pkt-traceevent-notes.txt, I
see this:

    Mon Sep  2 03:32:38 2019 Hmm for one thing we need to be calling
    ADD_PKT_EVENT_IRQ not ADD_PKT_EVENT..  I doubt that's our current
    issue though.

ah but then I also see:

    Mon Sep  2 05:29:13 2019 So we really have no explanation for the
    original page fault we saw.  We don't actually think we even need to
    use ADD_PKT_EVENT_IRQ either, because we're not doing interrupt stuff
    on the itc_pkt side.  

So I think it's the scary comment that's (currently) wrong.
[148:

Wed Feb 19 14:53:37 2020 Changed the scary addPktEvent comment to:

    /*WARNING: IF INTERRUPT HANDLERS ARE IN USE (which they are evidently
      NOT in itcpkt), THEN THIS MUST BE CALLED ONLY AT INTERRUPT LEVEL OR
      WITH INTERRUPTS DISABLED */

[149:

Wed Feb 19 14:54:29 2020 OK, back to trying to sprinkle around some
ADD_IT_EVENT callshere..

:149]:148]
:147]
:146]
[150:

Wed Feb 19 15:25:01 2020 OK a first cut at /dev/itc/itcevents is
building successfully.  Time for

RISKY BITS OFF

:150]
[151:

Wed Feb 19 16:16:19 2020 Yikes, apparently the itc_pkt userspace event
decoder never made it into the T2-12 repo?!  I just copied (a version
of) it off of the old 4.4.54 keymaster --- which I had carefully NOT
yet reflashed --- and will stick in the repo now, but, yow.  That
could have been significant work lost.

RISKY BITS OFF

:151]
[152:

Thu Feb 20 05:31:20 2020 OK, well we've finally gotten t2trace working
plausibly here on 4.19.79.  And now we can START modifying it to read
/dev/itc/itcevents too.  It was a pretty big hack to force two event
streams together and it will be an even bigger gross hack to force a
third in the same way, so we'll need to smooth out the
next-event-picking logic, I'd think, in this process.

:152]
[153:

Thu Feb 20 16:08:07 2020 OK, time to make install and reboot and see
how the events trace out.  Committing this stuff.

:153]
