{80}  -*- text -*- 
[0:

Sun Nov 12 12:54:47 2017 Yay we finally have 'go.el' on the tiles!  Or
at least the subset of go.el that we actually use..

[1:

Sun Nov 12 12:55:31 2017 So, we're here to have a place to discuss all
the issues of talking packets back and forth between the PRUs and
kernelspace and userspace.

Of course we're way in the middle of things here.  One current issue
is: Do we need a custom LKM for this at all, or could we just use some
existing thing that presents RPMsg IO to userspace?  We've seen claims
that some demo or some kind of module will create devices like
/dev/rpmsg_pru30 that we could theoretically write and read packets
from.  But so far we haven't managed to demonstrate that.[2:

Sun Nov 12 14:19:43 2017 It seems perhaps like we need the 'correct'
crap on the PRU side for the LKM side 'probe' to create the devices.
There's these comments in PRU code like:

/*
 * Using the name 'rpmsg-client-sample' will probe the RPMsg sample driver
 * found at linux-x.y.z/samples/rpmsg/rpmsg_client_sample.c
 *
 * Using the name 'rpmsg-pru' will probe the rpmsg_pru driver found
 * at linux-x.y.z/drivers/rpmsg/rpmsg_pru.c
 */

so if my current demo fws aren't using the right sort of names..
..what name is my current demo using?[3:

Sun Nov 12 14:23:18 2017 Well, I guess it's using

    /*
     * Using the name 'rpmsg-pru-itcio' will probe the rpmsg_pru driver found
     * at linux-x.y.z/drivers/rpmsg/rpmsg_pru_itcio.c
     */
    #define CHAN_NAME					"rpmsg-pru-itcio"
    #define CHAN_DESC					"Channel 31"
    #define CHAN_PORT					31

according to pru/itcio/firmware/main_pru1.c[4:

Sun Nov 12 14:49:01 2017 Well it seems more the other way around.  I
copied the modules_install stuff from lkms/itc/Makefile, and after
running that, it seems that 'modprobe rpmsg_pru_itcio' boots the PRU:

    root@beaglebone:/home/t2/T2-12/pru/itcio/firmware# modprobe rpmsg_pru_itcio
    Nov 12 14:48:34 beaglebone kernel: [52236.139924]  remoteproc2: powering up 4a338000.pru1
    Nov 12 14:48:34 beaglebone kernel: [52236.169561]  remoteproc2: Booting fw image am335x-pru1-fw, size 71100
    Nov 12 14:48:34 beaglebone kernel: [52236.196808] ti-pruss 4a300000.pruss: configured system_events = 0x00000000000c0000 intr_channels = 0x0000000a host_intr = 0x0000000a
    Nov 12 14:48:34 beaglebone kernel: [52236.251818]  remoteproc2: remote processor 4a338000.pru1 is now up
    Nov 12 14:48:34 beaglebone kernel: [52236.277011] virtio_rpmsg_bus virtio0: rpmsg host is online
    Nov 12 14:48:34 beaglebone kernel: [52236.282695] virtio_rpmsg_bus virtio0: creating channel rpmsg-pru-itcio addr 0x1f
    Nov 12 14:48:34 beaglebone kernel: [52236.316205] rpmsg_pru_itcio rpmsg0: chnl: 0x400 -> 0x1f
    Nov 12 14:48:34 beaglebone kernel: [52236.346715] rpmsg_pru_itcio rpmsg0: pru_itcio device ready at /dev/rpmsg_pru_itcio
    root@beaglebone:/home/t2/T2-12/pru/itcio/firmware#                

Committing this as a checkpoint, adding rpmsg_pru_itcio to my
/etc/modules stuff, and trying a reboot..

:4]

:3]

:2]

:1]

:0]
[5:

Sun Nov 12 17:01:34 2017 OK, so it's gross and we're doing it by hand
in t2-startup.sh, but we have a functioning /dev/rpmsg_pru_itcio
getting created at boot.  Now we 'just' have to make it useful.

The current hard part is doing something sensible on the read side.
I think we're going to try to find some kfifo sample code and buffer
the incoming rpmsg packets there, and have the read side draw from the
kfifo.  First question: Does a kfifo work in blocks or bytes?  In
other words, are we going to lose our rpmsg packet boundaries going in
and out of a kfifo?  Is a kfifo a linked list of blocks or a circular
byte array??[6:

Sun Nov 12 17:31:00 2017 Not completely clear but sort of looking like
kfifo is byte-oriented, despite some stuff talking about 'records'.

Q: Could we just leave stuff in the rpmsg queue until userspace comes
along to read it?  The queue would fill fast but we're expecting mfmt2
to basically have a thread sitting on the read side, pulling packets
to userspace for dishing off.  Or maybe it's polling during events and
stuff, advancing communications.

But we can't really ignore the rpmsg callback, because it's up to us
to get rid of data[len] at that point; rpmsg is going to assume we
did.  So we could make our own linked list of packets, using the
kernel's linked list stuff rather than the kfifo.[7:

Sun Nov 12 18:07:24 2017 Or we could use skb's from the network
stack??  That seems like a huge kettle of fish, but then we could
conceivably be routing more or less genuine network crap between
tiles, for good and for ill.. 

:7]

:6]

:5]
[8:

Tue Nov 14 18:12:42 2017 OK, pushing all this crap as a checkpoint.
Renamed the module to itc_pkt and made its device be /dev/itc/packets,
to be a sibling of /dev/itc/locks.  Probably should be /dev/t2/*, but
deal with that later.

:8][9:

Thu Nov 16 22:36:46 2017 All right; we lost a couple of days to
stuff, but here we are again.  What about those skb's?  Any chance
they're at all general purpose?[10:

Thu Nov 16 22:44:01 2017 Well, it looks mostly byte-oriented too, but
with special support for packet heads and tails.  So at that point it
seems we might just as well use a kfifo but enforce the discipline
that we grow and shrink it by units of packets, and we use our own
packet framing discipline to know where the packet boundaries are
starting from the current head of the kfifo.

At least, let's take that provisionally and see where it gets us.

Let's review our packet semantics document from way back when -- when
we were thinking an FPGA for comms -- and see how much we still might
like it.[11:

Thu Nov 16 23:08:13 2017 OK, the file is MFMPFD11.txt, now copied but
not commited in T2-12/doc.

It's calling for a two byte header on a 255 max packet size, with the
data alleged to be byte-escaped to eliminate nulls, but no actual data
format is included in MFMPFD11.[12:

Thu Nov 16 23:46:04 2017 And hmm indeed, it looks like kfifo (at least
in 2009) explicitly supports variable-length records between 0 and 255
bytes..  Except I think it wants the length in the first byte rather
than the second; dunno.[13:

Thu Nov 16 23:55:56 2017 What if we took that to heart?  In principle
I like having the length first anyway.. we were toying with having the
start-of-byte be an extra 1 bit before the first packet byte, in which
case we could have a whole first byte for length if we wanted it..  If
you send 15 or more straight 0s then the channel goes idle, and at
that point the first 1 bit to arrive is a byte-alignment start bit
rather than a data bit.  But you send packets back-to-back if you have
them, and the byte sync just carries over.

Now one thing is we do have to keep clocking _all_ the live channels
all the time -- even if some of them are 'idle' -- so that either side
can start a packet any time it wants.  But once the channels are
logically idle we won't be generating bytes for inbound packets.
[14:

Fri Nov 17 00:11:54 2017 Now, we really could do bit or byte stuffing
on the wire, with a privileged packet delimiter, but then convert them
to counted packets before sending them to linux.  Or maybe we can just
count on the rpmsg framing to imply the count?  Or not, because we
might have a lot of short packets which could burn a lot of rpmsg
buffers, when memory is not that cheap down toward the PRU end of
things?

But in any case we would say the beginning of an rpmsg is always the
beginning of a packet?  But then could we dare to put multiple packets
in one buffer?  I suppose as long as there's more than max packet len
bytes still in the rpmsg buffer we could keep going.  But that would
tend to increase latency.. Who knows..

[15:

Fri Nov 17 00:49:00 2017 Pop pop pop..  So, status:

(1) We're going to try using a kfifo in its recsize==1 mode

(2) We're going to do bit stuffing on the wire with a reserved
    end-of-packet / start-of-packet sequence.

(3) We're going to unstuff the bits and assemble bytes in PRU memory
    while tracking the len and updating the packet status.

(4) Our PRU code will have a single incoming and a single outgoing
    packet buffer for each direction (so, three in and three out per
    PRU, six in and six out overall).

(5) Our PRU main loop will just continually advance the wire bit state
    machines for each direction, and those state machines will report
    conditions like 'incoming packet complete' and 'outgoing packet
    buffer empty', and in response the PRU main loop will service them
    appropriately, calling pru_rpmsg_send in the former case and/or
    pru_rpmsg_receive in the latter.  If there's no more rpmsg buffers
    available for sending data to linux, we mark the packet blown and
    start discarding until another start-of-packet.  If there's no
    more rpmsg buffers available containing data from linux, the
    corresponding output channel goes idle.

'And that's all there is to it.'  Yahright.[16:

Fri Nov 17 01:30:44 2017 And we're still thinking the wire bit state
machines are written in assembler, using the context-switching design
previously worked up.. but we're not sure how that's going to
interface to the the main loop, which we are thinking is going to be
C.

Now, I don't think we actually ate all the registers in our state
machine design.  Could we try to see if there's a way to get along
with the clpru usages?[17:

Fri Nov 17 09:36:55 2017 All right, so it's all about 'spruhv7a.pdf',
the 'PRU Optimizing Compiler C/C++ Compiler v2.1 (Rev. A)' manual.
[19:

Fri Nov 17 09:41:45 2017 And the key table for register usage appears
to be Table 6-4 on page 105-106:

   Table 6-4. Register Usage
    Register  Usage                   Save on Call    Save on Entry
     R0.w0     Expression register     Yes
     R1        Expression register     Yes
     R2        Stack pointer (SP)
     R3.w0     Expression register
     R3.w2     Expression register                     Yes
                (usually used as Link
                register to store the
                return address) 
     R4        Argument pointer (AP)                   Yes
     R5        Expression register                     Yes
     R6        Expression register                     Yes
     R7        Expression register                     Yes
     R8        Expression register                     Yes
     R9        Expression register                     Yes
     R10       Expression register                     Yes
     R11       Expression register                     Yes
     R12       Expression register                     Yes
     R13       Expression register                     Yes
     R14       Return register         Yes
     R15       Expression register     Yes
     R16       Expression register     Yes
     R17       Expression register     Yes
     R18       Expression register     Yes
     R19       Expression register     Yes
     R20       Expression register     Yes
     R21       Expression register     Yes
     R22       Expression register     Yes
     R23       Expression register     Yes
     R24       Expression register     Yes
     R25       Expression register     Yes
     R26       Expression register     Yes
     R27       Expression register     Yes
     R28       Expression register     Yes
     R29       Expression register     Yes
     R30       Control register
     R31       Control register

[20:

Fri Nov 17 10:13:17 2017 Aand how does that fit together with what we
were imagining in a pure ASM environment?  From
T2-local/candidates/beagleboardgreen/BBG-SHR/SymmetricBitstreamTransceiver.inc:

    /*
       PRUx REGISTER USAGE

       R0 : reserved for context switching
       R1 : arg ret + tmp
       R2-6 : temp caller saves
       R7-9 : temp callee saves
       R10-17 : context register (see below)
       R18-29 : reserved
       R30 : direct GPIO output
       R31 : status and direct GPIO input
    */
                                

and I think everything but R30 and R31 are actually movable.  In
particular, the 8 register context struct just has to be contiguous
but can otherwise go anywhere.

But if the main loop is, in effect, the context-switching threaded
state machines, that means we will need to be calling C from ASM, not
(just) the reverse.

[21:

Fri Nov 17 11:01:39 2017 So I don't know if I have the strength for it
now, but it seems one good workflow spike would be to write an ASM
main loop that does the processing currently in main_pru1.c.
Something like:

//C

struct pru_rpmsg_transport transport;

unsigned getOutboundPacket(uint8_t * buffer) {
   unsigned len;
   if (pru_rpmsg_receive(&transport, &src, &dst, buffer, &len) != PRU_RPMSG_SUCCESS)
     return 0;
   return len;
}
void putInboundPacket(uint8_t * buffer, unsigned len)
{
   pru_rpmsg_send(&transport, dst, src, buffer, len);					
}

int main() {
   uint16_t src, dst, len;

   /* allow OCP master port access by the PRU so the PRU can read external memories */
   CT_CFG.SYSCFG_bit.STANDBY_INIT = 0;

   /* clear the status of the PRU-ICSS system event that the ARM will use to 'kick' us */
   CT_INTC.SICR_bit.STS_CLR_IDX = FROM_ARM_HOST;

   /* Make sure the Linux drivers are ready for RPMsg communication */
   status = &resourceTable.rpmsg_vdev.status;
   while (!(*status & VIRTIO_CONFIG_S_DRIVER_OK));

   /* Initialize pru_virtqueue corresponding to vring0 (PRU to ARM Host direction) */
   pru_virtqueue_init(&transport.virtqueue0, &resourceTable.rpmsg_vring0, TO_ARM_HOST, FROM_ARM_HOST);

   /* Initialize pru_virtqueue corresponding to vring1 (ARM Host to PRU direction) */
   pru_virtqueue_init(&transport.virtqueue1, &resourceTable.rpmsg_vring1, TO_ARM_HOST, FROM_ARM_HOST);

   /* Create the RPMsg channel between the PRU and ARM user space using the transport structure. */
   while (pru_rpmsg_channel(RPMSG_NS_CREATE, &transport, CHAN_NAME, CHAN_DESC, CHAN_PORT) != PRU_RPMSG_SUCCESS);

   mainLoop(&transport);
}

;ASM
.whatever mainLoop
    ;; R14 is ptr to transport
    blah
    blah
    ;; call getOutboundPacket for more data to send
    blah
    ;; call putInboundPacket for push received data to linux

:21]

:20]
:19]

:17]

:16]


:15]

:14]


:13]

:12]

:11]


:10]

:9]
[18: Fri Nov 17 09:39:47 2017 Hmm using the go macros makes it much
more obvious this T2 tile is running on GMT.  Confusing.  It's 2:40AM
here in Mountain Time.  :18]
[22:

Fri Nov 24 07:28:52 2017 OK godamn it

(1) Demo C code running on two PRUs talking to linux
(2) Demo C calling an ASM routine and it returning something
(3) Demo that ASM routine calling another C routine.

[23:

Fri Nov 24 07:30:44 2017 How to push toward (1)?  Let's try to get our
itcio LKM to support two minor devices.  That hadn't seemed hopeless
last time we worked, IIRC.

:23]

:22]
[24:

Fri Nov 24 10:28:47 2017 Useful info from http://theduchy.ualr.edu/?p=996

    The structure of communications using INTC can be seen in the
    Technical Reference Manual, Table 4-17.

    PRU0 is connected to Host-0 using R31 bit 30.

    PRU1 is connected to Host-1 using R31 bit 31.

    System events (SYS_EVT) are connected to one of the ten channels
    (0..9).  This channel connection is done through the resource table.

    Table 4-21 demonstrates the Interrupt number and connection to a
    pin. Pins 16, 17, 18, and 19 are connected to signals
    pr1_pru_mst_intr[0]_intr_req, pr1_pru_mst_intr[1]_intr_req,
    pr1_pru_mst_intr[2]_intr_req,  and pr1_pru_mst_intr[3]_intr_req.

:24]
[25:

Fri Nov 24 11:37:35 2017 OK, well, after just the right amount of pain
and suffering, apparently, I now have both pru0 and pru1 up and
running the minimal packet demo code, as /dev/itc/packets0 and
/dev/itc/packets1, respectively.

Finally.

Thinking of renaming to /dev/itc/pru0 etc but uncertain if my current
flow guarantees that pru0 will always get minor 0.

In any case, pushing all this.

:25]
[26:

Fri Nov 24 12:32:42 2017 So it was possible for pru1 to get minor 0
and vv, but I've now rehacked to not use idr_alloc for minors and
instead use (rpmsg->dest - 30), which appears to do what we want.

Renaming to /dev/itc/pru[01].


:26]
[27:

Fri Nov 24 15:00:28 2017 OK, so boot time stuff remains messed up --
with some indications on the net that RCN was making changes in
related stuff in mid-2017, so whatever.  We're now just rebinding the
pru stuff in our own boot script.

:27]
[28:

Fri Nov 24 20:31:54 2017 OK, so it appears we're sometimes losing
ARM->PRU interrupts destined for PRU0.  I am perfectly willing to
believe whatever the reason is it's my lack of knowledge, and
consequent incorrect configuration/coding, that's to blame.

In any case, rather than continue down that debugging hole at present,
instead we have enabled the PRU instruction cycle counters, and have
added a backup 1HZ timeout for incoming messages: If it's been more
than 200M cycles since the last ARM->PRU interrupt, we go ahead and
check for messages (and reset the timeout clock) anyway.[29:

Fri Nov 24 21:53:23 2017 And the threat of timeout appears to be
sufficient to keep the interrupts arriving, across reboot reloads and
what-not -- at least, I'm seeing pretty regular ~5ms RTT for the
current setup (with lots of kernel logging and all and etc), without
any ~500ms outliers one might expect if the timeout was kicking in.

Committing all this.  Time to push on to case (2) from :22: above.

:29]

:28]
[30:

Fri Nov 24 22:24:31 2017 Summarizing register usage:


 r2 contains the stack pointer,
 r3 contains the return address,
 r14 to r29 are used for argument passing,
 r14 is used for the return value,
 r3 to r13 must be saved by the callee.

(from https://www.embeddedrelated.com/showarticle/603.php)

:30]
[31:

Sat Nov 25 13:58:23 2017 OK, well, so after all sorts of worthless and
worthwhile diversions, we finally appear to qualify for having done
(2) from :22: above.  Here's us calling an asm routine from C:

    ..
    extern int addfuncasm(int a, int b);
    ..
            payload[0]++; /* But increment the first byte to show we care */
            payload[0] = addfuncasm(payload[0]+1, ON_PRU); /* add extra increments via asm */
    ..

and here's the function:

            .global addfuncasm
    addfuncasm:
            ADD R14, R15, R14
            JMP r3.w2
        
and here's the behavior:

    root@beaglebone:/home/t2/T2-12/pru/itcio# echo aaa > /dev/itc/pru1
    Nov 25 13:58:04 beaglebone kernel: [  875.954349] itc_pkt itc!pru1: Write count 4 / max 496
    Nov 25 13:58:04 beaglebone kernel: [  875.968757] itc_pkt itc!pru1: Sending 4 starting with a
    Nov 25 13:58:04 beaglebone kernel: [  875.974292] Received 4
    Nov 25 13:58:04 beaglebone kernel: [  875.976667] pkt:64 61 61 0a                                      daa.
    root@beaglebone:/home/t2/T2-12/pru/itcio# echo aaa > /dev/itc/pru0
    Nov 25 13:58:08 beaglebone kernel: [  879.922753] itc_pkt itc!pru0: Write count 4 / max 496
    Nov 25 13:58:08 beaglebone kernel: [  879.937989] itc_pkt itc!pru0: Sending 4 starting with a
    Nov 25 13:58:08 beaglebone kernel: [  879.943529] Received 4
    Nov 25 13:58:08 beaglebone kernel: [  879.945947] pkt:63 61 61 0a                                      caa.
    root@beaglebone:/home/t2/T2-12/pru/itcio# 

So there's that.

Moving on to (3).  Would like to jump the ambition a little and have
our C function called from asm generate an rpmsg_send of a variable or
something.  We'll see.
[32:

Sat Nov 25 18:44:13 2017 Well, now have a SENDVAL macro that takes a
string and a register and sends a message to linux containing same,
and we're calling it from asm.

Committing.

:32]
:31]
[33:

Sun Nov 26 06:43:56 2017 OK, so a good next step would be the ability
to read and set the PRU-controlled pins.  That will let us answer the
following still-outstanding 'fourth round' questions:

[56: DONE  :56](4.1) Can we really read and write the ITC pins via the PRUs?

(4.2) Can we really control ALL the relevant pins, including the ones
   with contested lines and the ones we stole from other low-level
   functions like the cape I2C?

(4.3) Do the signals appear reliable at essentially DC clocking rates?

while leaving open the big money Fifth Round Questions:

(5.1) Can we implement the SBST state machines and have them actually
   work, in a time period like, say, this semester?

(5.2) Can we actually send a packet across tiles from linux to linux via
   the PRUs and the external connectors?

while not approaching or forgetting the Final Round Questions:

(6.1) Will our signal integrity start to break down, at speeds our
   initial code will be able to achieve?  Or In Other Words

(6.2) HOW FUCKING FAST WILL ALL THIS GO IN ACTUAL REALITY? 


:33]
[34:

Sun Nov 26 07:02:59 2017 So, for (4.1), we want some simple command
and respond format between itc_pkt and the PRUs.  We're already
planning/using the following packet design decisions:

 - First byte is packet type.

 - Any packet type with its high-order bit set is an intertile data
   packet (inbound or outbound depending on direction).  The remaining
   seven bits of a data packet type will not be locked down until we
   get there but are likely to include 3 bits of src/dst, an overrun
   bit, and an error bit.

 - Any packet type with its high-order bit clear is a special command,
   with semantics that depend pretty utterly on the packet type.

 - Special packet type 'V' (inbound) is now already defined to be a
   "debug print 'V'alue" going from PRU to linux.  ('V' outbound is
   currently undefined.)

And now we're going to lay down a couple more special packet types.

 - 'R' (outbound) shall mean 'Read R31 and report its current value here'

 - 'R' (inbound) shall mean 'You asked for R31 and here it is'

 - 'W' (outbound) shall mean 'Write R30 with these bits'

 - 'W' (inbound) shall mean 'I wrote these bits to R30'.

We're thinking we might use a fill-in-the-blank style packet format
here, which could give us some nice properties like flexibility and
cheapness.  Specifically, suppose 'R' (outbound) -- let's call it
R/out -- worked like this:

  'R'

[35:

Sun Nov 26 07:43:02 2017 Holy crap look at this:

    root@beaglebone:/sys/kernel/debug/remoteproc# ls remoteproc1
    name  recovery	regs  single_step  state  version
    root@beaglebone:/sys/kernel/debug/remoteproc# cat remoteproc1/regs 
    ============== Control Registers ==============
    CTRL      := 0x0000800b
    STS (PC)  := 0x0000003a (0x000000e8)
    WAKEUP_EN := 0x00000000
    CYCLE     := 0x0af1df26
    STALL     := 0x03489034
    CTBIR0    := 0x00000000
    CTBIR1    := 0x00000000
    CTPPR0    := 0x00000100
    CTPPR1    := 0x00000000
    =============== Debug Registers ===============
    PRU is executing, cannot print/access debug registers.
    root@beaglebone:/sys/kernel/debug/remoteproc#

Which is coming to us care of Zeek the beaglescope guy's blog entry at
https://www.zeekhuge.me/post/ptp_docs_commands_and_tools/

Although watch out -- things are not quite all as they seem at first:

    root@beaglebone:/sys/kernel/debug/remoteproc# cat remoteproc0/regs
    cat: remoteproc0/regs: No such file or directory
    root@beaglebone:/sys/kernel/debug/remoteproc# 

whaduh?

    root@beaglebone:/sys/kernel/debug/remoteproc# cat remoteproc0/name
    wkup_m3

oh yeah, the little Cortex-M3 in there doing power management..

    root@beaglebone:/sys/kernel/debug/remoteproc# cat remoteproc1/name 
    4a338000.pru1
    root@beaglebone:/sys/kernel/debug/remoteproc# cat remoteproc2/name 
    4a334000.pru0

[36:

Sun Nov 26 07:47:44 2017 And furthermore, look at fricken this:

    root@beaglebone:/sys/kernel/debug/remoteproc# echo 1 > remoteproc1/single_step 
    root@beaglebone:/sys/kernel/debug/remoteproc# cat remoteproc1/regs
    ============== Control Registers ==============
    CTRL      := 0x00000109
    STS (PC)  := 0x0000003b (0x000000ec)
    WAKEUP_EN := 0x00000000
    CYCLE     := 0x00118b01
    STALL     := 0x000543a4
    CTBIR0    := 0x00000000
    CTBIR1    := 0x00000000
    CTPPR0    := 0x00000100
    CTPPR1    := 0x00000000
    =============== Debug Registers ===============
    GPREG0  := 0x0bebc200	CT_REG0  := 0x00020000
    GPREG1  := 0x00118aff	CT_REG1  := 0x48040000
    GPREG2  := 0x000005dc	CT_REG2  := 0x4802a000
    GPREG3  := 0x0037bc06	CT_REG3  := 0x00030000
    GPREG4  := 0x00024000	CT_REG4  := 0x00026000
    GPREG5  := 0x00020024	CT_REG5  := 0x48060000
    GPREG6  := 0x000006d0	CT_REG6  := 0x48030000
    GPREG7  := 0x00000200	CT_REG7  := 0x00028000
    GPREG8  := 0x00000000	CT_REG8  := 0x46000000
    GPREG9  := 0x000006d8	CT_REG9  := 0x4a100000
    GPREG10 := 0x9c65dfd5	CT_REG10 := 0x48318000
    GPREG11 := 0x00000000	CT_REG11 := 0x48022000
    GPREG12 := 0xcd077786	CT_REG12 := 0x48024000
    GPREG13 := 0x3fbcf516	CT_REG13 := 0x48310000
    GPREG14 := 0x0000ffff	CT_REG14 := 0x481cc000
    GPREG15 := 0x000005c0	CT_REG15 := 0x481d0000
    GPREG16 := 0x000005bc	CT_REG16 := 0x481a0000
    GPREG17 := 0x00000001	CT_REG17 := 0x4819c000
    GPREG18 := 0x000005dc	CT_REG18 := 0x48300000
    GPREG19 := 0x00000200	CT_REG19 := 0x48302000
    GPREG20 := 0x00040002	CT_REG20 := 0x48304000
    GPREG21 := 0x20747372	CT_REG21 := 0x00032400
    GPREG22 := 0x72616863	CT_REG22 := 0x480c8000
    GPREG23 := 0x206f7420	CT_REG23 := 0x480ca000
    GPREG24 := 0x646e6573	CT_REG24 := 0x00000000
    GPREG25 := 0x206f7420	CT_REG25 := 0x00002000
    GPREG26 := 0x20656874	CT_REG26 := 0x0002e000
    GPREG27 := 0x6e6f6f6d	CT_REG27 := 0x00032000
    GPREG28 := 0x696c6120	CT_REG28 := 0x00010000
    GPREG29 := 0x00006563	CT_REG29 := 0x49000000
    GPREG30 := 0x00000ff0	CT_REG30 := 0x40000000
    GPREG31 := 0x00000020	CT_REG31 := 0x80000000
    root@beaglebone:/sys/kernel/debug/remoteproc# echo 0 > remoteproc1/single_step 

So we can actually put the PRUs into single-step mode, read their
registers (including R30/R31, looks like), and then put it back in
continuous-run mode, all from the comfort of sysfs.  (The second
column is the contents of the constants table, which could be useful
too.)[37:

Sun Nov 26 07:53:30 2017 It also appears that echoing 1 to single_step,
while it is already in single-step mode, causes the targeted PRU to do
one more instruction and then stop again.  So who's written us a GDB
interface to the effen PRUs??

[38:

Sun Nov 26 07:56:23 2017 Also also, 'dmesg -Hw' appears to be like
'tail -f /var/log/messages', except at the dmesg level.  It doesn't
report 'logger' commands, but I bet it doesn't get log-rotated at
night either..

:38]

:37]

So 'we don't actually need' my 'R' packet, in that sense.  Although as
far as I can tell we might still need 'W' -- [39:

Sun Nov 26 09:20:55 2017 No, looks like we have pretty full
debug-style control if we want it, via memory-mapped addresses.  But
that's not really the whole point anyway, and 'nearly full-speed'
printf debugging isn't the same as clunkachunk breakpoint debugging
for better and for worse.
[40:

Sun Nov 26 09:29:29 2017 There's lots of good stuff in SPRUHF8A.. wish
I'd found it earlier but anyway.

In particular, section 4 table 7 figure 3 page 21 seems to suggest
that at least some of the PRU pins have to have additional
PRU-internal MUX settings, on top of the stuff the device tree is
doing.  Like to get at pr1_pru1_pru_r31[11:8], for example, we need to
set 'pin_mux_sel[0] = 1', however that is done..
[41:

Sun Nov 26 09:56:45 2017 Well, still reading SPRUHF8A, but it's time
well-spent now, I feel.  Reminder that R0.b0 is used to specify a
register shift in XIN and XOUT instructions, which we are planning to
use for our state machine context switching.  Note also that it seems
we have to use different 'device id's for scratch pad destinations on
PRU0 and PRU1.  Device 10 is bank 0, which is nominally meant for PRU,
and device 11 is bank 1 likewise for PRU1.  So we'll apparently need

  XOUT (10+PRU), R4, sizeof(mycontext)

instructions or the like.

Also, XFR register shifting needs to be enabled via the 'SPP register
of the PRU-ICSS CFG register space'.[42:

Sun Nov 26 19:39:13 2017 Which we find in Section 10.1.13 page 288 of
SPRUHF8A.  According to 10.1 page 272, SPP is at +0x40 relative to the
PRU_ICSS_CFG base address, which is at 0x0002_6000 in the PRU local
memory map, according to Section 3.1.2 page 19.[43:

Sun Nov 26 19:46:44 2017 And we have a linker symbol defined for that
address:

	PRU_CFG			: org = 0x00026000 len = 0x00000044	CREGISTER=4

in AM335x_PRU.cmd.[44:

Sun Nov 26 19:49:30 2017 Aand we have definitions for the CFG
registers in T2-12/pru/include/am335x/pru_cfg.h, which has stuff like:

	/* PRU_CFG_SPP register bit field */
	union {
		volatile uint32_t SPP;

		volatile struct {
			unsigned PRU1_PAD_HP_EN : 1;	// 0
			unsigned XFR_SHIFT_EN : 1;	// 1
			unsigned rsvd2 : 30;		// 31:2
		} SPP_bit;
	};	// 0x34

and

	union {
		volatile uint32_t PIN_MX;

		volatile struct {
			unsigned PIN_MUX_SEL : 8;	// 7:0
			unsigned rsvd2 : 24;		// 31:8
		} PIN_MX_bit;
	};	//0x40

inside the 'pruCfg' struct.  Plus a declaration of CT_CFG to be a
constant table near pointer to all that stuff.  So, something like

CT_CFG.SPP_bit.XFR_SHIFT_EN = 1;

'should' suffice to turn on the XFR register shifting we need, and

CT_CFG.PIN_MX_bit.PIN_MUX_SEL = 1;

[45: Sun Nov 26 20:09:50 2017 Except it actually looks like we don't
have to screw with that anyway.  It looks like the default,
CT_CFG.PIN_MX_bit.PIN_MUX_SEL = 10, does what we want, mapping
prus-to-prus in the obvious way in and out.  It looks like the
alternate values -- .PIN_MUX_SEL == 1, 2, or 3 -- are for remapping
stuff or providing stuff in multiple places.  Figures 3 and 4, pp 21
and 22, both show 'bypass' connections for 'pruish' external names
mapping to corresponding pruish internal names, regardless of the
value of PIN_MUX_SEL.

So I think that one's a false alarm.  But the

  CT_CFG.SPP_bit.XFR_SHIFT_EN = 1;

thing I'm fairly confident we will need.

:45]

:44]

:43]
:42]

:41]

:40]

:39]

:36]

:35]

:34]
[46:

Sun Nov 26 20:20:00 2017 And 'CT_CFG.SPP_bit.XFR_SHIFT_EN = 1;'
compiles fine in main_prux.inc, although we haven't got any XIN/XOUTs
yet in the asm so it's untested.

Moving on to hardware for a couple hours here..[47:

Tue Nov 28 16:14:54 2017 Well so on the hardware front the latest
board build is being a real drag.  Guessing some kind of crossed wire
somewhere is pushing current where it's not supposed to be going, with
the result that linux is panicking at various non-reproducible times
during booting or early uptime.  Urgh.  Poking around with the
multimeter, the main power rails seem okay; haven't dragged in the
oscilloscope yet because time.

So what's the next TODO or two here?[48: Tue Nov 28 16:27:28 2017
Well, doing (4.1) -- via our own packets, not sysfs -- would certainly
be a good thing.  It's 9:30AM here in mountain time; let's aim at that
for an hour or so here.  :48]

:47]

:46]
[49:

Tue Nov 28 16:29:54 2017 So, a fill-in-the-blank packet format:

Given outbound
RxxxxFOOBAR

PRU produces

R0123FOOBAR

where '0123' is the contents of R31 in little-endian binary.  The
remainder of the packet is passed back unchanged, and 'caller' can do
whatever they want with it -- use it as a message tag, or not have it,
or whatever.  If the message isn't big enough to fit all of R31, PRU
fills in whatever it can.

[50:

Tue Nov 28 17:52:14 2017 OK, well 'R' seems to be working as
described.  The opening 'HEWO' packet the driver sends now gets
returned as 'HUnk' which took me a second to parse..

But I realize that what we really need now is a way to get packet
responses back to userspace, rather than only to dmesg.  Then we could
do all this stuff via scripts and what-not.

So, this is where we were reading up on kfifos, but never got to
implementation.  We believe we can have a kfifo that preserves
variable-length record structures, with a one byte count per record,
and that's just what we think we want.  We'll have the rpmsg callback
put crap in the kfifo, and we'll have readers block until they can
pull a packet out of the kfifo.

The 'only' issue is that we just hadn't, and still haven't, found any
finite concrete example of that to work from.[51:

Tue Nov 28 18:14:55 2017 OK, well I guess 'record-example.c' from the
kfifo author Stefani Seibold is where we're supposed to start.  I'd
looked at it briefly before but often it's easier to work from
something _not_ written by the actual designer/implementer of a given
pile of code...[52:

Wed Nov 29 07:53:41 2017 OK, so aside from how doh long it took me to
remember/understand that using clever power-of-2 fifo sizes meant that
_I_ had to declare my static kfifo with a power-of-2 size, the kfifo
went in fairly smoothly.  

:52]

:51]

:50]

:49]
[53:

Sun Dec  3 00:46:17 2017 So have been dealing with a paper deadline but
was just playing here.  With only one kfifo, a packet sent to linux by
PRU0 can be read by like 'cat < /dev/itc/pru1', which seems odd.  But
then, we'd kind of prefer to have a single point of packet access for
both PRUs, since mfms in userspace really doesn't care and it would be
easier to just have a single thread blocking on a single device.[54:

Sun Dec  3 00:57:30 2017 But on the other hand, for debugging, stats,
and configuration purposes, we'd like to have easy access to each PRU
independently.

What if we distinguish earlier and harder between ITC packets and
special packets?  And actually have three fucking fifos in the itc_pkt
driver -- one for pru0 specials, one for pru1 specials, and one for
all ITC packets.  Then we have like /dev/itc/pru[01] for special
packets, and perhaps /dev/itc/packets for all ITC packets.  And in
general, userspace/mfmt2 will just have a thread blocking on
/dev/itc/packets, to receive cache updates from anywhere.

Can a char driver with a dynamic major have three minors, but have one
of them be named 'packets' instead of 'pru2'?  I bet so.. didn't I
have to use some formatting interface to get 'pru%d' to begin with?


:54]

:53]
[55:

Wed Dec  6 00:16:23 2017 OK, so I believe we have achieved 4.1.  Let's
call that for now.[57: Wed Dec  6 00:17:23 2017 At least, we're pretty
sure we have seen input pins that were looped back with ribbon cable change
states when we changed other output pins.  We need some runnable code
to deal with actual ITC pin names like ET_TXRDY and so forth, so we
can write scripts to test stuff much more thoroughly.

So where('s the first place we really) do want to embed pin name info?
In the itc_pkt driver?  How?  Lots of names under /dev/itc?  Like

# cat /dev/itc/pin/ET_TXRDY
0
# echo 1 > /dev/itc/pin/ET_TXRDY
# cat /dev/itc/pin/ET_TXRDY
1
# 

or

# cat /dev/itc/pin/ET/TXRDY
0
# echo 1 > /dev/itc/pin/ET/TXRDY
# cat /dev/itc/pin/ET/TXRDY
1
# 

[58:

Wed Dec  6 01:01:02 2017 Maybe that?[59:

Wed Dec  6 08:00:24 2017 Or /dev/itc/dir/ET/TXRDY, to avoid
unbalancing /dev/itc.  Or  /dev/itc/dir/ET/pin/TXRDY so that we could
also expand in dir/ with things like /dev/itc/dir/ET/packet?  But not
for reading, only for writing, since we aren't planning to buffer
inbound packets separately by their source direction.  Or weren't,
anyway..  I suppose we could, though, and then have /dev/itc/packet
use the randomized iterator to scan over the six kfifos looking for
any packet..  Hmm.  If we wanted to support blocking we'd need to put
a wait queue .. [60: Wed Dec  6 08:38:33 2017 So, waiting on multiple
queues in the kernel seems a bit non-trivial.  Let's try to keep it
the simple choice here (KITSCH).

If /dev/itc/dir/ET/packet exists, it will be write-only for now, and
it will just add the appropriate packet header byte for the given
direction, figure out whether that's PRU0 or PRU1, and dish it to
rpmsg.  Shouldn't call it /packet though, if it's not a packet when it
goes in.  ET/payload?  ET/send?  ET/datapacket?  ET/packetbody?

[61:

Wed Dec  6 09:08:00 2017 I have to say it's tempting to want
reasonable direction-based point-to-point comms.

[68:

Wed Dec  6 03:49:03 2017 So that would mean a kfifo per dir, in
addition to the kfifo for the special packets.  And scanning the
packet kfifos on /dev/itc/packet reads.  But then we could have
plausible blocking reads on /dev/itc/dir/ET/packet.

But only a non-blocking read on /dev/itc/packets grr.  Could it be one
extra wait queue for packet level reads?  So whenever we add anything
to any dir kfifo, we wake up two wait queues?  Our own dir plus the
packet level?  And whoever gets it gets it?[69:

Wed Dec  6 04:34:01 2017 Maybe but then we also have to have a mutex
for reading each dir kfifo to arbitrate who actually does get it.
Which is a drag, but then, we already signed up for that the instant
we considered having /dev/itc/packets and /dev/itc/dir/ET/packet --
whether anybody is blocking or not.

So once again, how bad do we really want /dev/itc/dir/ET/packet???

Vs throwing that dispatch up to userspace and dealing with it there.

The reason I was wanting it in kernel was so we could consider
shipping data --- like, say, a new .mfz file -- inter-tile, while
mfmt2 was running and doing cache traffic over the same itc channels.

[70:

Wed Dec  6 04:51:01 2017 Did a little reading about implementing a new
socket type and eventually using like skbuffs and hooking into the
networ klayers.  Maybe someday.  What can we do now to move the ball
while likely foreclosing as little possible of that stuff down the
road?

We basically want UDP-like semantics, with our own address space or
address family or whatever it's called.[71:

Wed Dec  6 07:21:39 2017 Anyway. Anyway damnit this is not
progressing.  First stop, just setting and testing the pins --
/dev/itc/dir/ET/TXRDY etc -- via requests to the PRUs.

:71]

:70]

:69]

:68]

(Hmm, it's also tempting to want fricking MOUNTAIN TIME on MY TILES
instead of UTC..  For those times when we are connected to the net..
Could we quick add a TZ config to our T2-12 repo?)[62:

Wed Dec  6 09:20:18 2017 OK well attempt #1 didn't work:

    root@beaglebone:/home/t2/T2-12# echo 'Etc/Navajo' > /etc/timezone
    root@beaglebone:/home/t2/T2-12# cat /etc/timezone 
    Etc/Navajo
    root@beaglebone:/home/t2/T2-12# dpkg-reconfigure --frontend noninteractive tzdata

    Current default time zone: 'Etc/UTC'
    Local time is now:      Wed Dec  6 09:19:51 UTC 2017.
    Universal Time is now:  Wed Dec  6 09:19:51 UTC 2017.

    root@beaglebone:/home/t2/T2-12# 

[63:

Wed Dec  6 09:21:26 2017 Nor attempt #2:

    root@beaglebone:/home/t2/T2-12# echo 'Etc/MST7MDT' > /etc/timezone
    root@beaglebone:/home/t2/T2-12# cat /etc/timezone 
    Etc/MST7MDT
    root@beaglebone:/home/t2/T2-12# dpkg-reconfigure --frontend noninteractive tzdata

    Current default time zone: 'Etc/UTC'
    Local time is now:      Wed Dec  6 09:21:05 UTC 2017.
    Universal Time is now:  Wed Dec  6 09:21:05 UTC 2017.

    root@beaglebone:/home/t2/T2-12# cat /etc/timezone 
    Etc/UTC
    root@beaglebone:/home/t2/T2-12#

[64:

Wed Dec  6 09:29:56 2017 Nor attempt #3

    root@beaglebone:/home/t2/T2-12# cp /usr/share/zoneinfo/MST7MDT /etc/localtime 
    root@beaglebone:/home/t2/T2-12# dpkg-reconfigure --frontend noninteractive tzdata

    Current default time zone: 'Etc/UTC'
    Local time is now:      Wed Dec  6 09:29:32 UTC 2017.
    Universal Time is now:  Wed Dec  6 09:29:32 UTC 2017.

    root@beaglebone:/home/t2/T2-12# cat /etc/timezone 
    Etc/UTC
    root@beaglebone:/home/t2/T2-12# 

Nor attempt #4

    root@beaglebone:/home/t2/T2-12# cp /usr/share/zoneinfo/MST7MDT /etc/localtime 
    root@beaglebone:/home/t2/T2-12# echo 'Etc/MST7MDT' > /etc/timezone
    root@beaglebone:/home/t2/T2-12# dpkg-reconfigure --frontend noninteractive tzdata

    Current default time zone: 'Etc/UTC'
    Local time is now:      Wed Dec  6 09:30:45 UTC 2017.
    Universal Time is now:  Wed Dec  6 09:30:45 UTC 2017.

    root@beaglebone:/home/t2/T2-12# 

[65:

Wed Dec  6 02:33:53 2017 Enfin.   Attempt #5:

    root@beaglebone:/home/t2/T2-12# ln -fs /usr/share/zoneinfo/MST7MDT /etc/localtime 
    root@beaglebone:/home/t2/T2-12# ls -l /etc/localtime 
    lrwxrwxrwx 1 root root 27 Dec  6 02:33 /etc/localtime -> /usr/share/zoneinfo/MST7MDT
    root@beaglebone:/home/t2/T2-12# rm /etc/timezone 
    root@beaglebone:/home/t2/T2-12# dpkg-reconfigure --frontend noninteractive tzdata

    Current default time zone: 'SystemV/MST7MDT'
    Local time is now:      Wed Dec  6 02:33:45 MST 2017.
    Universal Time is now:  Wed Dec  6 09:33:45 UTC 2017.

    root@beaglebone:/home/t2/T2-12# 

Or maybe I like this better:

    root@beaglebone:/home/t2/T2-12# ln -fs /usr/share/zoneinfo/Navajo /etc/localtime 
    root@beaglebone:/home/t2/T2-12# rm /etc/timezone 
    root@beaglebone:/home/t2/T2-12# dpkg-reconfigure --frontend noninteractive tzdata

    Current default time zone: 'America/Denver'
    Local time is now:      Wed Dec  6 02:35:40 MST 2017.
    Universal Time is now:  Wed Dec  6 09:35:40 UTC 2017.

    root@beaglebone:/home/t2/T2-12# 

since anything SystemV creeps me out.
[66:

Wed Dec  6 03:03:59 2017 OK, well it didn't involve too much yak
shaving, and now we have a new T2-12/pkgconfig directory that
currently just sets the timezone to mountain.[67:

Wed Dec  6 03:07:54 2017 Oh and look at these timestamps now!  So
local!  So right!  T2 tiles come from the mountains!  T2!

:67]

:66]
:65]

:64]

:63]

:62]

:61]

:60] 

:59]

:58]

:57]

:55]
[72:

Sat Dec  9 05:53:27 2017 OK, let's take a few minutes here before
breakfast to see about these attribute groups..  Greg KH says if I
have a class, which I do, I want to be dealing with these guys:

    struct class {
        ...
        struct class_attribute      *class_attrs;
        struct device_attribute     *dev_attrs;
        struct bin_attribute        *dev_bin_attrs;
        ...
    }

So let's look for a couple of believable-looking examples mentioning,
say, "struct class_attribute"..
[73:

Sat Dec  9 05:59:58 2017 Something like this perhaps:

    static struct class_attribute class_attr[] =
    { __ATTR(enable, 0644, enable_show, enable_store), __ATTR_NULL };

    static struct class hello_drv =
    { .name = "Dev_Hello", .owner = THIS_MODULE, .class_attrs =
                    (struct class_attribute *) &class_attr, };
                
plus this


    status = class_register(&hello_drv);
    if (status < 0)
       printk("Registering Class Failed\n");

in the module _init().

from https://github.com/Jeshwanth/Linux_modules_examples/blob/master/sysfs/enable_attr_sysfs.c

[74:

Sat Dec  9 06:01:51 2017 So, __ATTR does the stringification?  We
never write the name of the sysfs entry as a string ourselves?

[75:

Sat Dec  9 06:26:35 2017 Ah, doh,
https://www.kernel.org/doc/Documentation/filesystems/sysfs.txt 

with a device level example:

    #define DEVICE_ATTR(_name, _mode, _show, _store) \
    struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show,
    _store)

    For example, declaring

    static DEVICE_ATTR(foo, S_IWUSR | S_IRUGO, show_foo, store_foo);

    is equivalent to doing:

    static struct device_attribute dev_attr_foo = {
       .attr = {
                 .name = "foo",
                 .mode = S_IWUSR | S_IRUGO,
               },
       .show = show_foo,
       .store = store_foo,
    };
                                      
from which we can learn (1) __ATTR does stringify, but (2) This is not
an attribute _group_ example, which is what we thought we were going
for.. [76:

Sun Dec 10 05:30:03 2017 OK, so, in modern parlance, this:

    TIL the reason I can't google decent answers for my linux kernel
    questions anymore is it's time for me to git clone mainline and
    use git grep and discover I can understand the results.

[77:

Sun Dec 10 05:38:17 2017 We now have a framework for groups of
attributes stuck onto the ->dev_groups of our itc_pkt_class object,
courtesy of drivers/misc/c2port/core.c, and it's time to pick a first
attribute or few to try implementing.[78:

Sun Dec 10 06:14:06 2017 I guess for starters we're going for like
ET_TXRDY as a single attribute, with show and set, and defer ET/TXRDY
until we understand things better.

[79:

Sun Dec 10 12:25:00 2017 OK, so it took forever but we have managed to
get class attributes demoed in itc_pkt.c, living amongst the
previously demoed /dev/itc/pru[01] == /sys/class/itc_pkt/itc!pru[01].
The key at the end appeared to be ditching class_create in favor of
class_register, so we could set up its .class_attrs before registering
it.

A little hard to believe there isn't a way to do it with class_create,
but I haven't found an example of that yet.  And class_create goes to
__class_create which goes to __class_register which goes to
add_class_attrs..  Aaand add_class_attrs appears to be called only
from there:

    linux-stable$ git grep add_class_attrs
    drivers/base/class.c:static int add_class_attrs(struct class *cls)
    drivers/base/class.c:       error = add_class_attrs(class_get(cls));
    linux-stable$ 

so for us it's class_register rather than class_create, I guess.

:79]
:78]

:77]

:76]

:75]

:74]

:73]
:72]
