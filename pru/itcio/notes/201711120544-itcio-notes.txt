{291}  -*- text -*-
[0:

Sun Nov 12 12:54:47 2017 Yay we finally have 'go.el' on the tiles!  Or
at least the subset of go.el that we actually use..

[1:

Sun Nov 12 12:55:31 2017 So, we're here to have a place to discuss all
the issues of talking packets back and forth between the PRUs and
kernelspace and userspace.

Of course we're way in the middle of things here.  One current issue
is: Do we need a custom LKM for this at all, or could we just use some
existing thing that presents RPMsg IO to userspace?  We've seen claims
that some demo or some kind of module will create devices like
/dev/rpmsg_pru30 that we could theoretically write and read packets
from.  But so far we haven't managed to demonstrate that.[2:

Sun Nov 12 14:19:43 2017 It seems perhaps like we need the 'correct'
crap on the PRU side for the LKM side 'probe' to create the devices.
There's these comments in PRU code like:

/*
 * Using the name 'rpmsg-client-sample' will probe the RPMsg sample driver
 * found at linux-x.y.z/samples/rpmsg/rpmsg_client_sample.c
 *
 * Using the name 'rpmsg-pru' will probe the rpmsg_pru driver found
 * at linux-x.y.z/drivers/rpmsg/rpmsg_pru.c
 */

so if my current demo fws aren't using the right sort of names..
..what name is my current demo using?[3:

Sun Nov 12 14:23:18 2017 Well, I guess it's using

    /*
     * Using the name 'rpmsg-pru-itcio' will probe the rpmsg_pru driver found
     * at linux-x.y.z/drivers/rpmsg/rpmsg_pru_itcio.c
     */
    #define CHAN_NAME					"rpmsg-pru-itcio"
    #define CHAN_DESC					"Channel 31"
    #define CHAN_PORT					31

according to pru/itcio/firmware/main_pru1.c[4:

Sun Nov 12 14:49:01 2017 Well it seems more the other way around.  I
copied the modules_install stuff from lkms/itc/Makefile, and after
running that, it seems that 'modprobe rpmsg_pru_itcio' boots the PRU:

    root@beaglebone:/home/t2/T2-12/pru/itcio/firmware# modprobe rpmsg_pru_itcio
    Nov 12 14:48:34 beaglebone kernel: [52236.139924]  remoteproc2: powering up 4a338000.pru1
    Nov 12 14:48:34 beaglebone kernel: [52236.169561]  remoteproc2: Booting fw image am335x-pru1-fw, size 71100
    Nov 12 14:48:34 beaglebone kernel: [52236.196808] ti-pruss 4a300000.pruss: configured system_events = 0x00000000000c0000 intr_channels = 0x0000000a host_intr = 0x0000000a
    Nov 12 14:48:34 beaglebone kernel: [52236.251818]  remoteproc2: remote processor 4a338000.pru1 is now up
    Nov 12 14:48:34 beaglebone kernel: [52236.277011] virtio_rpmsg_bus virtio0: rpmsg host is online
    Nov 12 14:48:34 beaglebone kernel: [52236.282695] virtio_rpmsg_bus virtio0: creating channel rpmsg-pru-itcio addr 0x1f
    Nov 12 14:48:34 beaglebone kernel: [52236.316205] rpmsg_pru_itcio rpmsg0: chnl: 0x400 -> 0x1f
    Nov 12 14:48:34 beaglebone kernel: [52236.346715] rpmsg_pru_itcio rpmsg0: pru_itcio device ready at /dev/rpmsg_pru_itcio
    root@beaglebone:/home/t2/T2-12/pru/itcio/firmware#

Committing this as a checkpoint, adding rpmsg_pru_itcio to my
/etc/modules stuff, and trying a reboot..

:4]

:3]

:2]

:1]

:0]
[5:

Sun Nov 12 17:01:34 2017 OK, so it's gross and we're doing it by hand
in t2-startup.sh, but we have a functioning /dev/rpmsg_pru_itcio
getting created at boot.  Now we 'just' have to make it useful.

The current hard part is doing something sensible on the read side.
I think we're going to try to find some kfifo sample code and buffer
the incoming rpmsg packets there, and have the read side draw from the
kfifo.  First question: Does a kfifo work in blocks or bytes?  In
other words, are we going to lose our rpmsg packet boundaries going in
and out of a kfifo?  Is a kfifo a linked list of blocks or a circular
byte array??[6:

Sun Nov 12 17:31:00 2017 Not completely clear but sort of looking like
kfifo is byte-oriented, despite some stuff talking about 'records'.

Q: Could we just leave stuff in the rpmsg queue until userspace comes
along to read it?  The queue would fill fast but we're expecting mfmt2
to basically have a thread sitting on the read side, pulling packets
to userspace for dishing off.  Or maybe it's polling during events and
stuff, advancing communications.

But we can't really ignore the rpmsg callback, because it's up to us
to get rid of data[len] at that point; rpmsg is going to assume we
did.  So we could make our own linked list of packets, using the
kernel's linked list stuff rather than the kfifo.[7:

Sun Nov 12 18:07:24 2017 Or we could use skb's from the network
stack??  That seems like a huge kettle of fish, but then we could
conceivably be routing more or less genuine network crap between
tiles, for good and for ill..

:7]

:6]

:5]
[8:

Tue Nov 14 18:12:42 2017 OK, pushing all this crap as a checkpoint.
Renamed the module to itc_pkt and made its device be /dev/itc/packets,
to be a sibling of /dev/itc/locks.  Probably should be /dev/t2/*, but
deal with that later.

:8][9:

Thu Nov 16 22:36:46 2017 All right; we lost a couple of days to
stuff, but here we are again.  What about those skb's?  Any chance
they're at all general purpose?[10:

Thu Nov 16 22:44:01 2017 Well, it looks mostly byte-oriented too, but
with special support for packet heads and tails.  So at that point it
seems we might just as well use a kfifo but enforce the discipline
that we grow and shrink it by units of packets, and we use our own
packet framing discipline to know where the packet boundaries are
starting from the current head of the kfifo.

At least, let's take that provisionally and see where it gets us.

Let's review our packet semantics document from way back when -- when
we were thinking an FPGA for comms -- and see how much we still might
like it.[11:

Thu Nov 16 23:08:13 2017 OK, the file is MFMPFD11.txt, now copied but
not commited in T2-12/doc.

It's calling for a two byte header on a 255 max packet size, with the
data alleged to be byte-escaped to eliminate nulls, but no actual data
format is included in MFMPFD11.[12:

Thu Nov 16 23:46:04 2017 And hmm indeed, it looks like kfifo (at least
in 2009) explicitly supports variable-length records between 0 and 255
bytes..  Except I think it wants the length in the first byte rather
than the second; dunno.[13:

Thu Nov 16 23:55:56 2017 What if we took that to heart?  In principle
I like having the length first anyway.. we were toying with having the
start-of-byte be an extra 1 bit before the first packet byte, in which
case we could have a whole first byte for length if we wanted it..  If
you send 15 or more straight 0s then the channel goes idle, and at
that point the first 1 bit to arrive is a byte-alignment start bit
rather than a data bit.  But you send packets back-to-back if you have
them, and the byte sync just carries over.

Now one thing is we do have to keep clocking _all_ the live channels
all the time -- even if some of them are 'idle' -- so that either side
can start a packet any time it wants.  But once the channels are
logically idle we won't be generating bytes for inbound packets.
[14:

Fri Nov 17 00:11:54 2017 Now, we really could do bit or byte stuffing
on the wire, with a privileged packet delimiter, but then convert them
to counted packets before sending them to linux.  Or maybe we can just
count on the rpmsg framing to imply the count?  Or not, because we
might have a lot of short packets which could burn a lot of rpmsg
buffers, when memory is not that cheap down toward the PRU end of
things?

But in any case we would say the beginning of an rpmsg is always the
beginning of a packet?  But then could we dare to put multiple packets
in one buffer?  I suppose as long as there's more than max packet len
bytes still in the rpmsg buffer we could keep going.  But that would
tend to increase latency.. Who knows..

[15:

Fri Nov 17 00:49:00 2017 Pop pop pop..  So, status:

(1) We're going to try using a kfifo in its recsize==1 mode

(2) We're going to do bit stuffing on the wire with a reserved
    end-of-packet / start-of-packet sequence.

(3) We're going to unstuff the bits and assemble bytes in PRU memory
    while tracking the len and updating the packet status.

(4) Our PRU code will have a single incoming and a single outgoing
    packet buffer for each direction (so, three in and three out per
    PRU, six in and six out overall).

(5) Our PRU main loop will just continually advance the wire bit state
    machines for each direction, and those state machines will report
    conditions like 'incoming packet complete' and 'outgoing packet
    buffer empty', and in response the PRU main loop will service them
    appropriately, calling pru_rpmsg_send in the former case and/or
    pru_rpmsg_receive in the latter.  If there's no more rpmsg buffers
    available for sending data to linux, we mark the packet blown and
    start discarding until another start-of-packet.  If there's no
    more rpmsg buffers available containing data from linux, the
    corresponding output channel goes idle.

'And that's all there is to it.'  Yahright.[16:

Fri Nov 17 01:30:44 2017 And we're still thinking the wire bit state
machines are written in assembler, using the context-switching design
previously worked up.. but we're not sure how that's going to
interface to the the main loop, which we are thinking is going to be
C.

Now, I don't think we actually ate all the registers in our state
machine design.  Could we try to see if there's a way to get along
with the clpru usages?[17:

Fri Nov 17 09:36:55 2017 All right, so it's all about 'spruhv7a.pdf',
the 'PRU Optimizing Compiler C/C++ Compiler v2.1 (Rev. A)' manual.
[19:

Fri Nov 17 09:41:45 2017 And the key table for register usage appears
to be Table 6-4 on page 105-106:

   Table 6-4. Register Usage
    Register  Usage                   Save on Call    Save on Entry
     R0.w0     Expression register     Yes
     R1        Expression register     Yes
     R2        Stack pointer (SP)
     R3.w0     Expression register
     R3.w2     Expression register                     Yes
                (usually used as Link
                register to store the
                return address)
     R4        Argument pointer (AP)                   Yes
     R5        Expression register                     Yes
     R6        Expression register                     Yes
     R7        Expression register                     Yes
     R8        Expression register                     Yes
     R9        Expression register                     Yes
     R10       Expression register                     Yes
     R11       Expression register                     Yes
     R12       Expression register                     Yes
     R13       Expression register                     Yes
     R14       Return register         Yes
     R15       Expression register     Yes
     R16       Expression register     Yes
     R17       Expression register     Yes
     R18       Expression register     Yes
     R19       Expression register     Yes
     R20       Expression register     Yes
     R21       Expression register     Yes
     R22       Expression register     Yes
     R23       Expression register     Yes
     R24       Expression register     Yes
     R25       Expression register     Yes
     R26       Expression register     Yes
     R27       Expression register     Yes
     R28       Expression register     Yes
     R29       Expression register     Yes
     R30       Control register
     R31       Control register

[20:

Fri Nov 17 10:13:17 2017 Aand how does that fit together with what we
were imagining in a pure ASM environment?  From
T2-local/candidates/beagleboardgreen/BBG-SHR/SymmetricBitstreamTransceiver.inc:

    /*
       PRUx REGISTER USAGE

       R0 : reserved for context switching
       R1 : arg ret + tmp
       R2-6 : temp caller saves
       R7-9 : temp callee saves
       R10-17 : context register (see below)
       R18-29 : reserved
       R30 : direct GPIO output
       R31 : status and direct GPIO input
    */


and I think everything but R30 and R31 are actually movable.  In
particular, the 8 register context struct just has to be contiguous
but can otherwise go anywhere.

But if the main loop is, in effect, the context-switching threaded
state machines, that means we will need to be calling C from ASM, not
(just) the reverse.

[21:

Fri Nov 17 11:01:39 2017 So I don't know if I have the strength for it
now, but it seems one good workflow spike would be to write an ASM
main loop that does the processing currently in main_pru1.c.
Something like:

//C

struct pru_rpmsg_transport transport;

unsigned getOutboundPacket(uint8_t * buffer) {
   unsigned len;
   if (pru_rpmsg_receive(&transport, &src, &dst, buffer, &len) != PRU_RPMSG_SUCCESS)
     return 0;
   return len;
}
void putInboundPacket(uint8_t * buffer, unsigned len)
{
   pru_rpmsg_send(&transport, dst, src, buffer, len);
}

int main() {
   uint16_t src, dst, len;

   /* allow OCP master port access by the PRU so the PRU can read external memories */
   CT_CFG.SYSCFG_bit.STANDBY_INIT = 0;

   /* clear the status of the PRU-ICSS system event that the ARM will use to 'kick' us */
   CT_INTC.SICR_bit.STS_CLR_IDX = FROM_ARM_HOST;

   /* Make sure the Linux drivers are ready for RPMsg communication */
   status = &resourceTable.rpmsg_vdev.status;
   while (!(*status & VIRTIO_CONFIG_S_DRIVER_OK));

   /* Initialize pru_virtqueue corresponding to vring0 (PRU to ARM Host direction) */
   pru_virtqueue_init(&transport.virtqueue0, &resourceTable.rpmsg_vring0, TO_ARM_HOST, FROM_ARM_HOST);

   /* Initialize pru_virtqueue corresponding to vring1 (ARM Host to PRU direction) */
   pru_virtqueue_init(&transport.virtqueue1, &resourceTable.rpmsg_vring1, TO_ARM_HOST, FROM_ARM_HOST);

   /* Create the RPMsg channel between the PRU and ARM user space using the transport structure. */
   while (pru_rpmsg_channel(RPMSG_NS_CREATE, &transport, CHAN_NAME, CHAN_DESC, CHAN_PORT) != PRU_RPMSG_SUCCESS);

   mainLoop(&transport);
}

;ASM
.whatever mainLoop
    ;; R14 is ptr to transport
    blah
    blah
    ;; call getOutboundPacket for more data to send
    blah
    ;; call putInboundPacket for push received data to linux

:21]

:20]
:19]

:17]

:16]


:15]

:14]


:13]

:12]

:11]


:10]

:9]
[18: Fri Nov 17 09:39:47 2017 Hmm using the go macros makes it much
more obvious this T2 tile is running on GMT.  Confusing.  It's 2:40AM
here in Mountain Time.  :18]
[22:

Fri Nov 24 07:28:52 2017 OK godamn it

(1) Demo C code running on two PRUs talking to linux
(2) Demo C calling an ASM routine and it returning something
(3) Demo that ASM routine calling another C routine.

[23:

Fri Nov 24 07:30:44 2017 How to push toward (1)?  Let's try to get our
itcio LKM to support two minor devices.  That hadn't seemed hopeless
last time we worked, IIRC.

:23]

:22]
[24:

Fri Nov 24 10:28:47 2017 Useful info from http://theduchy.ualr.edu/?p=996

    The structure of communications using INTC can be seen in the
    Technical Reference Manual, Table 4-17.

    PRU0 is connected to Host-0 using R31 bit 30.

    PRU1 is connected to Host-1 using R31 bit 31.

    System events (SYS_EVT) are connected to one of the ten channels
    (0..9).  This channel connection is done through the resource table.

    Table 4-21 demonstrates the Interrupt number and connection to a
    pin. Pins 16, 17, 18, and 19 are connected to signals
    pr1_pru_mst_intr[0]_intr_req, pr1_pru_mst_intr[1]_intr_req,
    pr1_pru_mst_intr[2]_intr_req,  and pr1_pru_mst_intr[3]_intr_req.

:24]
[25:

Fri Nov 24 11:37:35 2017 OK, well, after just the right amount of pain
and suffering, apparently, I now have both pru0 and pru1 up and
running the minimal packet demo code, as /dev/itc/packets0 and
/dev/itc/packets1, respectively.

Finally.

Thinking of renaming to /dev/itc/pru0 etc but uncertain if my current
flow guarantees that pru0 will always get minor 0.

In any case, pushing all this.

:25]
[26:

Fri Nov 24 12:32:42 2017 So it was possible for pru1 to get minor 0
and vv, but I've now rehacked to not use idr_alloc for minors and
instead use (rpmsg->dest - 30), which appears to do what we want.

Renaming to /dev/itc/pru[01].


:26]
[27:

Fri Nov 24 15:00:28 2017 OK, so boot time stuff remains messed up --
with some indications on the net that RCN was making changes in
related stuff in mid-2017, so whatever.  We're now just rebinding the
pru stuff in our own boot script.

:27]
[28:

Fri Nov 24 20:31:54 2017 OK, so it appears we're sometimes losing
ARM->PRU interrupts destined for PRU0.  I am perfectly willing to
believe whatever the reason is it's my lack of knowledge, and
consequent incorrect configuration/coding, that's to blame.

In any case, rather than continue down that debugging hole at present,
instead we have enabled the PRU instruction cycle counters, and have
added a backup 1HZ timeout for incoming messages: If it's been more
than 200M cycles since the last ARM->PRU interrupt, we go ahead and
check for messages (and reset the timeout clock) anyway.[29:

Fri Nov 24 21:53:23 2017 And the threat of timeout appears to be
sufficient to keep the interrupts arriving, across reboot reloads and
what-not -- at least, I'm seeing pretty regular ~5ms RTT for the
current setup (with lots of kernel logging and all and etc), without
any ~500ms outliers one might expect if the timeout was kicking in.

Committing all this.  Time to push on to case (2) from :22: above.

:29]

:28]
[30:

Fri Nov 24 22:24:31 2017 Summarizing register usage:


 r2 contains the stack pointer,
 r3 contains the return address,
 r14 to r29 are used for argument passing,
 r14 is used for the return value,
 r3 to r13 must be saved by the callee.

(from https://www.embeddedrelated.com/showarticle/603.php)

:30]
[31:

Sat Nov 25 13:58:23 2017 OK, well, so after all sorts of worthless and
worthwhile diversions, we finally appear to qualify for having done
(2) from :22: above.  Here's us calling an asm routine from C:

    ..
    extern int addfuncasm(int a, int b);
    ..
            payload[0]++; /* But increment the first byte to show we care */
            payload[0] = addfuncasm(payload[0]+1, ON_PRU); /* add extra increments via asm */
    ..

and here's the function:

            .global addfuncasm
    addfuncasm:
            ADD R14, R15, R14
            JMP r3.w2

and here's the behavior:

    root@beaglebone:/home/t2/T2-12/pru/itcio# echo aaa > /dev/itc/pru1
    Nov 25 13:58:04 beaglebone kernel: [  875.954349] itc_pkt itc!pru1: Write count 4 / max 496
    Nov 25 13:58:04 beaglebone kernel: [  875.968757] itc_pkt itc!pru1: Sending 4 starting with a
    Nov 25 13:58:04 beaglebone kernel: [  875.974292] Received 4
    Nov 25 13:58:04 beaglebone kernel: [  875.976667] pkt:64 61 61 0a                                      daa.
    root@beaglebone:/home/t2/T2-12/pru/itcio# echo aaa > /dev/itc/pru0
    Nov 25 13:58:08 beaglebone kernel: [  879.922753] itc_pkt itc!pru0: Write count 4 / max 496
    Nov 25 13:58:08 beaglebone kernel: [  879.937989] itc_pkt itc!pru0: Sending 4 starting with a
    Nov 25 13:58:08 beaglebone kernel: [  879.943529] Received 4
    Nov 25 13:58:08 beaglebone kernel: [  879.945947] pkt:63 61 61 0a                                      caa.
    root@beaglebone:/home/t2/T2-12/pru/itcio#

So there's that.

Moving on to (3).  Would like to jump the ambition a little and have
our C function called from asm generate an rpmsg_send of a variable or
something.  We'll see.
[32:

Sat Nov 25 18:44:13 2017 Well, now have a SENDVAL macro that takes a
string and a register and sends a message to linux containing same,
and we're calling it from asm.

Committing.

:32]
:31]
[33:

Sun Nov 26 06:43:56 2017 OK, so a good next step would be the ability
to read and set the PRU-controlled pins.  That will let us answer the
following still-outstanding 'fourth round' questions:

[56: DONE  :56](4.1) Can we really read and write the ITC pins via the PRUs?

[117: DONE  :117](4.2) Can we really control ALL the relevant pins, including the ones
   with contested lines and the ones we stole from other low-level
   functions like the cape I2C?

[119: DONE (enough for now)  :119](4.3) Do the signals appear reliable at essentially DC clocking rates?

while leaving open the big money Fifth Round Questions:

(5.1) Can we implement the SBST state machines and have them actually
   work, in a time period like, say, this semester?

(5.2) Can we actually send a packet across tiles from linux to linux via
   the PRUs and the external connectors?

while not approaching or forgetting the Final Round Questions:

(6.1) Will our signal integrity start to break down, at speeds our
   initial code will be able to achieve?  Or In Other Words

(6.2) HOW FUCKING FAST WILL ALL THIS GO IN ACTUAL REALITY?


:33]
[34:

Sun Nov 26 07:02:59 2017 So, for (4.1), we want some simple command
and respond format between itc_pkt and the PRUs.  We're already
planning/using the following packet design decisions:

 - First byte is packet type.

 - Any packet type with its high-order bit set is an intertile data
   packet (inbound or outbound depending on direction).  The remaining
   seven bits of a data packet type will not be locked down until we
   get there but are likely to include 3 bits of src/dst, an overrun
   bit, and an error bit.

 - Any packet type with its high-order bit clear is a special command,
   with semantics that depend pretty utterly on the packet type.

 - Special packet type 'V' (inbound) is now already defined to be a
   "debug print 'V'alue" going from PRU to linux.  ('V' outbound is
   currently undefined.)

And now we're going to lay down a couple more special packet types.

 - 'R' (outbound) shall mean 'Read R31 and report its current value here'

 - 'R' (inbound) shall mean 'You asked for R31 and here it is'

 - 'W' (outbound) shall mean 'Write R30 with these bits'

 - 'W' (inbound) shall mean 'I wrote these bits to R30'.

We're thinking we might use a fill-in-the-blank style packet format
here, which could give us some nice properties like flexibility and
cheapness.  Specifically, suppose 'R' (outbound) -- let's call it
R/out -- worked like this:

  'R'

[35:

Sun Nov 26 07:43:02 2017 Holy crap look at this:

    root@beaglebone:/sys/kernel/debug/remoteproc# ls remoteproc1
    name  recovery	regs  single_step  state  version
    root@beaglebone:/sys/kernel/debug/remoteproc# cat remoteproc1/regs
    ============== Control Registers ==============
    CTRL      := 0x0000800b
    STS (PC)  := 0x0000003a (0x000000e8)
    WAKEUP_EN := 0x00000000
    CYCLE     := 0x0af1df26
    STALL     := 0x03489034
    CTBIR0    := 0x00000000
    CTBIR1    := 0x00000000
    CTPPR0    := 0x00000100
    CTPPR1    := 0x00000000
    =============== Debug Registers ===============
    PRU is executing, cannot print/access debug registers.
    root@beaglebone:/sys/kernel/debug/remoteproc#

Which is coming to us care of Zeek the beaglescope guy's blog entry at
https://www.zeekhuge.me/post/ptp_docs_commands_and_tools/

Although watch out -- things are not quite all as they seem at first:

    root@beaglebone:/sys/kernel/debug/remoteproc# cat remoteproc0/regs
    cat: remoteproc0/regs: No such file or directory
    root@beaglebone:/sys/kernel/debug/remoteproc#

whaduh?

    root@beaglebone:/sys/kernel/debug/remoteproc# cat remoteproc0/name
    wkup_m3

oh yeah, the little Cortex-M3 in there doing power management..

    root@beaglebone:/sys/kernel/debug/remoteproc# cat remoteproc1/name
    4a338000.pru1
    root@beaglebone:/sys/kernel/debug/remoteproc# cat remoteproc2/name
    4a334000.pru0

[36:

Sun Nov 26 07:47:44 2017 And furthermore, look at fricken this:

    root@beaglebone:/sys/kernel/debug/remoteproc# echo 1 > remoteproc1/single_step
    root@beaglebone:/sys/kernel/debug/remoteproc# cat remoteproc1/regs
    ============== Control Registers ==============
    CTRL      := 0x00000109
    STS (PC)  := 0x0000003b (0x000000ec)
    WAKEUP_EN := 0x00000000
    CYCLE     := 0x00118b01
    STALL     := 0x000543a4
    CTBIR0    := 0x00000000
    CTBIR1    := 0x00000000
    CTPPR0    := 0x00000100
    CTPPR1    := 0x00000000
    =============== Debug Registers ===============
    GPREG0  := 0x0bebc200	CT_REG0  := 0x00020000
    GPREG1  := 0x00118aff	CT_REG1  := 0x48040000
    GPREG2  := 0x000005dc	CT_REG2  := 0x4802a000
    GPREG3  := 0x0037bc06	CT_REG3  := 0x00030000
    GPREG4  := 0x00024000	CT_REG4  := 0x00026000
    GPREG5  := 0x00020024	CT_REG5  := 0x48060000
    GPREG6  := 0x000006d0	CT_REG6  := 0x48030000
    GPREG7  := 0x00000200	CT_REG7  := 0x00028000
    GPREG8  := 0x00000000	CT_REG8  := 0x46000000
    GPREG9  := 0x000006d8	CT_REG9  := 0x4a100000
    GPREG10 := 0x9c65dfd5	CT_REG10 := 0x48318000
    GPREG11 := 0x00000000	CT_REG11 := 0x48022000
    GPREG12 := 0xcd077786	CT_REG12 := 0x48024000
    GPREG13 := 0x3fbcf516	CT_REG13 := 0x48310000
    GPREG14 := 0x0000ffff	CT_REG14 := 0x481cc000
    GPREG15 := 0x000005c0	CT_REG15 := 0x481d0000
    GPREG16 := 0x000005bc	CT_REG16 := 0x481a0000
    GPREG17 := 0x00000001	CT_REG17 := 0x4819c000
    GPREG18 := 0x000005dc	CT_REG18 := 0x48300000
    GPREG19 := 0x00000200	CT_REG19 := 0x48302000
    GPREG20 := 0x00040002	CT_REG20 := 0x48304000
    GPREG21 := 0x20747372	CT_REG21 := 0x00032400
    GPREG22 := 0x72616863	CT_REG22 := 0x480c8000
    GPREG23 := 0x206f7420	CT_REG23 := 0x480ca000
    GPREG24 := 0x646e6573	CT_REG24 := 0x00000000
    GPREG25 := 0x206f7420	CT_REG25 := 0x00002000
    GPREG26 := 0x20656874	CT_REG26 := 0x0002e000
    GPREG27 := 0x6e6f6f6d	CT_REG27 := 0x00032000
    GPREG28 := 0x696c6120	CT_REG28 := 0x00010000
    GPREG29 := 0x00006563	CT_REG29 := 0x49000000
    GPREG30 := 0x00000ff0	CT_REG30 := 0x40000000
    GPREG31 := 0x00000020	CT_REG31 := 0x80000000
    root@beaglebone:/sys/kernel/debug/remoteproc# echo 0 > remoteproc1/single_step

So we can actually put the PRUs into single-step mode, read their
registers (including R30/R31, looks like), and then put it back in
continuous-run mode, all from the comfort of sysfs.  (The second
column is the contents of the constants table, which could be useful
too.)[37:

Sun Nov 26 07:53:30 2017 It also appears that echoing 1 to single_step,
while it is already in single-step mode, causes the targeted PRU to do
one more instruction and then stop again.  So who's written us a GDB
interface to the effen PRUs??

[38:

Sun Nov 26 07:56:23 2017 Also also, 'dmesg -Hw' appears to be like
'tail -f /var/log/messages', except at the dmesg level.  It doesn't
report 'logger' commands, but I bet it doesn't get log-rotated at
night either..

:38]

:37]

So 'we don't actually need' my 'R' packet, in that sense.  Although as
far as I can tell we might still need 'W' -- [39:

Sun Nov 26 09:20:55 2017 No, looks like we have pretty full
debug-style control if we want it, via memory-mapped addresses.  But
that's not really the whole point anyway, and 'nearly full-speed'
printf debugging isn't the same as clunkachunk breakpoint debugging
for better and for worse.
[40:

Sun Nov 26 09:29:29 2017 There's lots of good stuff in SPRUHF8A.. wish
I'd found it earlier but anyway.

In particular, section 4 table 7 figure 3 page 21 seems to suggest
that at least some of the PRU pins have to have additional
PRU-internal MUX settings, on top of the stuff the device tree is
doing.  Like to get at pr1_pru1_pru_r31[11:8], for example, we need to
set 'pin_mux_sel[0] = 1', however that is done..
[41:

Sun Nov 26 09:56:45 2017 Well, still reading SPRUHF8A, but it's time
well-spent now, I feel.  Reminder that R0.b0 is used to specify a
register shift in XIN and XOUT instructions, which we are planning to
use for our state machine context switching.  Note also that it seems
we have to use different 'device id's for scratch pad destinations on
PRU0 and PRU1.  Device 10 is bank 0, which is nominally meant for PRU,
and device 11 is bank 1 likewise for PRU1.  So we'll apparently need

  XOUT (10+PRU), R4, sizeof(mycontext)

instructions or the like.

Also, XFR register shifting needs to be enabled via the 'SPP register
of the PRU-ICSS CFG register space'.[42:

Sun Nov 26 19:39:13 2017 Which we find in Section 10.1.13 page 288 of
SPRUHF8A.  According to 10.1 page 272, SPP is at +0x40 relative to the
PRU_ICSS_CFG base address, which is at 0x0002_6000 in the PRU local
memory map, according to Section 3.1.2 page 19.[43:

Sun Nov 26 19:46:44 2017 And we have a linker symbol defined for that
address:

	PRU_CFG			: org = 0x00026000 len = 0x00000044	CREGISTER=4

in AM335x_PRU.cmd.[44:

Sun Nov 26 19:49:30 2017 Aand we have definitions for the CFG
registers in T2-12/pru/include/am335x/pru_cfg.h, which has stuff like:

	/* PRU_CFG_SPP register bit field */
	union {
		volatile uint32_t SPP;

		volatile struct {
			unsigned PRU1_PAD_HP_EN : 1;	// 0
			unsigned XFR_SHIFT_EN : 1;	// 1
			unsigned rsvd2 : 30;		// 31:2
		} SPP_bit;
	};	// 0x34

and

	union {
		volatile uint32_t PIN_MX;

		volatile struct {
			unsigned PIN_MUX_SEL : 8;	// 7:0
			unsigned rsvd2 : 24;		// 31:8
		} PIN_MX_bit;
	};	//0x40

inside the 'pruCfg' struct.  Plus a declaration of CT_CFG to be a
constant table near pointer to all that stuff.  So, something like

CT_CFG.SPP_bit.XFR_SHIFT_EN = 1;

'should' suffice to turn on the XFR register shifting we need, and

CT_CFG.PIN_MX_bit.PIN_MUX_SEL = 1;

[45: Sun Nov 26 20:09:50 2017 Except it actually looks like we don't
have to screw with that anyway.  It looks like the default,
CT_CFG.PIN_MX_bit.PIN_MUX_SEL = 10, does what we want, mapping
prus-to-prus in the obvious way in and out.  It looks like the
alternate values -- .PIN_MUX_SEL == 1, 2, or 3 -- are for remapping
stuff or providing stuff in multiple places.  Figures 3 and 4, pp 21
and 22, both show 'bypass' connections for 'pruish' external names
mapping to corresponding pruish internal names, regardless of the
value of PIN_MUX_SEL.

So I think that one's a false alarm.  But the

  CT_CFG.SPP_bit.XFR_SHIFT_EN = 1;

thing I'm fairly confident we will need.

:45]

:44]

:43]
:42]

:41]

:40]

:39]

:36]

:35]

:34]
[46:

Sun Nov 26 20:20:00 2017 And 'CT_CFG.SPP_bit.XFR_SHIFT_EN = 1;'
compiles fine in main_prux.inc, although we haven't got any XIN/XOUTs
yet in the asm so it's untested.

Moving on to hardware for a couple hours here..[47:

Tue Nov 28 16:14:54 2017 Well so on the hardware front the latest
board build is being a real drag.  Guessing some kind of crossed wire
somewhere is pushing current where it's not supposed to be going, with
the result that linux is panicking at various non-reproducible times
during booting or early uptime.  Urgh.  Poking around with the
multimeter, the main power rails seem okay; haven't dragged in the
oscilloscope yet because time.

So what's the next TODO or two here?[48: Tue Nov 28 16:27:28 2017
Well, doing (4.1) -- via our own packets, not sysfs -- would certainly
be a good thing.  It's 9:30AM here in mountain time; let's aim at that
for an hour or so here.  :48]

:47]

:46]
[49:

Tue Nov 28 16:29:54 2017 So, a fill-in-the-blank packet format:

Given outbound
RxxxxFOOBAR

PRU produces

R0123FOOBAR

where '0123' is the contents of R31 in little-endian binary.  The
remainder of the packet is passed back unchanged, and 'caller' can do
whatever they want with it -- use it as a message tag, or not have it,
or whatever.  If the message isn't big enough to fit all of R31, PRU
fills in whatever it can.

[50:

Tue Nov 28 17:52:14 2017 OK, well 'R' seems to be working as
described.  The opening 'HEWO' packet the driver sends now gets
returned as 'HUnk' which took me a second to parse..

But I realize that what we really need now is a way to get packet
responses back to userspace, rather than only to dmesg.  Then we could
do all this stuff via scripts and what-not.

So, this is where we were reading up on kfifos, but never got to
implementation.  We believe we can have a kfifo that preserves
variable-length record structures, with a one byte count per record,
and that's just what we think we want.  We'll have the rpmsg callback
put crap in the kfifo, and we'll have readers block until they can
pull a packet out of the kfifo.

The 'only' issue is that we just hadn't, and still haven't, found any
finite concrete example of that to work from.[51:

Tue Nov 28 18:14:55 2017 OK, well I guess 'record-example.c' from the
kfifo author Stefani Seibold is where we're supposed to start.  I'd
looked at it briefly before but often it's easier to work from
something _not_ written by the actual designer/implementer of a given
pile of code...[52:

Wed Nov 29 07:53:41 2017 OK, so aside from how doh long it took me to
remember/understand that using clever power-of-2 fifo sizes meant that
_I_ had to declare my static kfifo with a power-of-2 size, the kfifo
went in fairly smoothly.

:52]

:51]

:50]

:49]
[53:

Sun Dec  3 00:46:17 2017 So have been dealing with a paper deadline but
was just playing here.  With only one kfifo, a packet sent to linux by
PRU0 can be read by like 'cat < /dev/itc/pru1', which seems odd.  But
then, we'd kind of prefer to have a single point of packet access for
both PRUs, since mfms in userspace really doesn't care and it would be
easier to just have a single thread blocking on a single device.[54:

Sun Dec  3 00:57:30 2017 But on the other hand, for debugging, stats,
and configuration purposes, we'd like to have easy access to each PRU
independently.

What if we distinguish earlier and harder between ITC packets and
special packets?  And actually have three fucking fifos in the itc_pkt
driver -- one for pru0 specials, one for pru1 specials, and one for
all ITC packets.  Then we have like /dev/itc/pru[01] for special
packets, and perhaps /dev/itc/packets for all ITC packets.  And in
general, userspace/mfmt2 will just have a thread blocking on
/dev/itc/packets, to receive cache updates from anywhere.

Can a char driver with a dynamic major have three minors, but have one
of them be named 'packets' instead of 'pru2'?  I bet so.. didn't I
have to use some formatting interface to get 'pru%d' to begin with?


:54]

:53]
[55:

Wed Dec  6 00:16:23 2017 OK, so I believe we have achieved 4.1.  Let's
call that for now.[57: Wed Dec  6 00:17:23 2017 At least, we're pretty
sure we have seen input pins that were looped back with ribbon cable change
states when we changed other output pins.  We need some runnable code
to deal with actual ITC pin names like ET_TXRDY and so forth, so we
can write scripts to test stuff much more thoroughly.

So where('s the first place we really) do want to embed pin name info?
In the itc_pkt driver?  How?  Lots of names under /dev/itc?  Like

# cat /dev/itc/pin/ET_TXRDY
0
# echo 1 > /dev/itc/pin/ET_TXRDY
# cat /dev/itc/pin/ET_TXRDY
1
#

or

# cat /dev/itc/pin/ET/TXRDY
0
# echo 1 > /dev/itc/pin/ET/TXRDY
# cat /dev/itc/pin/ET/TXRDY
1
#

[58:

Wed Dec  6 01:01:02 2017 Maybe that?[59:

Wed Dec  6 08:00:24 2017 Or /dev/itc/dir/ET/TXRDY, to avoid
unbalancing /dev/itc.  Or  /dev/itc/dir/ET/pin/TXRDY so that we could
also expand in dir/ with things like /dev/itc/dir/ET/packet?  But not
for reading, only for writing, since we aren't planning to buffer
inbound packets separately by their source direction.  Or weren't,
anyway..  I suppose we could, though, and then have /dev/itc/packet
use the randomized iterator to scan over the six kfifos looking for
any packet..  Hmm.  If we wanted to support blocking we'd need to put
a wait queue .. [60: Wed Dec  6 08:38:33 2017 So, waiting on multiple
queues in the kernel seems a bit non-trivial.  Let's try to keep it
the simple choice here (KITSCH).

If /dev/itc/dir/ET/packet exists, it will be write-only for now, and
it will just add the appropriate packet header byte for the given
direction, figure out whether that's PRU0 or PRU1, and dish it to
rpmsg.  Shouldn't call it /packet though, if it's not a packet when it
goes in.  ET/payload?  ET/send?  ET/datapacket?  ET/packetbody?

[61:

Wed Dec  6 09:08:00 2017 I have to say it's tempting to want
reasonable direction-based point-to-point comms.

[68:

Wed Dec  6 03:49:03 2017 So that would mean a kfifo per dir, in
addition to the kfifo for the special packets.  And scanning the
packet kfifos on /dev/itc/packet reads.  But then we could have
plausible blocking reads on /dev/itc/dir/ET/packet.

But only a non-blocking read on /dev/itc/packets grr.  Could it be one
extra wait queue for packet level reads?  So whenever we add anything
to any dir kfifo, we wake up two wait queues?  Our own dir plus the
packet level?  And whoever gets it gets it?[69:

Wed Dec  6 04:34:01 2017 Maybe but then we also have to have a mutex
for reading each dir kfifo to arbitrate who actually does get it.
Which is a drag, but then, we already signed up for that the instant
we considered having /dev/itc/packets and /dev/itc/dir/ET/packet --
whether anybody is blocking or not.

So once again, how bad do we really want /dev/itc/dir/ET/packet???

Vs throwing that dispatch up to userspace and dealing with it there.

The reason I was wanting it in kernel was so we could consider
shipping data --- like, say, a new .mfz file -- inter-tile, while
mfmt2 was running and doing cache traffic over the same itc channels.

[70:

Wed Dec  6 04:51:01 2017 Did a little reading about implementing a new
socket type and eventually using like skbuffs and hooking into the
networ klayers.  Maybe someday.  What can we do now to move the ball
while likely foreclosing as little possible of that stuff down the
road?

We basically want UDP-like semantics, with our own address space or
address family or whatever it's called.[71:

Wed Dec  6 07:21:39 2017 Anyway. Anyway damnit this is not
progressing.  First stop, just setting and testing the pins --
/dev/itc/dir/ET/TXRDY etc -- via requests to the PRUs.

:71]

:70]

:69]

:68]

(Hmm, it's also tempting to want fricking MOUNTAIN TIME on MY TILES
instead of UTC..  For those times when we are connected to the net..
Could we quick add a TZ config to our T2-12 repo?)[62:

Wed Dec  6 09:20:18 2017 OK well attempt #1 didn't work:

    root@beaglebone:/home/t2/T2-12# echo 'Etc/Navajo' > /etc/timezone
    root@beaglebone:/home/t2/T2-12# cat /etc/timezone
    Etc/Navajo
    root@beaglebone:/home/t2/T2-12# dpkg-reconfigure --frontend noninteractive tzdata

    Current default time zone: 'Etc/UTC'
    Local time is now:      Wed Dec  6 09:19:51 UTC 2017.
    Universal Time is now:  Wed Dec  6 09:19:51 UTC 2017.

    root@beaglebone:/home/t2/T2-12#

[63:

Wed Dec  6 09:21:26 2017 Nor attempt #2:

    root@beaglebone:/home/t2/T2-12# echo 'Etc/MST7MDT' > /etc/timezone
    root@beaglebone:/home/t2/T2-12# cat /etc/timezone
    Etc/MST7MDT
    root@beaglebone:/home/t2/T2-12# dpkg-reconfigure --frontend noninteractive tzdata

    Current default time zone: 'Etc/UTC'
    Local time is now:      Wed Dec  6 09:21:05 UTC 2017.
    Universal Time is now:  Wed Dec  6 09:21:05 UTC 2017.

    root@beaglebone:/home/t2/T2-12# cat /etc/timezone
    Etc/UTC
    root@beaglebone:/home/t2/T2-12#

[64:

Wed Dec  6 09:29:56 2017 Nor attempt #3

    root@beaglebone:/home/t2/T2-12# cp /usr/share/zoneinfo/MST7MDT /etc/localtime
    root@beaglebone:/home/t2/T2-12# dpkg-reconfigure --frontend noninteractive tzdata

    Current default time zone: 'Etc/UTC'
    Local time is now:      Wed Dec  6 09:29:32 UTC 2017.
    Universal Time is now:  Wed Dec  6 09:29:32 UTC 2017.

    root@beaglebone:/home/t2/T2-12# cat /etc/timezone
    Etc/UTC
    root@beaglebone:/home/t2/T2-12#

Nor attempt #4

    root@beaglebone:/home/t2/T2-12# cp /usr/share/zoneinfo/MST7MDT /etc/localtime
    root@beaglebone:/home/t2/T2-12# echo 'Etc/MST7MDT' > /etc/timezone
    root@beaglebone:/home/t2/T2-12# dpkg-reconfigure --frontend noninteractive tzdata

    Current default time zone: 'Etc/UTC'
    Local time is now:      Wed Dec  6 09:30:45 UTC 2017.
    Universal Time is now:  Wed Dec  6 09:30:45 UTC 2017.

    root@beaglebone:/home/t2/T2-12#

[65:

Wed Dec  6 02:33:53 2017 Enfin.   Attempt #5:

    root@beaglebone:/home/t2/T2-12# ln -fs /usr/share/zoneinfo/MST7MDT /etc/localtime
    root@beaglebone:/home/t2/T2-12# ls -l /etc/localtime
    lrwxrwxrwx 1 root root 27 Dec  6 02:33 /etc/localtime -> /usr/share/zoneinfo/MST7MDT
    root@beaglebone:/home/t2/T2-12# rm /etc/timezone
    root@beaglebone:/home/t2/T2-12# dpkg-reconfigure --frontend noninteractive tzdata

    Current default time zone: 'SystemV/MST7MDT'
    Local time is now:      Wed Dec  6 02:33:45 MST 2017.
    Universal Time is now:  Wed Dec  6 09:33:45 UTC 2017.

    root@beaglebone:/home/t2/T2-12#

Or maybe I like this better:

    root@beaglebone:/home/t2/T2-12# ln -fs /usr/share/zoneinfo/Navajo /etc/localtime
    root@beaglebone:/home/t2/T2-12# rm /etc/timezone
    root@beaglebone:/home/t2/T2-12# dpkg-reconfigure --frontend noninteractive tzdata

    Current default time zone: 'America/Denver'
    Local time is now:      Wed Dec  6 02:35:40 MST 2017.
    Universal Time is now:  Wed Dec  6 09:35:40 UTC 2017.

    root@beaglebone:/home/t2/T2-12#

since anything SystemV creeps me out.
[66:

Wed Dec  6 03:03:59 2017 OK, well it didn't involve too much yak
shaving, and now we have a new T2-12/pkgconfig directory that
currently just sets the timezone to mountain.[67:

Wed Dec  6 03:07:54 2017 Oh and look at these timestamps now!  So
local!  So right!  T2 tiles come from the mountains!  T2!

:67]

:66]
:65]

:64]

:63]

:62]

:61]

:60]

:59]

:58]

:57]

:55]
[72:

Sat Dec  9 05:53:27 2017 OK, let's take a few minutes here before
breakfast to see about these attribute groups..  Greg KH says if I
have a class, which I do, I want to be dealing with these guys:

    struct class {
        ...
        struct class_attribute      *class_attrs;
        struct device_attribute     *dev_attrs;
        struct bin_attribute        *dev_bin_attrs;
        ...
    }

So let's look for a couple of believable-looking examples mentioning,
say, "struct class_attribute"..
[73:

Sat Dec  9 05:59:58 2017 Something like this perhaps:

    static struct class_attribute class_attr[] =
    { __ATTR(enable, 0644, enable_show, enable_store), __ATTR_NULL };

    static struct class hello_drv =
    { .name = "Dev_Hello", .owner = THIS_MODULE, .class_attrs =
                    (struct class_attribute *) &class_attr, };

plus this


    status = class_register(&hello_drv);
    if (status < 0)
       printk("Registering Class Failed\n");

in the module _init().

from https://github.com/Jeshwanth/Linux_modules_examples/blob/master/sysfs/enable_attr_sysfs.c

[74:

Sat Dec  9 06:01:51 2017 So, __ATTR does the stringification?  We
never write the name of the sysfs entry as a string ourselves?

[75:

Sat Dec  9 06:26:35 2017 Ah, doh,
https://www.kernel.org/doc/Documentation/filesystems/sysfs.txt

with a device level example:

    #define DEVICE_ATTR(_name, _mode, _show, _store) \
    struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show,
    _store)

    For example, declaring

    static DEVICE_ATTR(foo, S_IWUSR | S_IRUGO, show_foo, store_foo);

    is equivalent to doing:

    static struct device_attribute dev_attr_foo = {
       .attr = {
                 .name = "foo",
                 .mode = S_IWUSR | S_IRUGO,
               },
       .show = show_foo,
       .store = store_foo,
    };

from which we can learn (1) __ATTR does stringify, but (2) This is not
an attribute _group_ example, which is what we thought we were going
for.. [76:

Sun Dec 10 05:30:03 2017 OK, so, in modern parlance, this:

    TIL the reason I can't google decent answers for my linux kernel
    questions anymore is it's time for me to git clone mainline and
    use git grep and discover I can understand the results.

[77:

Sun Dec 10 05:38:17 2017 We now have a framework for groups of
attributes stuck onto the ->dev_groups of our itc_pkt_class object,
courtesy of drivers/misc/c2port/core.c, and it's time to pick a first
attribute or few to try implementing.[78:

Sun Dec 10 06:14:06 2017 I guess for starters we're going for like
ET_TXRDY as a single attribute, with show and set, and defer ET/TXRDY
until we understand things better.

[79:

Sun Dec 10 12:25:00 2017 OK, so it took forever but we have managed to
get class attributes demoed in itc_pkt.c, living amongst the
previously demoed /dev/itc/pru[01] == /sys/class/itc_pkt/itc!pru[01].
The key at the end appeared to be ditching class_create in favor of
class_register, so we could set up its .class_attrs before registering
it.

A little hard to believe there isn't a way to do it with class_create,
but I haven't found an example of that yet.  And class_create goes to
__class_create which goes to __class_register which goes to
add_class_attrs..  Aaand add_class_attrs appears to be called only
from there:

    linux-stable$ git grep add_class_attrs
    drivers/base/class.c:static int add_class_attrs(struct class *cls)
    drivers/base/class.c:       error = add_class_attrs(class_get(cls));
    linux-stable$

so for us it's class_register rather than class_create, I guess.

:79]
:78]

:77]

:76]

:75]

:74]

:73]
:72]
[80:

Mon Dec 11 01:53:27 2017 Well, it's likely not in its final context,
but we have arrived at the point we need to know:

(1) The mapping of "packet destination numbers" to ITCs, and,[83:

    Mon Dec 11 02:46:00 2017 Which will use the Dirs.h numbering:

                  PRUDIR   TXRDY      TXDAT       RXRDY     RXDAT
                             0          1           2         3
    0  NT  (x T2)           ---        ---         ---       ---
    1  NE  PRU1      2     r30_10     r30_11      r31_4     r31_5
    2  ET  PRU0      0     r30_3      r30_4       r31_0     r31_1
    3  SE  PRU0      1     r30_5      r30_6       r31_2     r31_14
    4  ST  (x T2)           ---        ---         ---       ---
    5  SW  PRU0      2     r30_7      r30_14      r31_15    r31_16
    6  WT  PRU1      0     r30_0      r30_1       r31_6     r31_7
    7  NW  PRU1      1     r30_8      r30_9       r31_2     r31_3

:83]
(2) The mapping of ITCs to PRUs..[85:

Mon Dec 11 03:41:07 2017 So, which PRUs get which dirs?  I guess the
pinmap in doc/ should be the source for this?[86:

Mon Dec 11 03:50:19 2017 PRU[01] info from pinmap filled in above!

:86]

:85]

For (1) we are thinking:[82: No we're not, see :81: below.  :82]

[84: NO!  :84]0  ET
1  SE
2  SW
3  WT
4  NW
5  NE

So

 - We are counting clockwise from east
 - So one step clockwise of any direction is (dir+1)%6
 - And one step counterclockwise of any direciton is (dir+5)%6
 - The opposite of any direction is (dir+3)%6

[81:

Mon Dec 11 02:39:11 2017 Although we could just go with the eightfold
direction in MFM's Dirs.h, which puts NORTH at 0, NE at 1, .., NW at
7.  We are, after all allocating three bits for the direction, so two
codes are going to be illegal no matter what.  With the :80: scheme
above, 6 and 7 will be illegal; with the Dirs.h scheme, 0 and 4 will
be illegal.

It creeps us out having the legal direction values not be contiguous,
which makes clockwise and counterclockwise a tad more complicated..
but it's in line with significant uses in the MFM, most especially
including CacheProcessor.h::m_cacheDir.

So let's go with it.  0 and 4 illegal..

:81]

:80]
[87:

Mon Dec 11 04:08:19 2017 OK, so given :83: we should be able to sketch
out what a read on ET_TXRDY would do:

 1. Standardize the request.  Maybe we should have numbers for the
    pins as well as the dirs, like TXRDY..RXDAT == 0..3.  Then
    ET_TXRDY turns into 2,0 and SW_RXDAT turns into 6,3.  Actually
    let's also have a 0..2 'PRUDIR' for each dir.  [88: Mon Dec 11
    04:13:02 2017 PRUDIR added to :83:  So the full coordinate for is
    ET_TXRDY would be (0,0,0) meaning (PRU, PRUDIR, PIN).  And
    SW_RXRDY would be (0,2,2), and NE_TXDAT would be (1,2,1).[89:

Mon Dec 11 04:21:42 2017 So let's try again.  A read on NW_RXRDY would
do:

 1. Find pin coordinate.  NW -> PRU1, DIR1; RXRDY -> PIN2; so full pin
    coord is (1,1,2).

 2. Take the (write) lock on specialKfifo1.  Send an 'R' special packet to PRU1

:89]

    :88]

:87]
[90:

Mon Dec 11 06:30:25 2017 I think we need some restrictions on
initiative in using special packets.  In particular, the inclination
is that Linux->PRU special packets should always be 'commands', and
PRU->Linux special packets should always be 'responses'.  So in
particular, the PRUs cannot originate a special packet on their own.
So a linux process could send a special packet to a pru and block
waiting for a response on the appropriate special kfifo, and never
have to contend with an unexpected PRU-origined-packet showing up
instead.  Linux processes would have to mutex among themselves to get
the right to wait, and the special packet loop would not be pipelined,
but at least it makes a blocking read seem imaginable.

Of course here we're talking an evil disgusting remote procedure call,
with all the fragility that entails.. but at least, in this case, the
destination isn't _all_that_ remote, and the communications channel
between us is unlikely to be the weakest link.. although the
destination failing to respond is certainly a threat, and we'll have
to have a timeout leading to -EIO or something on the linux side.

OK.  So we're saying max one special request/reply in flight at a time
per PRU, with a mutex for issuing such a request.  We probably want a
per-PRU access point for issuing packets.  We probably want to include
a serial number in the packet and check it on return.

[91:

Mon Dec 11 07:03:57 2017 So.  Do we rise to the level of a little
struct for this?

struct specialPacketMgr {
  struct mutex m_cmdLock;
  unsigned m_serialNumber;
};

..and where would we stick this?  We certainly have other per-PRU
stuff to stash linux-side.  [92:

Mon Dec 11 07:27:59 2017 We'd want to stick it in struct itc_pkt_dev,
I imagine, since that's what we're allocating per minor device number.

:92]

:91]
:90]
[93:

Tue Dec 12 20:04:53 2017 OK, so we have a '/dev/itc/packets' getting
built, and torn down, now.  It's not doing much of anything yet, and I
can't believe this the way I'm doing it is right, but here we are.[94:

Tue Dec 12 23:03:19 2017 Now we'd like to get ET_TXRDY showing up
under /sys/class/itc_pkt/, instead of under both of
/sys/class/itc_pkt/itc\!pru[01]

Then we'd like to see a blocking read of ET_TXRDY work, using an 'R'
packet under the hood.

And on the way to that we think we want to refactor the message
sending stuff so it isn't so tightly coupled to the fops callbacks, so
that we can call it internally more easily.

But first sleep.[95:

Wed Dec 13 03:18:15 2017 OK, let's go.[96:

Wed Dec 13 03:44:44 2017 OK, ET_TXRDY was under the itc!pru[01]s
because I had it being a device attribute.  Now it's a class attribute
and it's under /sys/class/itc_pkt (for good and for ill).  And we made
an ITC_PIN_ATTR macro to begin systematizing this crap.  Now we need
to encode that pin info table we made back.. where.. in :80:, above..

:96]

:95]

:94]

:93]
[97:

Wed Dec 13 05:47:50 2017 OK, well, it's not really debugged or
double-checked, but we now have a table of pru pin info in itc_pkt and
all the pins are showing up (ugly but present):

    root@beaglebone:/home/t2/T2-12# ls /sys/class/itc_pkt/
    ET_RXDAT  ET_TXRDY     itc!pru1  NE_TXDAT  NW_RXRDY  packet    SE_RXRDY  SW_RXDAT  SW_TXRDY  WT_TXDAT
    ET_RXRDY  itc!packets  NE_RXDAT  NE_TXRDY  NW_TXDAT  poke      SE_TXDAT  SW_RXRDY  WT_RXDAT  WT_TXRDY
    ET_TXDAT  itc!pru0     NE_RXRDY  NW_RXDAT  NW_TXRDY  SE_RXDAT  SE_TXRDY  SW_TXDAT  WT_RXRDY
    root@beaglebone:/home/t2/T2-12#

I really wish I knew how to push them down to at least
/sys/class/itc_pkt/pins, But I Don't.
[98:

Wed Dec 13 05:50:06 2017 So OK, now we have to face sending a packet
internally and blocking for an answer.  Can we break that down a bit?

 - [100: Wed Dec 13
   06:31:46 2017 DONE, made changed to S.dev_packet_state[3]  :100]Refactor, or at least understand if we don't need to, to have some
   way to get to the rpmsg_channels from outside fops interface
   methods.  Store pointers at create time, presumably.[99:
   Wed Dec 13 06:18:56 2017 ITCDeviceState has rpmsg_channel * for
   minor [01].  Just need to get to that from S.. :99]

 - [101: Wed Dec 13 06:32:17 2017 DONE, created send_msg_to_pru
   (rudy).  Tested only in the existing flow so far.[102: Wed Dec 13
   08:25:28 2017 Now also in use for itc pin writes.  :102]
   :101]Refactor so rpmsg_send is accessible outside fops interface
   methods, using our alternate navigation to the rpmsg_channels
   produced above.

[103: DONE Wed Dec 13 17:59:22 2017   :103] - Create a wait queue for each kfifo.  (We don't have that, I think?)

[104: DONE (although _cb does it directly)  :104] - Refactor so that the rpmsg callbacks dish off somewhere to store
   the packet and wake the appropriate waiters.

[105: DONE  :105] - Have the newly-created sysfs pin read/write handlers generate 'R'
   and 'W' packets to the appropriate PRU and then wait for an answer.


:98]
:97]
[106:

Wed Dec 13 18:01:05 2017 OK so we have blocking read+write of PRU
pins.  We need a script to test all the pru pins, assuming full cross
connection, and that will let us finally complete 4.2 from all the
back in :33:.[107:

Wed Dec 13 18:04:08 2017 In tests/ITC/, I guess? [108:

Wed Dec 13 18:10:25 2017 Although that code seems decidedly rottedy at
this point, due to device tree changes or something.  checkExports.pl
is dying because T2tils.pm seems to be expecting pingroups with names
like 'pinmux_ET_ITC_all_gpio_pins' but that name is currently nowhere
to be found in /sys/kernel/debug/pinctrl/44e10800.pinmux/pingroups.

So maybe not there.

Actually, let's make a place for tests expect to be run when the ITCs
are all cross-connected.  If we made a functional tester for this
thing to use during PCBA, that would be the condition we would go
for..
[109:

Thu Dec 14 04:46:21 2017 OK, so now we're getting (slow, considering)
output from cross-connection tests at tests/XCON/XCON_PRU_PIN_TEST.pl:

    root@beaglebone:/home/t2/T2-12# time tests/XCON/XCON_PRU_PIN_TEST.pl
    ////TESTING ET_TXRDY
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 1  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 0  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING ET_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 0  WT_RXDAT = 1  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING SE_TXRDY
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 0  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING SE_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 0  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING SW_TXRDY
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 1
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 0  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING SW_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 0  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 1
    ////TESTING WT_TXRDY
    ET_RXRDY = 1  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 0  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING WT_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 1  SE_RXDAT = 0  SW_RXDAT = 0  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING NW_TXRDY
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 0  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING NW_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 0  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING NE_TXRDY
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 1  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 0  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING NE_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 1  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0

    real	0m5.430s
    user	0m0.648s
    sys	0m1.452s
    root@beaglebone:/home/t2/T2-12#

from which we can see that everything 'works' -- except SE and NW, which
are not cross-connected at the moment.  Because I'm afraid to try
cross-connecting through the power connector, currently plugged into
NW, since that requires a M<->F ribbon cable and I've blown an awful
lot of fuses using them.

But hey, let's shut down quickly, recable, and just confirm that,
indeed, all PRUs are responding as expected.  That'll get us a check on
4-point-something, right?

:109]
:108]

:107]

:106][110:

Thu Dec 14 04:58:43 2017 OK, well, now E<->W and NW<->SE are xcon but
NE and SW are unconnected, and that's giving us:

    root@beaglebone:/home/t2/T2-12# ./tests/XCON/XCON_PRU_PIN_TEST.pl
    ////TESTING ET_TXRDY
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 1  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 1  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING ET_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 1  WT_RXDAT = 1  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING SE_TXRDY
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 1  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 1  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING SE_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 1  WT_RXDAT = 0  NW_RXDAT = 1  NE_RXDAT = 0
    ////TESTING SW_TXRDY
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 1  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING SW_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 1  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING WT_TXRDY
    ET_RXRDY = 1  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 1  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING WT_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 1  SE_RXDAT = 0  SW_RXDAT = 1  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING NW_TXRDY
    ET_RXRDY = 0  SE_RXRDY = 1  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 1  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING NW_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 1  SW_RXDAT = 1  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING NE_TXRDY
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 1  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING NE_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 1  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    root@beaglebone:/home/t2/T2-12#

which isn't so pretty because SW_RXDAT seems to be pulled high for
some reason.  (I'm actually surprised that seems to be the only one,
in fact.)

We note that up at itc lock level, SW is also going through its
endless-but-slow attempts to connect to somebody who's not there:

    [  229.943718] ITC SW: sFAILED->sRESET o11 i11
    [  229.948021] ITC SW(sRESET): o11 i11, f11, r12, at0, ac0, gr0, co0, it0, em0
    [  230.051708] ITC SW: sRESET->sSYNC01 o11 i11
    [  230.056009] ITC SW(sSYNC01): o01 i11, f11, r12, at0, ac0, gr0, co0, it0, em0
    [  230.159715] ITC SW: sSYNC01->sWAIT o01 i11
    [  230.163935] ITC SW(sWAIT): o11 i11, f11, r12, at0, ac0, gr0, co0, it0, em0
    [  336.844328] ITC SW: sWAIT->sFAILED o11 i11
    [  336.848548] ITC SW(sFAILED): o11 i11, f12, r12, at0, ac0, gr0, co0, it0, em0
    [  336.952317] ITC SW: sFAILED->sRESET o11 i11
    [  336.956618] ITC SW(sRESET): o11 i11, f12, r13, at0, ac0, gr0, co0, it0, em0
    [  337.060328] ITC SW: sRESET->sSYNC01 o11 i11
    [  337.064637] ITC SW(sSYNC01): o01 i11, f12, r13, at0, ac0, gr0, co0, it0, em0
    [  337.168327] ITC SW: sSYNC01->sWAIT o01 i11
    [  337.172548] ITC SW(sWAIT): o11 i11, f12, r13, at0, ac0, gr0, co0, it0, em0

because it's seeing two 1s (i11) on its inputs.

So what's the deal with these three pins:

   SW_RXDAT  SW_IGRLK  SW_IRQLK

that isn't true of, say SW_RXRDY?  SYSBOOT crap or something?

Well, which pins are those?

Checking later, though.  Time for a nap before the day gets going.
[111:

Thu Dec 14 12:25:50 2017 OK, back from napping and morning stuff.  So,
what _are_ those pins?

   SW_RXDAT  P9_24
   SW_IGRLK  P8_31
   SW_IRQLK  P8_26

wow that's a weird collection of pins.[112:

Thu Dec 14 12:32:20 2017 Ooh look at this:

            P9_24_pruin_pin: pinmux_P9_24_pruin_pin {
                            pinctrl-single,pins = <0x184  0x36>; };
                            /* Mode 6, Pull-Up, RxActive */

from
https://github.com/cdsteinkuehler/beaglebone-universal-io/blob/master/cape-universal-00A0.dts#L608-L609

vs, say:

            P9_25_pruin_pin: pinmux_P9_25_pruin_pin {
                             pinctrl-single,pins = <0x1ac 0x26>; };
                             /* Mode 6, Pull-Down, RxActive */

Do we have that P9_24 decl?  Could we change it to <.. 0x26>?[113:

Thu Dec 14 12:49:20 2017 Hmm, we did!  Changed:

    --- a/files/firmware/lib/cape-universal2-00A0.dts
    +++ b/files/firmware/lib/cape-universal2-00A0.dts
    @@ -843,7 +843,7 @@
                 P9_24_pru_uart_pin: pinmux_P9_24_pru_uart_pin {
                     pinctrl-single,pins = <0x184  0x35>; };     /* Mode 5, Pull-Up, RxActive */
                 P9_24_pruin_pin: pinmux_P9_24_pruin_pin {
    -                pinctrl-single,pins = <0x184  0x36>; };     /* Mode 6, Pull-Up, RxActive */
    +                pinctrl-single,pins = <0x184  0x26>; };     /* T2: Mode 6, Pull-Down, RxActive */

                 /* P9_25 (ZCZ ball A14) Audio   */
                 P9_25_default_pin: pinmux_P9_25_default_pin {

Let's trying rebooting this and see what we get.
[114:

Thu Dec 14 12:52:46 2017 Doh, perhaps this time we should try a 'make
install' before rebooting?[115:

Thu Dec 14 12:56:27 2017 OK!  Now we get like:

    ////TESTING NW_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 1  SW_RXDAT = 0  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0

and so on, instead of

    ////TESTING NW_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 1  SW_RXDAT = 1  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0

like before.  That doesn't fix the

   SW_IGRLK  P8_31
   SW_IRQLK  P8_26

issue, but it's a nice little clean-up.  Yay.

We do need to recable and make sure the SW<->NE xcon still does work
when it has the chance..[116:

Thu Dec 14 13:03:08 2017 It does:

 ..
    ////TESTING SW_TXRDY
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 1
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 0  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING SW_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 0  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 1
 ..
    ////TESTING NE_TXRDY
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 1  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 0  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0
    ////TESTING NE_TXDAT
    ET_RXRDY = 0  SE_RXRDY = 0  SW_RXRDY = 0  WT_RXRDY = 0  NW_RXRDY = 0  NE_RXRDY = 0
    ET_RXDAT = 0  SE_RXDAT = 0  SW_RXDAT = 1  WT_RXDAT = 0  NW_RXDAT = 0  NE_RXDAT = 0

So there.  Claiming 4.2 done!  Moving on!

:116]

:115]

:114]
:113]

:112]

:111]
:110]
[118:

Thu Dec 14 13:21:40 2017 So.  Given the slowness of my current
debug-access to the PRU pins, I'm going to claim/forgo 4.3 without any
further ado.  Yes: We have eyeballed 0 failures in PRU signal pins
that weren't due to understood issues.[120:

Thu Dec 14 13:23:54 2017 So that means we're in THE BIG MONEY ROUND!

Technically speaking we have not yet failed at 5.1, which has a time
limit on it, although we are precious close to doing so.  But it's the
next stop even if we arrive late.

So, let's break down 5.1 a bit here and make life easier for ourselfs.

[123: DONE :123](5.1.1) Refresh where we are in main_prux.inc regarding calling C from
        asm.  We'll need that for shipping packets and stuff.
        (Re)demo calling C from asm.

[136: DONE, mostly  :136](5.1.2) Get some spikes on the register sets and context switching
        going.  Demo using the 'struct over registers' that clpru is
        supposed to give us.  Say: Make a struct that has a counter
        for some of our RX pins -- like for prudir==1 say.

[151: Fri Dec 15 03:26:06 2017 DONE  :151](5.1.3) Make asm loop that watches those two RX pins, and whenever
        they change, increments the appropriate counter, and sends a
        standard packet containing the two counter values.

[155: Fri Dec 15 08:40:33 2017 DONE  :155](5.1.4) Make a linux-side script that catches those packets and
        reports them.

[156: Fri Dec 15 08:40:39 2017 DONE, see :154:  :156](5.1.5) Come back and make some more steps here.


:120]

:118]
[121:

Thu Dec 14 13:42:46 2017 OK, into 5.1.1.  Looks like we have
'addfuncasm' existing.  How do we run that?[122:

Thu Dec 14 14:06:34 2017 OK!  Looks like we ran it:

    root@beaglebone:/home/t2/T2-12/pru/itcio/module# echo f > /sys/class/itc_pkt/debug
    root@beaglebone:/home/t2/T2-12/pru/itcio/module# echo '*ab-----' > /dev/itc/pru0

which (after turning up the debugging) asks addfuncasm to add (the
ASCII values of) 'a' and 'b' and report back the result using the
SEND_VAL macro that calls C's sendVal.  And we saw:

    [ 3785.487228] set debug f
    [ 3787.103935] itc_pkt itc!pru0: Sending length 9 type '*' packet
    [ 3787.110082] <pru0: c1 30 30 30 30 30 30 63 33 20 66 69 72 73 74 20  .000000c3 first
    [ 3787.117971] <pru0: 63 68 61 72 20 74 6f 20 73 65 6e 64 20 74 6f 20  char to send to
    [ 3787.125787] <pru0: 74 68 65 20 6d 6f 6f 6e 20 61 6c 69 63 65 00     the moon alice.
    [ 3787.133523] <pru0: 2a 61 62 c3 2d 2d 2d 2d 0a                       *ab.----.

and in fact the sum of 'a' and 'b' is actually 0xc3.  SO THERE.

[125:

Thu Dec 14 14:12:53 2017 Actually, note, though, that these kind of
slimy 'echo foo > pru0' tests are bad because they leave the results
clogging up read side of /dev/itc/pru0 and/or /dev/itc/packets:

    root@beaglebone:/home/t2/T2-12/pru/itcio/module# cat /dev/itc/pru0
    *ab----
    *ab----
    *----                           (<< that's really ^A^B^C I think..)
    root@beaglebone:/home/t2/T2-12/pru/itcio/module# cat /dev/itc/packets
    000000c3 first char to send to the moon alice 000000c3 first char to send to the moon alice 00000003 first char to send to the moon alice root@beaglebone:/home/t2/T2-12/pru/itcio/module#

Now, we're expecting to have some userspace listener thread sitting on
/dev/itc/packets, ready to deal with whatever shows up whenever, so
that's not an issue right now.  But for special packets it would be
nice to have some kind of round-trip interface, wouldn't it?  But
how.. the existing ET_TXRDY guys get away with it because the outbound
packet is completely determined by the sysfs attribute name.. That
just doesn't generalize..  So.. leave it for now, I guess.  Just try
to remember about clogged input buffers.

:125]
Claiming 5.1.1.[124:

Thu Dec 14 14:10:35 2017 OK, 5.1.2 isn't quite so quick.[126:

Thu Dec 14 14:19:01 2017 Let's start by going for a standalone asm
program for struct over registers and get it building, just that.[127:

Thu Dec 14 14:24:32 2017 Ooh, holy crap, there's a 'new spru'..  I'd
been using spruhv7a.pdf from Nov 2014, but I just see now there's
spruhv7b.pdf from Oct 2017!  Fresh!  Let's hope it's better![128:

Thu Dec 14 14:29:24 2017 Alllllllthough, of course, that's the C/C++
manual.  Right now we need the asm stuff..  And spruhv6b.pdf is
already Oct 2017..[129:

Thu Dec 14 14:34:45 2017 So, Table 5-9 says we have .struct and .union
to play with, as well as .enum (without considering C compatibility,
which has other things).  And we'll want '.sassign' to map our .struct
onto PRU registers.  Let's see how we do that.[130:

Thu Dec 14 14:42:46 2017 OK, something like this perhaps, for our
spike demo..

STATE_INFO .struct
RXRDY_COUNT     .int
RXDAT_COUNT     .int
STATE_INFO_LEN  .endstruct

[131:

Thu Dec 14 14:46:26 2017 And then it would be like

LiveCounts .sassign R4, STATE_INFO

and then, I guess, LiveCounts.RXRDY_COUNT would be R4 and
LiveCounts.RXDAT_COUNT would be R4..

Let's see if we can just get this to compile, without being used,
inside main_prux_def.asm..

:131]

:130]

:129]

:128]

:127]

:126]

:124]

:122]

:121]
[132:

Thu Dec 14 14:51:59 2017 OK well this compiles:

            ;; STRUCTURE DECLARATIONS
    STATE_INFO:     .struct
    RXRDY_COUNT:    .int
    RXDAT_COUNT:    .int
    STATE_INFO_LEN: .endstruct

    LiveCounts:     .sassign R4, STATE_INFO

along with like this:

            ADD LiveCounts.RXRDY_COUNT, LiveCounts.RXRDY_COUNT, 1

producing stuff like this:

           3        ;; STRUCTURE DECLARATIONS
           4STATE_INFO:     .struct
           5           00000000000000  RXRDY_COUNT:    .int
           6           00000000000004  RXDAT_COUNT:    .int
           7           00000000000008  STATE_INFO_LEN: .endstruct
           8
           9LiveCounts:     .sassign R4, STATE_INFO

and this:

          36 00000030 0000000101E4E4          ADD LiveCounts.RXRDY_COUNT, LiveCounts.RXRDY_COUNT, 1

so I guess we're more or less in business.  Let's try a struct with
some stuff that's smaller than a full register, though..  Actually,
fog, let's try to translate our 'real' (ho ho) IOThread struct from
SymmetricBitstreamTransport.inc.. [133:

Thu Dec 14 15:17:42 2017 OK well we have gotten to this:

      11IOThread:       .struct
      12           00000000000000  bTHIS_ID:       .ubyte   ; this context id (0..2)
      13           00000000000001  bNEXT_ID:       .ubyte   ; next context id (0..2)
      14           00000000000002  bPREV_ID:       .ubyte   ; prev context id (0..2)
      15           00000000000003  bFLAGS:         .ubyte   ; flags
      16
      17           00000000000004  bTXRDY_PN:      .ubyte  ; Transmit Ready R30 Pin Number
      18           00000000000005  bTXDAT_PN:      .ubyte  ; Transmit Data  R30 Pin Number
      19           00000000000006  bRXRDY_PN:      .ubyte  ; Receive Ready  R31 Pin Number
      20           00000000000007  bRXDAT_PN:      .ubyte  ; Receive Data   R31 Pin Number
      21
      22           00000000000008  wRES_ADDR:      .ushort ; Resume address after context switch
      23           0000000000000A  bOUT1CNT:       .ubyte  ; current count of output 1s sent
      24           0000000000000B  bINP1CNT:       .ubyte  ; current count of input 1s received
      25
      26           0000000000000C  bOUTDATA:       .ubyte  ; current bits being shifted out
      27           0000000000000D  bOUTBCNT:       .ubyte  ; count of bits remaining to shift out
      28           0000000000000E  bINPDATA:       .ubyte  ; current bits being shifted in
      29           0000000000000F  bINPBCNT:       .ubyte  ; count of bits remaining to shift in
      30
      31           00000000000010  bPREVOUT:       .ubyte  ; last bit sent
      32           00000000000011  bTHISOUT:       .ubyte  ; current bit to sent
      33           00000000000012  wRSRV2:         .ushort ; reserved
      34
      35           00000000000014  rTXDAT_MASK:    .uint   ; 1<<TXDAT_PN
      36           00000000000018  rRSRV3:         .uint   ; reserved
      37           0000000000001C  rRSRV4:         .uint   ; reserved
      38           00000000000020  IOThread_LEN:   .endstruct

which appears plausible as far as it goes.  Looks like 32 bytes == 8
registers, as planned.  (Even the last two registers are reserved!)

My next question is: Given the C calling conventions, which registers
are we going to use?  A likely key bit of information there is that we
will be expecting to save our context with XOUT before calling any C
function anyway..  Right?  Or there really eight whole callee-saves
registers available?[134:

Thu Dec 14 15:25:04 2017 Well, spruhv7b section 6.4 says:

    Save-on-entry registers. Registers R3.w2 through R13. It is the
    called function's responsibility to preserve the values in these
    registers. If the called function modifies these registers, it
    saves them when it gains control and preserves them when it
    returns control to the calling function.

So it really seems like we could do like

    CT: .sassign R6, IOThread  ; R6-R13 is the current thread

[147: set up in mainLoop, and respected by all funcs below,  :147]
and still have R4 and R5 for 'preserved scratch' values, plus say,
R14-R19 for passing like six arguments, and still have R20-R29 for
'scratch scratch' values.  Man we love register space!
[135:

Thu Dec 14 15:34:33 2017 OK, well, all that assembled, but thinking
about IOThread is really getting ahead of ourselves.  Let's claim
5.1.2..[137: and then and narrow focus back to 5.1.3: Getting a loop
that actually watches pins and reports stuff.

Now, how actually is that going to work?  At first we had planned on
the main loop being in asm, and having it call out to C to check for
packets from time to time.  But at the moment C is owning the main
loop...[138:

Thu Dec 14 15:40:18 2017 Well, let's try writing initStateMachines()
and advanceStateMachines() in asm to do our pin-watch spike, and leave
C with the main loop, and see how it goes..[139:

Thu Dec 14 16:51:12 2017 Well, we have gotten a cut at them to
assemble.  And I came here to announce that before actually trying the
code, because I'm chicken.  It's supposed to use sendVal whenever
SE_RXRDY or SE_RXDAT (on PRU0) change state.  It's got macros and byte
fields oh my.

Well here we go.
[140:

Thu Dec 14 16:54:14 2017 Well, the world didn't end yet.  The PRUs
came back up and all.  Let's try toggling NW_TXDAT, here..[141:

Thu Dec 14 16:56:40 2017 Oooooookay, well so far no sign of any
packets getting sent back, although the PRUs are still responding to
my special packets.  Let's try the xcon test and see if anything might
trigger a reaction..[142:

Thu Dec 14 16:58:50 2017 Nope.  So here we are debugging, blurge.
Pretty much exactly what we were scared of.. But we know about
stopping the PRUs and reading the registers..  Let's do that and see
if we can learn anything.

:142]

:141]

:140]
:139]

:138]


:137]

:135]

:134]

:133]

:132]
[143:

Thu Dec 14 17:08:41 2017 Wait.  So I'm completely fogged up here,
right?  I can't use R4 and R5 for my LiveCounts struct, not in this
setup, because the asm code keeps returning.  Doh oh oh oh.  All my
arguments back in :134: only make sense IF ASM OWNS THE MAIN LOOP, so
we can set our stuff up there and everything else -- including
processing special packets and etc etc etc -- is functions called from
asm.  So we're going to have to turn this code inside out and give asm
the main loop before expecting it to go anywhere.

But it's time to check mail and etc and break for the evening, I
  think.[144:

Thu Dec 14 18:24:23 2017 Well, took a short break but got back for a
minute, here.  Turning the code inside out wasn't so hard, and now we
have a first glimmer of function!

Like, doing

    root@beaglebone:/sys/kernel/debug/remoteproc# echo 1 >/sys/class/itc_pkt/NW_TXDAT
    root@beaglebone:/sys/kernel/debug/remoteproc#

got me this

    [19340.891594] <pru0: c1 30 30 30 30 30 30 30 31 20 52 58 44 41 54 00  .00000001 RXDAT.

but only once..  Debugging still needed, but from a functioning
  start![145:

Fri Dec 15 00:51:10 2017 OK, let's take a crack at debugging
  here.[146:

Fri Dec 15 00:54:30 2017 Oooh, umm yeah, I'd been ignoring that part
about how R3.w2 is a callee-saved register.  R3.w2 is the fogging
return address!  If we aren't a leaf routine we really do have to
store that somewhere, don't we.  Which, for example, addfuncasm is
already doing, but advanceStateMachines (which may call sendVal via
SENDVAL), is _not_.

:146]

:145]

:144]

:143]
[148:

Fri Dec 15 01:38:53 2017 OK!  We have our little demo 'working'!  We
do like:

    # echo 0 >/sys/class/itc_pkt/NW_TXRDY; echo 0 >/sys/class/itc_pkt/NW_TXDAT ; echo 1 >/sys/class/itc_pkt/NW_TXDAT; echo 1 >/sys/class/itc_pkt/NW_TXRDY
    #

and we see like:

    [45139.634435] <pru0: c1 30 30 30 30 30 30 34 38 20 52 58 52 44 59 00  .00000048 RXRDY.
    [45139.644542] >pru1: 42 09 00 2d                                      B..-
    [45139.667489] <pru1: 42 09 01 2d                                      B..-
    [45139.674425] <pru0: c1 30 30 30 30 30 30 34 38 20 52 58 44 41 54 00  .00000048 RXDAT.
    [45139.684150] >pru1: 42 09 01 2d                                      B..-
    [45139.707949] <pru1: 42 09 00 2d                                      B..-
    [45139.715030] <pru0: c1 30 30 30 30 30 30 34 39 20 52 58 44 41 54 00  .00000049 RXDAT.
    [45139.725847] >pru1: 42 08 01 2d                                      B..-
    [45139.741360] <pru1: 42 08 00 2d                                      B..-
    [45139.748282] <pru0: c1 30 30 30 30 30 30 34 39 20 52 58 52 44 59 00  .00000049 RXRDY.

I thought I'd seen a case where a count was missed, apparently due to
multiple B packets being processed in a single call to
processPackets(), but scrolling back through dmesg and *shell* I see
it was just my misunderstanding.

So anyway cool!  And learned a lot pretty quickly!  Yay spike!

Let's get this working in the opposite direction -- requiring a little
PRU-specific customization -- and then claim our progress and move
on.[149:

Fri Dec 15 02:34:04 2017 OK, so the PRU-specific stuff is taking a
little time because I was trying to avoid repeating code between the
itcio/firmware and itcio/module sides of things.  The '.cdecls' asm
statement lets you include a C header file into asm, so I was thinking
a '.cdecls "itc_pkt.h"' might be useful.. and it might be, somewhat,
but it's definitely not the fantasy.  In particular, it appears that
any macros with arguments are simply ignored on the asm side.  Where
'macros without arguments' is my interpretation of the phrase
'non-function-like macro' in spruhv6b.pdf.

So I'm getting close to timing out on doing this without duplication.
My rationalization is that the T2 ITC pin assignments aren't going to
change any time soon, and if they do, it's going to be a huge major
upset all over the place anyway, and so 'one more place' that has to
be updated isn't that big as an incremental cost.

Fog it.  Cotton Paist.  Putting the r30/r31 pin number info into
prux.h, using the prudir abstraction.[150:

Fri Dec 15 03:11:00 2017 OK did that, and our spike is now working on
both prus ad lib:

        # echo 0 >/sys/class/itc_pkt/SE_TXRDY; echo 0 >/sys/class/itc_pkt/NW_TXDAT ; echo 1 >/sys/class/itc_pkt/NW_TXDAT; echo 1 >/sys/class/itc_pkt/SE_TXRDY
        #

    gets like

    [50732.198423] >pru0: 42 05 00 2d                                      B..-
    [50732.217939] <pru0: 42 05 01 2d                                      B..-
    [50732.224887] <pru1: c1 30 30 30 30 30 30 30 34 20 52 58 52 44 59 00  .00000004 RXRDY.
    [50732.235310] >pru1: 42 09 00 2d                                      B..-
    [50732.262603] <pru1: 42 09 01 2d                                      B..-
    [50732.269538] <pru0: c1 30 30 30 30 30 30 30 39 20 52 58 44 41 54 00  .00000009 RXDAT.
    [50732.279834] >pru1: 42 09 01 2d                                      B..-
    [50732.301971] <pru1: 42 09 00 2d                                      B..-
    [50732.308882] <pru0: c1 30 30 30 30 30 30 30 61 20 52 58 44 41 54 00  .0000000a RXDAT.
    [50732.319214] >pru0: 42 05 01 2d                                      B..-
    [50732.334108] <pru0: 42 05 00 2d                                      B..-
    [50732.341033] <pru1: c1 30 30 30 30 30 30 30 35 20 52 58 52 44 59 00  .00000005 RXRDY.

where now we see both <pru0 and <pru1 on the c1 packets.

Honesty makes me confess I found a typo in itc_pkt.h that may not be
that obvious in the diffs, because it turned up in the process of
moving the pin definitions out to a separate pin_info_maps.h file.
What's wrong with this picture:

    /* pru# + prudir# to direction */
    #define ITC_PRU_PRU_DIR_TO_DIR__0_0 ET
    #define ITC_PRU_PRU_DIR_TO_DIR__0_1 SE
    #define ITC_PRU_PRU_DIR_TO_DIR__0_2 NW
    #define ITC_PRU_PRU_DIR_TO_DIR__1_0 WT
    #define ITC_PRU_PRU_DIR_TO_DIR__1_1 NW
    #define ITC_PRU_PRU_DIR_TO_DIR__1_2 NE
    #define ITC_PRU_PRU_DIR_TO_DIR(pru,prudir) ITC_PRU_PRU_DIR_TO_DIR__##pru##_##prudir

Yes Jane, once again demonstrating reality's anti-southwest bias..

At present, those defs weren't in use anywhere, but still, foggindoh.
Dodged a bullet there perhaps.

Claiming 5.1.3.[152: and committing. :152]

:150]

:149]

:148]
[153:

Fri Dec 15 04:12:53 2017 OK, well, on to 5.1.4.  The 'only'
challenging part of that is we'll be dealing with 'standard' packets
for the first time.  We'd like to have a blocking option for
/dev/itc/packets -- right now it just returns 0 bytes if there's no
packets available.  Which is also a good option, but let's get it to
block unless O_NONBLOCK or whatever is set on the fd..

:153][154:

Fri Dec 15 07:25:59 2017 OK, with our new tests/PKT/PacketReporter.pl,
I think we can claim 5.1.4.  We're running out of to-do fast, but I
think the next stop, call it

[159: DONE  :159](5.1.6) Demo writing and reading standard packets on the same file
handle,

is pretty clear.  And then my gob it'll be time for the text of 5.1..

:154]
[157:

Fri Dec 15 10:39:07 2017 OK, after way too many stupid page faults due
to saying 'buf' instead of 'driver_buf' all over itc_pkt_write, we
appear to be routing outbound standard packets from /dev/itc/packets
appropriately:

    root@beaglebone:/home/t2/T2-12# echo f >/sys/class/itc_pkt/debug
    root@beaglebone:/home/t2/T2-12# echo 'ZORG' > /dev/itc/packets
    root@beaglebone:/home/t2/T2-12# echo 'ZORGEAST' > /dev/itc/packets
    root@beaglebone:/home/t2/T2-12#

getting

    [14999.182574] set debug f
    [15001.866458] itc_pkt_open 246:2
    [15001.875824] CONSIDERINGO ROUTINGO
    [15001.879325] Routing 'c1'+6 packet to PRU1
    [15001.900433] itc_pkt itc!pru1: Sending length 6 type 0xc1 packet
    [15001.906547] <pru1: c4 5a 4f 52 47 0a                                .ZORG.
    [15001.927678] itc_pkt_release 246:2
    [15103.814205] itc_pkt_open 246:2
    [15103.823676] CONSIDERINGO ROUTINGO
    [15103.827151] Routing 'c2'+10 packet to PRU0
    [15103.848183] itc_pkt itc!pru0: Sending length 10 type 0xc2 packet
    [15103.854442] <pru0: c5 5a 4f 52 47 45 41 53 54 0a                    .ZORGEAST.
    [15103.881667] itc_pkt_release 246:2

Not sure how to demo going both ways in a perl script.[158:

Fri Dec 15 10:47:51 2017 Well, that wasn't so hard:

    root@beaglebone:/home/t2/T2-12# /home/t2/T2-12/tests/PKT/PacketReporter.pl -nb 'ZORGOPERL' 'ZORGEAST'
    I GOT(10)='ZORGOPERL'
    I GOT(9)='ZORGEAST'
    root@beaglebone:/home/t2/T2-12#

with the optional first arg -nb meaning non-blocking, and any
remaining args being packets to send, after which the script reads
either forever (no -nb) or until there's nothing left to read (with
-nb).

Claiming 5.1.6.[160:

Fri Dec 15 10:54:52 2017 Committing.  Then consider how we might spike
the state machine development some.

:160]

:158]

:157]
[161:

Fri Dec 15 11:18:32 2017 How about we go after the IOThreads and
context switching, first?

[168: DONE Fri Dec 15 16:33:01 2017   :168]5.1.7 Get the three threads initializing and then reporting with
      SENDVAL during initialization, if that's possible given
      ontogeny.

[198: DONE Mon Dec 18 13:14:06 2017   :198]5.1.8 Get context switching going and have each thread do nothing
      except report with SENDVAL like every 1000th time they are
      advanced.  10,000th?  That'll be some data right there.

Just those two are already substantial.  So then

5.1.9 Return here and make more spikes.

:161][162:

Fri Dec 15 11:30:20 2017 Looks like initStateMachine time might be too
early.  Are we sure to have seen firstPacket by then?  Could we
be?[163:

Fri Dec 15 11:39:43 2017 OK, reorged to delay initStateMachine until
firstPacket is done.  Can I claim 5.1.7?  Well, no, because at present
all we're initializing is the LiveCounts struct, not the CT struct,
doh.

Real CT initialization is something more like this:

 - Loop i in 0..2
   = Zero all of CT
   = set CT.bTHIS_ID = i
   = set CT.bNEXT_ID = (i+1)%2
   = set CT.bPREV_ID = (i+2)%2
   = set CT.TXRDY_PN, bTXDAT_PN, bRXRDY_PN, bRXDAT_PN from the prux.h defs
   = set CT.rTXDAT_MASK from bTXDAT_PN or the prux.h def
   = set CT.wRES_ADDR = advanceStateMachine, or whatever the
     appropriate label is
   = XOUT the whole CT struct to the scratchpad, shifted by 8*i

But then as I look at that, it seems like what we really ought to do
is initialize each thread as in 'disabled' mode or something, so that
it would not have a next or prev.  And we should have an official
one-byte 'head of thread list' outside of CT that would initially
point at nothing (somehow).  And then we should enable each thread one
by one, and the process of enabling would automatically set the next
and prev appropriately for a circular doubly-linked list.

That will take us a long way towards being clean enough to enable a
direction based on, for example, having gotten to sIDLE in the
corresponding lock negotiation.  (And to disable based on having
reached sRESET or something.)

((And We could use a 'special standard' packet for changing enable
status.))

(((But we really need a name for those packets that doesn't include
'special'!  Please!  'local standard'?  'standard immediate'?
'unrouted standard'?  'control standard'?  'control packet', with the
'standard' implied?  'local packet' maybe?  'internal packet'?
Urgh.  Let's go with 'local standard' for now.)))

So.  To review:

 - Zero length packets are illegal except during PRU boot, so
   (virtually) every packet has at least one byte.

 - The first byte of a packet is its _type_.

 - In a 'standard' packet, by definition, (type&0x80)==0x80.

 - In a 'routed standard' packet, by definition, (type&0xc0)==0x80.
   The structure of a routed standard packet type is this:

      7   6   5   4    3   2   1   0
    +---+---+---+---++---+---+---+---+
    | 1 | 0 |RSV|OVR||ERR|SD2|SD1|SD0|
    +---+---+---+---++---+---+---+---+

     RSV - Reserved: Should be 0 on output, should be ignored on input
     OVR - Overrun: Packet data was lost due to exhausted buffer space
     ERR - Error: Some packet data corruption or other problem was detected
     SD[2..0] - Three bit source/destination direction code.

 - In a 'local standard' packet, by definition, (type&0xc0)==0xc0.
   The structure of a local standard packet type is this:

      7   6   5   4    3   2   1   0
    +---+---+---+---++---+---+---+---+
    | 1 | 1 |LS2|LS1||LS0|SD2|SD1|SD0|
    +---+---+---+---++---+---+---+---+

     LS[2..0] - Three bit local standard packet subtype.
     SD[2..0] - Three bit source/destination direction code.

 - The interpretation of SD[2..0] varies with context:
   = Linux->PRU: Packet destination direction
   = PRU->Linux: Packet source direction
   = PRU->PRU (in-flight intertile): Packet source direction

[164:

Fri Dec 15 12:46:32 2017 Ahem.  Well clearly :163: got away from me a
little, there, heh heh.  Has some useful stuff, though, if very likely
overdesigned for these exact space-time coordinates in the universe..

So, uh, where were we?

ORite: initting IOThreads -> enabling/disabling IOThreads -> whoopsie

So forget about runtime enabling/disabling.  But let's think about the
circular doubly-linked list with a list head we need to put somewhere.
We'll have to review the cargo-cult pseudocode we did months ago,
because I suspect it addressed some/much of this already.

I'm tempted to say that thread ids, instead of being 0..2, should be
whatever the necessary XFR register shift to load or save them..  But
I think it'll probably be the same number of instructions either way.
Assuming the necessary shifts will be 0, 8, and 16, then doing

   LSL R0.b0, CT.bNEXT_ID, 3

is no slower than doing

   MOV R0.b0, CT.bNEXT_ID

or whatever, since we have to set up R0.b0 for every XFR anyway.
Or.. could we make R0.b0 be our fogging thread list head?  And not use
it for _anything_ else?  [166: Fri Dec 15 13:27:31 2017 Urm except
that R0 is save-on-call donchano, so we'd have to copy it elsewhere
around every function call.. but there really might not be that many
of those, so.. :166]So then the guts of a context switch would be
something like this:

CONTEXT_SWITCH:
   XOUT PRUX_SCRATCH, CT, IOThread_LEN  ; Save suspending thread
   MOV R0.b0, CT.bNEXT_ID               ; Update list head
   XIN PRUX_SCRATCH, CT,  IOThread_LEN  ; Load resuming thread
   JMP CT.wRESADDR                      ; Resume it

and we have switched threads in 20ns flat.  Or say 25ns to count the

  JAL CT.wRESADDR, CONTEXT_SWITCH

that happened somewhere to initiate the switch.[165:

Fri Dec 15 13:15:30 2017 Could we have a demo of some asm with
XIN/XOUT that compiles, please?  It doesn't have to do anything..

:165]

  :164]:163]

:162]
[167:

Fri Dec 15 16:28:05 2017 OK, lots more foggindoh learning fun for me,
but now we have special packet 'S', which returns some or all of the
scratchpad used for thread storage, and we can see our three threads
now _minimally_ initialized.  With

    # echo SSSSSSssSSSSSSSSSSSSSSSSSSssSSSSSSSSSSSSSSSSSSSssSSSSSSSSSSSSSSSSSSssSSSSSSSSSSSSSSSSSS-------ddzabcx > /dev/itc/pru1
    #

we get:

    [39467.752993] itc_pkt_open 246:1
    [39467.763064] itc_pkt itc!pru1: Sending length 102 type 'S' packet
    [39467.769323] <pru1: 53 53 53 53 00 00 00 00 00 00 00 00 00 00 00 00  SSSS............
    [39467.777203] <pru1: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    [39467.785021] <pru1: 00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00  ................
    [39467.792984] <pru1: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    [39467.800817] <pru1: 00 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00  ................
    [39467.808631] <pru1: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    [39467.816438] <pru1: 00 00 00 00 78 0a                                ....x.
    [39467.838803] itc_pkt_release 246:1

and it's the 01 and 02 in there that are salient.

I'm going to claim 5.1.7 now, even though the initialization we have
is totally bogus.  I'm going to leave better initialization as a 5.1.8
task, when we'll actually be using a bit more of the state in the
struct.

But getting toward time to cook.

:167]
[169:

Sat Dec 16 04:58:10 2017 So, focusing on implementing the thread
list.  Actually let's review the SymmetricBitstreamTransceiver.inc
pseudocode from.. May 2017.. Seven months ago.
[170:

Sat Dec 16 07:05:32 2017 OK, well I got distracted by all the SHOUTING
in the asm code and decided to go back and change capitalization
conventions.  Also made some more macros for function prologue and
stuff and just generally cleaned up the dump a bit.

So that hit just about everything in main_pru_def.asm, and we should
commit before also doing anything much functional.

Actually, maybe now's the time to reorg the filenames too, ditch
main_prux.inc and so on.  Since we cleaning anyway.[171:

Sat Dec 16 07:57:48 2017 OK, renamed files and added GPL stuff and now
getting ready to commit.

:171]

:170]
:169]
[172:

Mon Dec 18 03:59:24 2017 OK, well we had a fairly disruptive event
yesterday or so, where something we did in pru/itcio/firmware managed
to first oops and then eventually corrupt the disk badly enough that
we had to reinstall.  And in recovering from all that, among other
things, we rolled the T2-12 repo back several commits to get to
pru/itcio/firmware that worked.  But we saved almost all of what we
had on a separate 'busted_firmware' branch, and as a late part of the
recovery process we started cherry-picking safe commits from that
branch back into the rolled-back develop branch.

But cherry-picking NOTES entries is hard because all duplicated note
numbers will collide, along with the next-avail at the top.  So, for
posterity at least -- and there's some I suspect significant design
discussions in them -- I'm placing the missing entries immediately
below here in :174:, with all their note numbers stripped out.

[173: ====BEGIN EXTRA NOTES FROM THE busted_firmware BRANCH==== [174:

Sat Dec 16 08:11:04 2017 OK committed.  Where were we?  Pop pop.

..Reviewing SymmetricBitStreamTransceiver to see what we could learn.
Let's not do more of that, since it seems to encourage day dreaming
and fantasy, and instead see about enabling and disabling IOThreads.

Hmm, note that changing next or prev pointers on _other_ threads
requires writing into the scratchpad.  Can we make a little macro to
help with that?  Give me another thread id and a byte offset or
something, and I read or write that byte for you?

Sat Dec 16 09:23:18 2017 OK, well not quite that flexible, but I made
'LOADCXTR1 threadid', that reads the (new) ThreadContext struct of the
given threadid into R1.  And 'SAVECXTR1' which writes R1 back to the
threadid from the LOADCXTR1, relying on r0.b0 to still be good.  A
'WRITECXTR1 threadid' would be easy to add, but let's need it first.

So.  Can we write some thread enable/disable routines?  Signatures?

Sat Dec 16 09:51:24 2017 Well, did more cleanup, but I'm having
trouble with the next/this/prev_id linked list concept.  Starting to
design it, it seems like a lot of overhead for three threads.  If we
kept some kind of thread enabling info in the (newly-created struct
GlobalContext) GC, we could perhaps just iterate over all the thread
info and skip anything that's disabled at the cost of maybe one
instruction, rather than actually switching contexts just to discover
the new current is disabled, at a cost of like five or six
instructions anyway.

Now, the old pseudocode seemed to be playing it both ways -- having
both nextID and prevID ptrs as well as a enable bit -- but it never
actually changes the next ptr after init, and it never uses the prev
ptr at all..

So let's go just halfway on this.  Let's ditch the prev ptr, and init
the next ptr to (this+1)%3, and expect to just cycle through all of
them all the time in advancestatemachines.  We'll do the enable bit
and take the five instructions hit per disabled thread advance.
That'll get us going and we'll still theoretically be able to consider
changing the linking in the future if we get to that level of need and
competence.

Sat Dec 16 10:28:56 2017 Hmm hmm hmm..  Here's a pretty evil
possibility.  If we reduce the IOThread size to six regs instead of
eight, by ditching rRSRV3 and rRSRV4, 'which we aren't using anyway',
then we could use 1..3 for thread ids instead of 0..2, and have 0
available down the road to mean null.  The idea would be to have the
register address in the XFR instructions be &R0 instead of &CT, and
then thread id 1 would have a shift of 6 which would take us to
R6==CT, and so on.  And then we're completely hosed when we need more
space in IOThread then the current wRSRV1 can provide.

But writing that paragraph I got the obvious next step: Who says the
XFR register address can only be &CT or &R0?  The XFRs all wrap around
in register space, so we can stay with our eight reg IOThread, AND
have thread ids of 1..3 so 0 can be OoB, by having the XFR register
address be the one that's eight before CT with wrap-around.  And which
register would that be, exactly?  Checking wrap rules..

Sat Dec 16 10:37:47 2017 The scratchpad banks are R0..R29, so
presumably wrap is %30..  Confirming..

Sat Dec 16 10:40:28 2017 Yeah, the second example in section 5.2.4.2.2
of spruhf8a implies %30.  So.  That means something like

   lsl r0.b0, THREADID, 3   ; get 8*threadid
   xin ..  foggindoh

Oh man I'm crazy.  The shift only applies to the scratchpad addresses,
not the register address!  The register address _is_ where the data
transfer will start in the register file.  None of this makes sense.

..But oh man I'm not crazy.  Who said the stored IOThreads have to
start in 8*threadid in the scratchpad?  We can put them anywhere we
want, have them half-wrapping around, or whatever.  So if we have
threadid 1..3 and we store at CT+8*threadid then we'll just have this
mapping:

  thread id  shift by    scratchpad regs
      1          8          R14-R21    (CT=6)+(8*1=8)=14
      2         16          R22-R29    (CT=6)+(8*2=16)=22
      3         24          R0-R7      (CT=6)+(8*3=24)=30%30=0

and hmm none of the structs actually gets wrapped, not that that would
matter.

Sat Dec 16 10:53:09 2017 Hmm!  Sitting here, that still seems
plausible!  Now, at the moment we don't really need 0 to be null in a
thread list, because we're just going to set it up at init and never
change it, but it feels better having it available.

Going for it.

Sat Dec 16 11:57:46 2017 OK, time to break for lunch and stuff.  Have
made progress though mostly just built yet untested.  During the
break, need to think through the interactions of the asm main loop
with the state machine execution.  Right now the overall state machine
is designed to just run hell for leather as soon as it's started,
context switching its brains out til universal heat death.  How does
the main loop ever get control again, or doesn't it?  If not, we need
to move the processPackets call to somewhere inside the state machine
so that we'll have a prayer of the pru listening to us.

Later.
:174] ====END EXTRA NOTES FROM THE busted_firmware BRANCH==== :173]

:172]
[175:

Mon Dec 18 04:23:40 2017 So now the question is: How can we move
forward on some of the busted stuff, more slowly, and keep it alive?
What should we try first?  Right now, I'm suspicious of all the
cleaning and renaming and Makefile stuff; seems eminently possible
that could be a problem somehow.
[176:

Mon Dec 18 04:42:44 2017 We're going to see if we can change the name
of the asm file.  Not the main_pru[01].c files, just the
main_prux_def.asm file..[177:

Mon Dec 18 04:57:18 2017 Well, that seemed to go okay.  Also took a
moment to trim up .gitignore files so we're actually clean clean clean
now in git status.  Let's try to hang on to that shall we.

So, what next.[178:

Mon Dec 18 05:01:33 2017 Here's another thought or two about context
switching:

Suppose we
(1) Ditched the whole idea of sequential threadids.  Instead of 0..2
    or 1..3, suppose we just used the register shift as the id.  And
(2) Suppose we also ditched both next_id and prev_id, and instead have
    a global register giving the sequence of threads to run.

And the way we context switch would be something like this:

    xout PRUX_SCRATCH, &CT, IOTHREAD_LEN  ; Save us
    lsr threadSeq, threadSeq, 8           ; Move on to next thread
    mov r0.b0, threadSeq.b0               ; Get shift
    xin PRUX_SCRATCH, &CT, IOTHREAD_LEN   ; Load next guy
    jmp CT.wResAddr                       ; Resume him

And you ask: But what happens when threadSeq gets all shifted out?
And the answer is: That never happens, because we have a secret fourth
thread that just reloads threadSeq and resumes.  But there aren't
enough registers to have a fourth IOThread, if they're eight regs
each!  But our secret thread doesn't have to be eight regs each!  It
could be just one!  And we'd do it like this:

    ThreadHeader:   .struct
    bTHIS_SHIFT:    .ubyte   ; shift to storage for this thread (0..29)
    bSIZE_BYTES:    .ubyte   ; size of this thread (4..30*4)
    wResAddr:       .ushort  ; thread resume address
                    .endstruct

    IOThread:       .struct
    rTH:            .tag ThreadHeader
    bTXRDY_PN:      .ubyte  ; Transmit Ready R30 Pin Number
..etc..
                    .endstruct

and then also have

    ThreadControl:  .struct
    rTH:            .tag ThreadHeader
                    .endstruct

and there's the fourth thread, taking just one scratchpad reg.  And
the context switch would really be more like this:

    mov r0.b0, CT.bTHIS_SHIFT               ; Get shift
    xout PRUX_SCRATCH, &CT, CT.bSIZE_BYTES  ; Save ourselves
    lsr threadSeq, threadSeq, 8           ; Move on to next thread
    mov r0.b0, threadSeq.b0               ; Get shift
    xin PRUX_SCRATCH, &CT, ..oops..       ; chicken and egg on the length
    jmp CT.wResAddr                       ; Resume him

We'd need to have the length in the threadSeq register.  But then the
unpacking starts costing even more..  Plus of course the cost of
switching to this fourth thread when most of the time it will change
nothing.  OK, I'm officially less excited about this idea.

So let's go back to ID==shift and try that with a thread header..

    ThreadHeader:   .struct
    bTHIS_SHIFT:    .ubyte   ; shift to storage for this thread (0..29)
    bNEXT_SHIFT:    .ubyte   ; shift to storage for next thread (0..29)
    wResAddr:       .ushort  ; thread resume address
                    .endstruct

    IOThread:       .struct
    rTH:            .tag ThreadHeader

and

    mov r0.b0, CT.rTH.bTHIS_SHIFT         ; Get our shift
    xout PRUX_SCRATCH, &CT, IOTHREAD_LEN  ; Save us
    mov r0.b0, CT.rTH.bNEXT_SHIFT         ; Get next guy's shift
    xin PRUX_SCRATCH, &CT, IOTHREAD_LEN   ; Load next guy
    jmp CT.wResAddr                       ; Resume him

which is still five instructions, but now we're no longer limited to
power-of-two IOTHREAD_LENs, because we're storing shifts instead of
IDs.  So we could take IOThread down to seven, or even six regs, at
least for now, and only pay a smidge more for thread initialization,
if that.[179:

Mon Dec 18 05:33:16 2017 If we did a two reg header

    ThreadHeader:   .struct
    bTHIS_SHIFT:    .ubyte   ; shift to storage for this thread (0..29)
    bTHIS_BYTES:    .ubyte   ; size of this struct (4..30*4)
    bNEXT_SHIFT:    .ubyte   ; shift to storage for next thread (0..29)
    bNEXT_BYTES:    .ubyte   ; size of next struct (4..30*4)
    wResAddr:       .ushort  ; thread resume address
    bFLAGS:         .ubyte
    bRSRV1:         .ubyte
                    .endstruct

then we could have variable-length threads:

    mov r0.b0, CT.rTH.bTHIS_SHIFT               ; Get our shift
    xout PRUX_SCRATCH, &CT, CT.rTH.bTHIS_BYTES  ; Save ourselves
    mov r0.b0, CT.rTH.bNEXT_SHIFT               ; Get next shift
    xin PRUX_SCRATCH, &CT, CT.rTH.bNEXT_BYTES   ; Load him
    jmp CT.wResAddr                             ; Resume him

and here we'd pay a little more for thread initialization and a little
more for thread reordering.

Would it be worth considering a fourth thread to be shipping stuff up
to linux, rather than running that into the regular prudir state
machines?  It would be only for managing code complexity rather than
performance.  But it's more complexity up front, and that we don't
need.

[180:

Mon Dec 18 05:43:09 2017 OK, let's execute here.  We really can't
spent the whole day on this since we have to finish up the course work
and ship that RSN, but let's get something done here.

Let's go with a one reg header and just run in it IOThread as we were
doing before.  Go from IDs to shifts, but include a prudir in 0..2
[181:

Mon Dec 18 06:00:32 2017 (Working on the context switching stuff, but:
Man we lost a bunch of stuff -- like the table of pinInfo for initting
the structs..  Grrrr.)

:181]
:180]

:179]

:178]

:177]

:176]
:175]
[182:

Mon Dec 18 06:07:27 2017 Having a fourth thread would be a natural
place to do checking for packets arriving from linux, though..  We
need to do that somewhere..

Part of the development trickiness here is about when and how do we
switch over from main loop control to threaded execution control.
Once we release the hounds they go straight to each other, they never
return.   So maybe we should think of a fourth thread, and have the
goal be to have all the IOThreads be idling, for now, and have the
fourth thread do the packetProcessing that the mainLoop is currently
doing.. [183:

Mon Dec 18 07:58:40 2017 OK, it seems we may have our now four threads
getting initialized plausibly.  And the fact that they're laid out
plausibly in the S-packet reply suggests we got the size and len stuff
into r0.w0, to use as b0 and b1, correctly.  So it would seem a next
stop could be to try to get thread 3 only working, with threads 0..2
set to immediately reschedule.  This would be a big step, because we'd
be switching the main loop over to threaded control..

[184: Mon Dec 18 09:29:05 2017 DONE, IdleThreadRunner.  :184] - Make an IDLE target that just does a context-switch and then jumps
   to IDLE.  (Later we'll expand that to check a flag but first things
   first.)

[185: DONE  :185] - Init threads 0..2 to resume at IDLE.

[186: DONE, LinuxThreadRunner.  :186] - Make an LINUX target that calls processPackets, does a
   context-switch, and then jumps to LINUX.

[208: DONE Tue Dec 19 04:20:12 2017   :208] - Change initStateMachines to startStateMachines, and

[209: DONE Tue Dec 19 04:20:15 2017   :209] - Have mainLoop jump to startStateMachines instead of calling it, and

[210: DONETue Dec 19 04:20:20 2017 Dintmuchheptho  :210] - Pray for mercy.

:183]

:182]
[187:

Mon Dec 18 09:30:38 2017 OK, well I think we've done most of what we
could do sensibly before letting the threads have control and see what
happens.  Let's commit and push this first.[188:

Mon Dec 18 09:36:38 2017 Did that.  Let's try the threads..[189:

Mon Dec 18 09:47:11 2017 OK.. well.. I should have prayed harder for
mercy..  We got endless high-speed repetitions of:

    Dec 18 09:43:20 beaglebone kernel: [20890.575148] <pru0: c1 30 30 30 30 30 30 32 38 20 50 52 55 30 20 52  .00000028 PRU0 R
    Dec 18 09:43:20 beaglebone kernel: [20890.582974] <pru0: 65 6c 65 61 73 69 6e 67 20 74 68 65 20 68 6f 75  eleasing the hou
    Dec 18 09:43:20 beaglebone kernel: [20890.590780] <pru0: 6e 64 73                                         nds
    Dec 18 09:43:20 beaglebone kernel: [20890.597465] <pru0: c1 30 30 30 30 30 30 32 38 20 50 52 55 30 20 52  .00000028 PRU0 R
    Dec 18 09:43:20 beaglebone kernel: [20890.605275] <pru0: 65 6c 65 61 73 69 6e 67 20 74 68 65 20 68 6f 75  eleasing the hou
    Dec 18 09:43:20 beaglebone kernel: [20890.613080] <pru0: 6e 64 73                                         nds

that I barely managed to recover from..  modprobe -r itc_pkt hung, but
eventually I managed to get the pru0 unbind command run --

		echo "4a334000.pru0" > /sys/bus/platform/drivers/pru-rproc/unbind 2>/dev/null

and then things quieted down..[190:

Mon Dec 18 09:51:03 2017 Now, that 28 at the beginning is supposed to
be thread 3's resume address..  But, before we think about anything,
let's get safer fw into position in case we reboot or whatever..[191:

Mon Dec 18 09:58:31 2017 OK now we put a processPacket loop at the end
of startStateMachines and we seem to be alive again..[192:

Mon Dec 18 11:59:06 2017 Well, we finally have a theory good enough to
be worth testing, so setting up to commit and push first again here.

The theory is we were setting up the resume addresses wrong.  Instead
of doing the moral equivalent of this:

	LDI CT.sTH.wRES_ADDR, IdleThreadRunner

the thought is we should be like:

	LDI CT.sTH.wRES_ADDR,$CODE(IdleThreadRunner)

to convert the 'IdleThreadRunner' symbol from a byte address to a word
address.  We Shall See.[193:

Mon Dec 18 12:14:28 2017 And We Are Still Alive!  It looks like we're
actually switching threads!  The 'S' packet header stuff still isn't
working but based on sampling the registers via the kernel debugging
interface, we are actually changing threads while still responding to
packets!

Foggin finally!

Let's make the prudir threads report in every several thousand calls
or so and see what happens.  Any bets?  How many context switches per
second will we be showing?  We have four threads now, and it's still
six instructions or 30ns to switch, all in.  The idle threadrunner
only adds one more instruction to that.  If all four threads were idle
we'd be taking 28 instructions to switch through all of them, which
would mean each guy would get over 7M context switches a second.
200MIPS/28 == 7,142,857..  But we'll start burning that up fast fast
fast.  If each thread did nothing but increment a counter that would
take us down to 6,250,000.  An increment plus quick branch makes
5,555,555.  If the branch hits one in every 65K
calls, and takes perhaps 8K instructions when it hits, that's a
quarter instruction amortized per thread, or one more instruction for
all threads together, and that's 5M.  And that's of course just the
beginning.

Let's call sendval each 10M advances and see if it ever hits![194:

Mon Dec 18 12:56:14 2017 It does!  Lookee:

    [32426.875881] <pru1: c1 30 30 30 30 30 30 30 61 20 50 52 55 31 20 52  .0000000a PRU1 R
    [32426.883762] <pru1: 65 6c 65 61 73 69 6e 67 20 74 68 65 20 68 6f 75  eleasing the hou
    [32426.891576] <pru1: 6e 64 73                                         nds
    [32429.333159] <pru0: c1 30 30 38 30 30 30 30 30 20 50 52 55 30 20 74  .00800000 PRU0 t
    [32429.341055] <pru0: 69 6d 65 72 20                                   imer
    [32429.472276] <pru1: c1 30 30 38 30 30 30 30 30 20 50 52 55 31 20 74  .00800000 PRU1 t
    [32429.480165] <pru1: 69 6d 65 72 20                                   imer
    [32431.933620] <pru0: c1 30 31 30 30 30 30 30 30 20 50 52 55 30 20 74  .01000000 PRU0 t
    [32431.941516] <pru0: 69 6d 65 72 20                                   imer
    [32432.072778] <pru1: c1 30 31 30 30 30 30 30 30 20 50 52 55 31 20 74  .01000000 PRU1 t
    [32432.080672] <pru1: 69 6d 65 72 20                                   imer

That's 0x01000000 - 0x00800000 == 0x00800000 context switches -- say
8M and change -- in 32431.933620-32429.333159 == 2.6 sec.  So with
that minimal load we're at like 3.2M counts/sec with just one thread
counting (I made thread 1, thread 0 & 2 and still idle.)

[195:

Mon Dec 18 13:05:27 2017 Upped it to 25 bits == 32M iterations per
report:

    [32975.202409] <pru1: c1 30 30 30 30 30 30 30 61 20 50 52 55 31 20 52  .0000000a PRU1 R
    [32975.210291] <pru1: 65 6c 65 61 73 69 6e 67 20 74 68 65 20 68 6f 75  eleasing the hou
    [32975.218106] <pru1: 6e 64 73                                         nds
    [32985.466562] <pru0: c1 30 32 30 30 30 30 30 30 20 50 52 55 30 20 74  .02000000 PRU0 t
    [32985.474456] <pru0: 69 6d 65 72 20                                   imer
    [32985.600185] <pru1: c1 30 32 30 30 30 30 30 30 20 50 52 55 31 20 74  .02000000 PRU1 t
    [32985.608072] <pru1: 69 6d 65 72 20                                   imer
    [32995.868439] <pru0: c1 30 34 30 30 30 30 30 30 20 50 52 55 30 20 74  .04000000 PRU0 t
    [32995.876351] <pru0: 69 6d 65 72 20                                   imer
    [32996.002078] <pru1: c1 30 34 30 30 30 30 30 30 20 50 52 55 31 20 74  .04000000 PRU1 t
    [32996.009997] <pru1: 69 6d 65 72 20                                   imer
    [33006.270338] <pru0: c1 30 36 30 30 30 30 30 30 20 50 52 55 30 20 74  .06000000 PRU0 t
    [33006.278245] <pru0: 69 6d 65 72 20                                   imer
    [33006.403961] <pru1: c1 30 36 30 30 30 30 30 30 20 50 52 55 31 20 74  .06000000 PRU1 t
    [33006.411881] <pru1: 69 6d 65 72 20                                   imer

and that's still too often :)..[196:

Mon Dec 18 13:09:52 2017 Went up to 128M iterations per report..  That
should be most of a minute per.   ..Yep.  Committing this.

:196]


:195]


:194]

:193]

:192]

:191]

:190]

:189]

:188]

:187]
[197:

Mon Dec 18 13:12:43 2017 OK, well, it's very close to time to branch
back to other business for a day or so, grr, but what can we claim
here?  Checking..  We can claim 5.1.8![199: Claimed.  Heh, it was
suggesting reporting every 10,000th iteration..

Mon Dec 18 13:24:15 2017 I feel like I want to redo some of the
cleanup that got lost in the weekend disk-creaming event.  Stop the
shouting in the opcodes and labels and such.  Let's try just that,
with no functional changes allowed..[200:

Mon Dec 18 14:18:49 2017 OK, so here are the symbolic 200th note, we
think we've cleaned up prux_sbst3.asm without breaking anything too
horribly.  It could be better but it is much quieter.  Committing.

:200]

:199]

:197]
[201:

Mon Dec 18 14:22:35 2017 OK.  Two more steps

[202: DONE Mon Dec 18 14:26:54 2017   :202] - Get rid of the state_info demo.

[203: DONE Mon Dec 18 14:48:23 2017 Pretty gross and brute force, but,
done and looks right in the 'S' packet returns.. :203] - Extend the initialization to set up the prudir pins as well.

:201]
[204:

Mon Dec 18 14:49:02 2017 OK, committing again.

:204][205:

[211: DONE  :211]Mon Dec 18 14:54:27 2017 OK, let's make a handler that looks for
reports changes on its RX bits, like advanceStateMachine used to do as
a special case.
[206:

Tue Dec 19 00:41:04 2017 Well, took a few tries at that but so far it
hasn't started working.  Committing alleged cleanup in the filenames,
primarily so we'll end up with separate .lst files for the .asm
destined for each PRU.[207:

Tue Dec 19 03:48:17 2017 Foggin finally.  OK, RXWatcherThreadRunner is
finally doing what I asked of it.  Last bug was that OK I was doing
loadBit with a DESTREG of r0.b0, but then was doing the ensuing qbeq
on r0, so garbage in r0.b1-b3 kept the qbeq from ever being true..
Fix is to do the loadBit on r0, or better, do the qbeq on r0.b0.

:207]

:206]
:205]
[212:

Tue Dec 19 04:22:02 2017 OK, so we're finally facing sending some bits
on the wire.  And we're definitely going to need some spiking to get
us through that.  Early goals might be:

[223: DONE Thu Dec 21 18:19:48 2017   :223](5.1.10) Get the interclocking going, with no data at all, and report
         every 'n' shared clocks.

(5.1.11) Get the interclocking handling disconnection and
         reconnection; see the reports stopping and then starting
         again as we pull connectors.

         Draft a flag for clock-live -- even if we don't use it
         internally, because we'll keep track based on execution
         flow?, we should be able to report it asynchronously.

         (We will probably need to use a counter here for timing out;
         could one byte be enough?  Two bytes really ought to be,
         right, even at high clocking speed?  Well, maybe not, if the
         delay is caused by the far side going to linux and we're
         idle, we could easily do many thousands of iterations anyway,
         I'd think.  Might have to be a whole reg.)

(5.1.12) Get the beginnings of bitstuffing going.  When clock-live
         rises (maybe we will use the flags internally, so we can
         'fall towards' communication robustly), we send a minimum of
         14 zeros (countdown counter).  And then for now just start
         sending a single byte over and over, like 0x87 perhaps --
         high order bit set for standard packet, illegal destination.
         Actually I guess it would be better to send 0x80 or 0xff --
         something that would trigger bitstuffing.

         Draft a flag for byte-lock

Again, getting to that would be major.  Then make more spikes.

:212]
[213:

Thu Dec 21 04:16:40 2017 OK, well grades are finally done and we have
a bit of time here.  Although we're going to need to sleep more and
have an early appointment so maybe we can't engage right now.
[214:

Thu Dec 21 10:23:17 2017 So appointments are done but sleep
beckons.. but thinking about 5.1.10 and facing the sync and startup
issue, PRU-style.  Same old issue: Who toggles first?  New twist: We
don't have random numbers here unless we make them or get them from
linux..  Would be nice to have our startup packet from linux give us a
seed maybe.  Could in fact dual purpose some random bytes -- as
additional entropy from linux to the pru, and as a random packet tag
for linux to match against in the returned packet.

Anyway, let's say we have some minimal PRU-PRNG availability.  So when
we enter START_INTERCLOCKING, we do like this:

START_INTERCLOCKING
(1) Set TXRDY low
(2) If RXRDY is high, go to START_OUR_CLOCK
(3) Otherwise, set random timeout
(4) Suspend
(5) Decrement timer.  If expired go to TIMEOUT
(6) If RXRDY is high, go to START_OUR_CLOCK
(7) Goto 4

[215:

Thu Dec 21 10:35:43 2017 You know, any way we do this, we're going to
end up with like a quadrature encoding in the two TXRDY lines -- which
of course and by design is inherently asymmetric.  So we really don't
want to be calling this 'symmetric' bit stream transport.

It's okay, because we can declare that, say, PRU0 toggles first and
PRU1 lags behind, because we have previously ensured that every ITC
connection will go between one PRU0 and one PRU1..  It does make the
transport less 'revolutionary' but that's fundamentally good -- this
was far too low-level to have been at all significantly new.  This is
like some kind of SPI where the 'slave' can stretch the clock.. but we
won't think about it that way..

Oh but wait.  Did we have a thought that we were going to let the
clocking stop when neither side had anything to say?  If so then
either side needs to be able to start the clock, and the symmetry
comes back.  But that seems of extremely limited value.  Once the
clock is stopped both sides are still going to have to watch for an
edge from the other side, so it's not like we save context switches or
anything.

Vs clocking continuously, but with independent byte and packet syncs
going in either direction, so either side can be idle while the other
side is transmitting.  With the point being that if no valid bytes are
being recognized, is 'watching for other side edge' really all that
much faster than 'watching for other side edge then toggling our
edge'?
[216:

Thu Dec 21 14:21:14 2017 If we can do the send and recv fully
independently, except for the shared clock, that could be pretty
cool, and it would partly justify the 'symmetric' name.  We make a
shared clock so either side can initiate a packet regardless of what
the other side is doing..

Well anyway that's pretty far down the road at this point.  Let's just
focus on ticking a shared clock right now.  We'll have per-PRU code
saying whether we are the 'matcher' or the 'mismatcher', and we set
our TXRDY relative to the far side RXRDY according to our role.

That gives us essentially a distributed self-connected NOT gate, and
when both sides are playing their roles, it oscillates: Shared clock.

Do it do it do it.[217:


Thu Dec 21 15:26:35 2017 Well, kind of, to a first approximation:

Did it did it did it.

The match/mismatch framing is so much nicer than the 'who goes first'
framing!  I'm not sure why we're getting double reports, but here's
the first results, with the 'InterClockThreadRunner' running only on
ET (PRU0) and WT (PRU1):

 ..
    [300427.155694] <pru1: c1 30 38 30 30 30 30 30 30 20 50 52 55 31 43 54  .08000000 PRU1CT
    [300427.163757] <pru1: c1 30 38 30 30 30 30 30 30 20 50 52 55 31 43 54  .08000000 PRU1CT
    [300428.355289] <pru0: c1 30 38 30 30 30 30 30 30 20 50 52 55 30 43 54  .08000000 PRU0CT
    [300428.363284] <pru0: c1 30 38 30 30 30 30 30 30 20 50 52 55 30 43 54  .08000000 PRU0CT
    [300479.500649] <pru1: c1 31 30 30 30 30 30 30 30 20 50 52 55 31 43 54  .10000000 PRU1CT
    [300479.508676] <pru1: c1 31 30 30 30 30 30 30 30 20 50 52 55 31 43 54  .10000000 PRU1CT
    [300482.042398] <pru0: c1 31 30 30 30 30 30 30 30 20 50 52 55 30 43 54  .10000000 PRU0CT
    [300482.050397] <pru0: c1 31 30 30 30 30 30 30 30 20 50 52 55 30 43 54  .10000000 PRU0CT
    [300531.845615] <pru1: c1 31 38 30 30 30 30 30 30 20 50 52 55 31 43 54  .18000000 PRU1CT
    [300531.853623] <pru1: c1 31 38 30 30 30 30 30 30 20 50 52 55 31 43 54  .18000000 PRU1CT
    [300535.729541] <pru0: c1 31 38 30 30 30 30 30 30 20 50 52 55 30 43 54  .18000000 PRU0CT
    [300535.737540] <pru0: c1 31 38 30 30 30 30 30 30 20 50 52 55 30 43 54  .18000000 PRU0CT
 ...

So let's see!  I believe we're incrementing on rising clock edges
only, and we're reporting at 24 bit intervals, so that's, what, 134M
clock cycles per report??  And the reports are coming in at like
300535.737540 - 300482.050397 ~ 54 seconds apart?  So we're talking
like almost exactly 2.5MHz in our so-far-single shared clock?  Now,
we're expecting to handle one bit in each direction per shared clock,
so best case we 'could see' 5Mbps total over both directions.

Which is perhaps 312KBps, not taking bit-stuffing into account.  If
that cost at worst perhaps 20% we could still hope for 250KBps
bidirectional.

Which is all neither extremely good nor extremely bad.

But it is, increasingly, extremely real.

[218:

Thu Dec 21 16:25:35 2017 So!  I'm claiming 5.1.10!  Actually first,
let's try interclocking in six directions and see what that timing
looks like.[219:

Thu Dec 21 17:30:28 2017 OK, well, this somehow seems typical of my
PRU efforts here, but now I can't get the damn interclocks to tick
anymore.  Can't even get just the ET-WT pair to do it now; something
has changed and I don't know what.  Been screwing around on this most
of the past hour, I guess.  Getting ready to push this in its busted
state and try a reboot.[220: Thu Dec 21 17:36:06 2017 Wait.. I have
one more idea of a thing to try..[221:

Thu Dec 21 17:49:59 2017 And it wasn't that at all, it was truly and
solely just my shooting myself backwards in the foot head ass hat.
Now we're interclocking in six directions.  And the data looks like

[309808.974628] <pru0: c1 30 66 30 30 30 30 30 30 20 50 52 55 30 43 54  .0f000000 PRU0CT
[309821.098408] <pru1: c1 31 30 30 30 30 30 30 30 20 50 52 55 31 43 54  .10000000 PRU1CT
[309821.106392] <pru1: c1 31 30 30 30 30 30 30 30 20 50 52 55 31 43 54  .10000000 PRU1CT
[309821.114341] <pru1: c1 31 30 30 30 30 30 30 30 20 50 52 55 31 43 54  .10000000 PRU1CT
[309821.122293] <pru0: c1 31 30 30 30 30 30 30 30 20 50 52 55 30 43 54  .10000000 PRU0CT
[309821.130235] <pru0: c1 31 30 30 30 30 30 30 30 20 50 52 55 30 43 54  .10000000 PRU0CT
[309821.138146] <pru0: c1 31 30 30 30 30 30 30 30 20 50 52 55 30 43 54  .10000000 PRU0CT
[309833.261891] <pru1: c1 31 31 30 30 30 30 30 30 20 50 52 55 31 43 54  .11000000 PRU1CT
[309833.269882] <pru1: c1 31 31 30 30 30 30 30 30 20 50 52 55 31 43 54  .11000000 PRU1CT
[309833.277837] <pru1: c1 31 31 30 30 30 30 30 30 20 50 52 55 31 43 54  .11000000 PRU1CT
[309833.285791] <pru0: c1 31 31 30 30 30 30 30 30 20 50 52 55 30 43 54  .11000000 PRU0CT
[309833.293713] <pru0: c1 31 31 30 30 30 30 30 30 20 50 52 55 30 43 54  .11000000 PRU0CT
[309833.301620] <pru0: c1 31 31 30 30 30 30 30 30 20 50 52 55 30 43 54  .11000000 PRU0CT
[309845.889648] <pru1: c1 31 32 30 30 30 30 30 30 20 50 52 55 31 43 54  .12000000 PRU1CT

which means something like

perl -e 'printf("%f\n",1.0*(0x11000000-0x10000000)/(309833.261891 - 309821.098408)/1)'

== 1379310.186076 == 1.38Mbps as raw bits or

perl -e 'printf("%f\n",0.8*(0x11000000-0x10000000)/(309833.261891 - 309821.098408)/8)'

== 137931.018608 == 138KBps as 20% stuffed bytes.

Now, given that UARTs typically claim at least 1.5Mbps, that's not
very encouraging.  And the SFBs defaulted to 115200 baud, which we're
hardly beating, by this estimate.

But again again again: Step by step.  This shid just started working..
We will find moves to make as we gain experience.  Crawl before fly.

Claiming 5.1.10.

[222:

Thu Dec 21 18:19:54 2017 Committing and pushing.

:222]

:221]  :220]

:219]

:218]
:217]

:216]

:215]


:214]
:213]
[224:

Thu Dec 21 18:48:02 2017 OK, so rehacked a little.  New data:

[312777.468324] <pru1: c1 30 33 30 30 30 30 30 30 20 50 52 55 31 43 54  .03000000 PRU1CT
[312788.837094] <pru0: c1 30 34 30 30 30 30 30 30 20 50 52 55 30 43 54  .04000000 PRU0CT<
[312788.845130] <pru0: c1 30 34 30 30 30 30 30 30 20 50 52 55 30 43 54  .04000000 PRU0CT
[312788.853081] <pru0: c1 30 34 30 30 30 30 30 30 20 50 52 55 30 43 54  .04000000 PRU0CT
[312788.861036] <pru1: c1 30 34 30 30 30 30 30 30 20 50 52 55 31 43 54  .04000000 PRU1CT
[312788.868989] <pru1: c1 30 34 30 30 30 30 30 30 20 50 52 55 31 43 54  .04000000 PRU1CT
[312788.876899] <pru1: c1 30 34 30 30 30 30 30 30 20 50 52 55 31 43 54  .04000000 PRU1CT
[312800.252860] <pru1: c1 30 35 30 30 30 30 30 30 20 50 52 55 31 43 54  .05000000 PRU1CT
[312800.260837] <pru1: c1 30 35 30 30 30 30 30 30 20 50 52 55 31 43 54  .05000000 PRU1CT
[312800.268818] <pru1: c1 30 35 30 30 30 30 30 30 20 50 52 55 31 43 54  .05000000 PRU1CT
[312800.276774] <pru0: c1 30 35 30 30 30 30 30 30 20 50 52 55 30 43 54  .05000000 PRU0CT<
[312800.284696] <pru0: c1 30 35 30 30 30 30 30 30 20 50 52 55 30 43 54  .05000000 PRU0CT
[312800.292603] <pru0: c1 30 35 30 30 30 30 30 30 20 50 52 55 30 43 54  .05000000 PRU0CT
[312812.576794] <pru0: c1 30 36 30 30 30 30 30 30 20 50 52 55 30 43 54  .06000000 PRU0CT

perl -e 'printf("%f\n",0.8*(0x05000000-0x04000000)/(312800.276774 - 312788.837094)/8)'

-> 1.46Mbps / 146KBps

which is like a 5+% increase over our 1.38Mbps / 138KBps baseline?

Not huge, and with much hair to add.  But still: Now we crawl faster.

:224]
[225:

Thu Dec 21 19:21:45 2017 Squeezed a little more.  Now the data is:

[314778.479729] <pru1: c1 30 31 30 30 30 30 30 30 20 50 52 55 31 43 54  .01000000 PRU1CT
[314789.531117] <pru0: c1 30 32 30 30 30 30 30 30 20 50 52 55 30 43 54  .02000000 PRU0CT<
[314789.539142] <pru0: c1 30 32 30 30 30 30 30 30 20 50 52 55 30 43 54  .02000000 PRU0CT
[314789.547121] <pru0: c1 30 32 30 30 30 30 30 30 20 50 52 55 30 43 54  .02000000 PRU0CT
[314789.555078] <pru1: c1 30 32 30 30 30 30 30 30 20 50 52 55 31 43 54  .02000000 PRU1CT
[314789.562999] <pru1: c1 30 32 30 30 30 30 30 30 20 50 52 55 31 43 54  .02000000 PRU1CT
[314789.571061] <pru1: c1 30 32 30 30 30 30 30 30 20 50 52 55 31 43 54  .02000000 PRU1CT
[314800.604048] <pru0: c1 30 33 30 30 30 30 30 30 20 50 52 55 30 43 54  .03000000 PRU0CT<
[314800.612041] <pru0: c1 30 33 30 30 30 30 30 30 20 50 52 55 30 43 54  .03000000 PRU0CT
[314800.619992] <pru0: c1 30 33 30 30 30 30 30 30 20 50 52 55 30 43 54  .03000000 PRU0CT

perl -e 'printf("%f\n",0.8*(0x03000000-0x02000000)/(314800.604048 - 314789.531117)/8)'

for 151515.583362 -> 1.5Mbps / 151KBps.  And we have made it to
1.5Mbps, doing nothing six ways (to Sunday).  So there.

:225]
[226:

Thu Dec 21 22:04:34 2017 Squeezed some more.  Now the data is:

[324558.670375] <pru1: c1 30 34 30 30 30 30 30 30 20 50 52 55 31 43 54  .04000000 PRU1CT
[324562.262288] <pru1: c1 30 35 30 30 30 30 30 30 20 50 52 55 31 43 54  .05000000 PRU1CT<
[324564.387400] <pru0: c1 30 35 30 30 30 30 30 30 20 50 52 55 30 43 54  .05000000 PRU0CT
[324566.512565] <pru1: c1 30 35 30 30 30 30 30 30 20 50 52 55 31 43 54  .05000000 PRU1CT
[324566.520626] <pru0: c1 30 35 30 30 30 30 30 30 20 50 52 55 30 43 54  .05000000 PRU0CT
[324566.528592] <pru0: c1 30 35 30 30 30 30 30 30 20 50 52 55 30 43 54  .05000000 PRU0CT
[324566.607363] <pru0: c1 30 35 30 30 30 30 30 30 20 50 52 55 30 43 54  .05000000 PRU0CT
[324566.615412] <pru1: c1 30 35 30 30 30 30 30 30 20 50 52 55 31 43 54  .05000000 PRU1CT
[324568.587078] <pru1: c1 30 36 30 30 30 30 30 30 20 50 52 55 31 43 54  .06000000 PRU1CT<
[324570.743219] <pru0: c1 30 36 30 30 30 30 30 30 20 50 52 55 30 43 54  .06000000 PRU0CT
[324572.899346] <pru1: c1 30 36 30 30 30 30 30 30 20 50 52 55 31 43 54  .06000000 PRU1CT
[324572.907390] <pru0: c1 30 36 30 30 30 30 30 30 20 50 52 55 30 43 54  .06000000 PRU0CT
[324572.982702] <pru0: c1 30 36 30 30 30 30 30 30 20 50 52 55 30 43 54  .06000000 PRU0CT
[324572.990759] <pru1: c1 30 36 30 30 30 30 30 30 20 50 52 55 31 43 54  .06000000 PRU1CT
[324574.962419] <pru1: c1 30 37 30 30 30 30 30 30 20 50 52 55 31 43 54  .07000000 PRU1CT

perl -e 'printf("%f\n",0.8*(0x06000000-0x05000000)/(324568.587078 - 324562.262288)/8)'

for 265261.233970 -> 2.65Mbps / 265KBps.  Which is like wow! :)  Is
that like a 75% improvement or something?  Main trick is to not bother
saving the current thread if we can know that nothing has changed.
Seems to help a lot![227:

Thu Dec 21 22:12:33 2017 Reducing the report frequency..  Shouldn't
change things much, but still..

OK, now the data is:

[325043.913303] <pru0: c1 30 34 30 30 30 30 30 30 20 50 52 55 30 43 54  .04000000 PRU0CT
[325052.397665] <pru1: c1 30 38 30 30 30 30 30 30 20 50 52 55 31 43 54  .08000000 PRU1CT<
[325059.108561] <pru0: c1 30 38 30 30 30 30 30 30 20 50 52 55 30 43 54  .08000000 PRU0CT
[325067.609109] <pru1: c1 30 38 30 30 30 30 30 30 20 50 52 55 31 43 54  .08000000 PRU1CT
[325067.617136] <pru1: c1 30 38 30 30 30 30 30 30 20 50 52 55 31 43 54  .08000000 PRU1CT
[325067.625127] <pru0: c1 30 38 30 30 30 30 30 30 20 50 52 55 30 43 54  .08000000 PRU0CT
[325072.834299] <pru0: c1 30 38 30 30 30 30 30 30 20 50 52 55 30 43 54  .08000000 PRU0CT
[325081.776471] <pru1: c1 30 63 30 30 30 30 30 30 20 50 52 55 31 43 54  .0c000000 PRU1CT<

perl -e 'printf("%f\n",0.8*(0x0c000000-0x08000000)/(325081.776471 - 325052.397665)/8)'

for 228426.110986 -> hmm worse?  Is my data collection wrong?  Let's
get a longer sample..

 [325153.031859] <pru0: c1 31 38 30 30 30 30 30 30 20 50 52 55 30 43 54  .18000000 PRU0CT
 [325169.139223] <pru0: c1 31 34 30 30 30 30 30 30 20 50 52 55 30 43 54  .14000000 PRU0CT
 [325175.268288] <pru1: c1 31 38 30 30 30 30 30 30 20 50 52 55 31 43 54  .18000000 PRU1CT
 [325175.276271] <pru1: c1 31 38 30 30 30 30 30 30 20 50 52 55 31 43 54  .18000000 PRU1CT
 [325175.284305] <pru0: c1 31 38 30 30 30 30 30 30 20 50 52 55 30 43 54  .18000000 PRU0CT
 [325176.110902] <pru1: c1 31 63 30 30 30 30 30 30 20 50 52 55 31 43 54  .1c000000 PRU1CT
 [325178.596986] <pru0: c1 31 63 30 30 30 30 30 30 20 50 52 55 30 43 54  .1c000000 PRU0CT
 [325195.915499] <pru0: c1 31 38 30 30 30 30 30 30 20 50 52 55 30 43 54  .18000000 PRU0CT
 [325199.951732] <pru1: c1 32 30 30 30 30 30 30 30 20 50 52 55 31 43 54  .20000000 PRU1CT
 [325201.334526] <pru0: c1 31 63 30 30 30 30 30 30 20 50 52 55 30 43 54  .1c000000 PRU0CT
 [325203.203624] <pru0: c1 32 30 30 30 30 30 30 30 20 50 52 55 30 43 54  .20000000 PRU0CT
 [325203.338682] <pru1: c1 31 63 30 30 30 30 30 30 20 50 52 55 31 43 54  .1c000000 PRU1CT
 [325203.346667] <pru1: c1 31 63 30 30 30 30 30 30 20 50 52 55 31 43 54  .1c000000 PRU1CT
 [325223.922173] <pru0: c1 31 63 30 30 30 30 30 30 20 50 52 55 30 43 54  .1c000000 PRU0CT
 [325224.021513] <pru1: c1 32 34 30 30 30 30 30 30 20 50 52 55 31 43 54  .24000000 PRU1CT
 [325227.670999] <pru0: c1 32 30 30 30 30 30 30 30 20 50 52 55 30 43 54  .20000000 PRU0CT
 [325228.689948] <pru0: c1 32 34 30 30 30 30 30 30 20 50 52 55 30 43 54  .24000000 PRU0CT
 [325228.882179] <pru1: c1 32 30 30 30 30 30 30 30 20 50 52 55 31 43 54  .20000000 PRU1CT

HMM!  They're getting significantly out of whack with each other?
Could this possibly be signal quality problems?  Or anisotropics from
non-randomized thread iteration?

We need to get the directions output here.  Let's do some code for
that.

Thu Dec 21 23:46:29 2017 It was a stupid braino, where I loaded the
next thread but didn't jump to it, so the threads got fogged up in
each other's code.  Now the data looks like:

[330626.999364] <pru1: c1 31 4e 45 3a 30 38 30 30 30 30 30 30 20 43 54  .1NE:08000000 CT
[330672.593696] <pru0: c1 30 53 57 3a 30 63 30 30 30 30 30 30 20 43 54  .0SW:0c000000 CT<
[330672.601711] <pru0: c1 30 45 54 3a 30 63 30 30 30 30 30 30 20 43 54  .0ET:0c000000 CT
[330672.609672] <pru0: c1 30 53 45 3a 30 63 30 30 30 30 30 30 20 43 54  .0SE:0c000000 CT
[330672.617656] <pru1: c1 31 57 54 3a 30 63 30 30 30 30 30 30 20 43 54  .1WT:0c000000 CT
[330672.625588] <pru1: c1 31 4e 57 3a 30 63 30 30 30 30 30 30 20 43 54  .1NW:0c000000 CT
[330672.633498] <pru1: c1 31 4e 45 3a 30 63 30 30 30 30 30 30 20 43 54  .1NE:0c000000 CT
[330718.227809] <pru0: c1 30 53 57 3a 31 30 30 30 30 30 30 30 20 43 54  .0SW:10000000 CT<

perl -e 'printf("%f\n",0.8*(0x10000000-0x0c000000)/(330718.227809 - 330672.593696)/8)'

for 147058.548065 -> 1.47Mbps / 147KBps.. much worse?  Was my alleged
75% improvement just BS?
[228:

Fri Dec 22 00:08:00 2017 Another code rearrangement.  Data is:

[331866.962677] <pru0: c1 30 53 57 3a 30 34 30 30 30 30 30 30 20 43 54  .0SW:04000000 CT
[331913.563691] <pru1: c1 31 57 54 3a 30 38 30 30 30 30 30 30 20 43 54  .1WT:08000000 CT<
[331913.571702] <pru1: c1 31 4e 57 3a 30 38 30 30 30 30 30 30 20 43 54  .1NW:08000000 CT
[331913.579659] <pru1: c1 31 4e 45 3a 30 38 30 30 30 30 30 30 20 43 54  .1NE:08000000 CT
[331913.587648] <pru0: c1 30 45 54 3a 30 38 30 30 30 30 30 30 20 43 54  .0ET:08000000 CT
[331913.595571] <pru0: c1 30 53 45 3a 30 38 30 30 30 30 30 30 20 43 54  .0SE:08000000 CT
[331913.603479] <pru0: c1 30 53 57 3a 30 38 30 30 30 30 30 30 20 43 54  .0SW:08000000 CT
[331960.204385] <pru1: c1 31 57 54 3a 30 63 30 30 30 30 30 30 20 43 54  .1WT:0c000000 CT<
[331960.212369] <pru1: c1 31 4e 57 3a 30 63 30 30 30 30 30 30 20 43 54  .1NW:0c000000 CT
[331960.220342] <pru1: c1 31 4e 45 3a 30 63 30 30 30 30 30 30 20 43 54  .1NE:0c000000 CT

perl -e 'printf("%f\n",0.8*(0x0c000000-0x08000000)/(331960.204385 - 331913.563691)/8)'

for 143884.788678 -> 1.43Mbps even slightly worse yet!  What am I doing wrong here?
[229:

Fri Dec 22 00:50:01 2017 Another try.  Don't context switch until we
'have to', more or less.  Data is:

[334406.392439] <pru1: c1 31 4e 45 3a 30 34 30 30 30 30 30 30 20 43 54  .1NE:04000000 CT
[334457.691558] <pru1: c1 31 57 54 3a 30 38 30 30 30 30 30 30 20 43 54  .1WT:08000000 CT<
[334457.699601] <pru1: c1 31 4e 57 3a 30 38 30 30 30 30 30 30 20 43 54  .1NW:08000000 CT
[334457.707566] <pru1: c1 31 4e 45 3a 30 38 30 30 30 30 30 30 20 43 54  .1NE:08000000 CT
[334457.715519] <pru0: c1 30 45 54 3a 30 38 30 30 30 30 30 30 20 43 54  .0ET:08000000 CT
[334457.723440] <pru0: c1 30 53 45 3a 30 38 30 30 30 30 30 30 20 43 54  .0SE:08000000 CT
[334457.731346] <pru0: c1 30 53 57 3a 30 38 30 30 30 30 30 30 20 43 54  .0SW:08000000 CT
[334507.388464] <pru1: c1 31 57 54 3a 30 63 30 30 30 30 30 30 20 43 54  .1WT:0c000000 CT<
[334507.396459] <pru1: c1 31 4e 57 3a 30 63 30 30 30 30 30 30 20 43 54  .1NW:0c000000 CT

perl -e 'printf("%f\n",0.8*(0x0c000000-0x08000000)/(334507.388464 - 334457.691558)/8)'
for 135036.301857 -> 1.35Mbps and again yet worse, of course..

:229]
:228]

:227]

:226]

currently committed

[335477.558944] <pru0: c1 30 63 30 30 30 30 30 30 20 50 52 55 30 43 54  .0c000000 PRU0CT
[335530.738134] <pru0: c1 31 30 30 30 30 30 30 30 20 50 52 55 30 43 54  .10000000 PRU0CT<
[335530.746100] <pru0: c1 31 30 30 30 30 30 30 30 20 50 52 55 30 43 54  .10000000 PRU0CT
[335530.754054] <pru0: c1 31 30 30 30 30 30 30 30 20 50 52 55 30 43 54  .10000000 PRU0CT
[335530.762024] <pru1: c1 31 30 30 30 30 30 30 30 20 50 52 55 31 43 54  .10000000 PRU1CT
[335530.769959] <pru1: c1 31 30 30 30 30 30 30 30 20 50 52 55 31 43 54  .10000000 PRU1CT
[335530.777870] <pru1: c1 31 30 30 30 30 30 30 30 20 50 52 55 31 43 54  .10000000 PRU1CT
[335579.392002] <pru1: c1 31 34 30 30 30 30 30 30 20 50 52 55 31 43 54  .14000000 PRU1CT<

1379312.000435


alternative 1:

[335940.559808] <pru0: c1 30 38 30 30 30 30 30 30 20 50 52 55 30 43 54  .08000000 PRU0CT
[335992.143655] <pru1: c1 30 63 30 30 30 30 30 30 20 50 52 55 31 43 54  .0c000000 PRU1CT<
[335992.151659] <pru1: c1 30 63 30 30 30 30 30 30 20 50 52 55 31 43 54  .0c000000 PRU1CT
[335992.159609] <pru1: c1 30 63 30 30 30 30 30 30 20 50 52 55 31 43 54  .0c000000 PRU1CT
[335992.167584] <pru0: c1 30 63 30 30 30 30 30 30 20 50 52 55 30 43 54  .0c000000 PRU0CT
[335992.175508] <pru0: c1 30 63 30 30 30 30 30 30 20 50 52 55 30 43 54  .0c000000 PRU0CT
[335992.183414] <pru0: c1 30 63 30 30 30 30 30 30 20 50 52 55 30 43 54  .0c000000 PRU0CT
[336042.085575] <pru1: c1 31 30 30 30 30 30 30 30 20 50 52 55 31 43 54  .10000000 PRU1CT<

1343738.166255

[336621.250908] <pru1: c1 31 4e 45 3a 30 32 30 30 30 30 30 30 20 43 54  .1NE:02000000 CT
[336644.323608] <pru0: c1 30 45 54 3a 30 34 30 30 30 30 30 30 20 43 54  .0ET:04000000 CT<
[336644.331607] <pru0: c1 30 53 57 3a 30 34 30 30 30 30 30 30 20 43 54  .0SW:04000000 CT
[336644.339601] <pru0: c1 30 53 45 3a 30 34 30 30 30 30 30 30 20 43 54  .0SE:04000000 CT
[336644.347558] <pru1: c1 31 57 54 3a 30 34 30 30 30 30 30 30 20 43 54  .1WT:04000000 CT
[336644.355478] <pru1: c1 31 4e 57 3a 30 34 30 30 30 30 30 30 20 43 54  .1NW:04000000 CT
[336644.363386] <pru1: c1 31 4e 45 3a 30 34 30 30 30 30 30 30 20 43 54  .1NE:04000000 CT
[336668.124497] <pru0: c1 30 45 54 3a 30 36 30 30 30 30 30 30 20 43 54  .0ET:06000000 CT<

1409797.423953

So, interesting.  The idea of trying to avoid context-switching as
much as possible, in the current scheme of things, was actually making
things worse.  I just went back to one forced switch per clock cycle
(after the rising edge), and performance went up, say 1379312 ->
1409797.[230:

Fri Dec 22 01:37:01 2017 Trying a forced context switch after each
edge..

[337323.801841] <pru1: c1 31 57 54 3a 30 34 30 30 30 30 30 30 20 43 54  .1WT:04000000 CT
[337346.601893] <pru0: c1 30 53 45 3a 30 36 30 30 30 30 30 30 20 43 54  .0SE:06000000 CT<
[337346.609889] <pru0: c1 30 53 57 3a 30 36 30 30 30 30 30 30 20 43 54  .0SW:06000000 CT
[337346.617842] <pru0: c1 30 45 54 3a 30 36 30 30 30 30 30 30 20 43 54  .0ET:06000000 CT
[337346.625842] <pru1: c1 31 4e 57 3a 30 36 30 30 30 30 30 30 20 43 54  .1NW:06000000 CT
[337346.633768] <pru1: c1 31 4e 45 3a 30 36 30 30 30 30 30 30 20 43 54  .1NE:06000000 CT
[337346.641676] <pru1: c1 31 57 54 3a 30 36 30 30 30 30 30 30 20 43 54  .1WT:06000000 CT
[337369.081572] <pru0: c1 30 53 45 3a 30 38 30 30 30 30 30 30 20 43 54  .0SE:08000000 CT<
[337369.089598] <pru0: c1 30 53 57 3a 30 38 30 30 30 30 30 30 20 43 54  .0SW:08000000 CT

1492656.189620

and that is better still.  So that's likely how we got to 1.5Mbps, and
then lost it looking for further improvements by trying to avoid
context switching..
[231:

Fri Dec 22 01:46:52 2017 Reorging the code a little for symmetry; see
if we break it again.

[337906.347422] <pru1: c1 31 4e 45 3a 30 32 30 30 30 30 30 30 20 43 54  .1NE:02000000 CT
[337929.273496] <pru0: c1 30 45 54 3a 30 34 30 30 30 30 30 30 20 43 54  .0ET:04000000 CT<
[337929.281498] <pru0: c1 30 53 57 3a 30 34 30 30 30 30 30 30 20 43 54  .0SW:04000000 CT
[337929.289480] <pru0: c1 30 53 45 3a 30 34 30 30 30 30 30 30 20 43 54  .0SE:04000000 CT
[337929.297436] <pru1: c1 31 57 54 3a 30 34 30 30 30 30 30 30 20 43 54  .1WT:04000000 CT
[337929.305374] <pru1: c1 31 4e 57 3a 30 34 30 30 30 30 30 30 20 43 54  .1NW:04000000 CT
[337929.313284] <pru1: c1 31 4e 45 3a 30 34 30 30 30 30 30 30 20 43 54  .1NE:04000000 CT
[337952.153011] <pru0: c1 30 45 54 3a 30 36 30 30 30 30 30 30 20 43 54  .0ET:06000000 CT<
[337952.161043] <pru0: c1 30 53 57 3a 30 36 30 30 30 30 30 30 20 43 54  .0SW:06000000 CT

perl -e 'printf("%f\n",(0x06000000-0x04000000)/(337952.153011 - 337929.273496))'
1466570.947852

..yep it appears we do, slightly..

[232:

Fri Dec 22 02:03:55 2017 OK, keeping the two switches but splitting
them into saveResumePoint + resumeNextThread calls.  Data is:

[338879.912611] <pru1: c1 31 4e 45 3a 30 34 30 30 30 30 30 30 20 43 54  .1NE:04000000 CT
[338902.689905] <pru0: c1 30 53 45 3a 30 36 30 30 30 30 30 30 20 43 54  .0SE:06000000 CT<
[338902.697917] <pru0: c1 30 53 57 3a 30 36 30 30 30 30 30 30 20 43 54  .0SW:06000000 CT
[338902.705893] <pru0: c1 30 45 54 3a 30 36 30 30 30 30 30 30 20 43 54  .0ET:06000000 CT
[338902.713849] <pru1: c1 31 57 54 3a 30 36 30 30 30 30 30 30 20 43 54  .1WT:06000000 CT
[338902.721768] <pru1: c1 31 4e 57 3a 30 36 30 30 30 30 30 30 20 43 54  .1NW:06000000 CT
[338902.729675] <pru1: c1 31 4e 45 3a 30 36 30 30 30 30 30 30 20 43 54  .1NE:06000000 CT
[338925.506969] <pru0: c1 30 53 45 3a 30 38 30 30 30 30 30 30 20 43 54  .0SE:08000000 CT<
[338925.515017] <pru0: c1 30 53 57 3a 30 38 30 30 30 30 30 30 20 43 54  .0SW:08000000 CT

perl -e 'printf("%f\n",(0x08000000-0x06000000)/(338925.506969 - 338902.689905))'
1470584.997263

and that's slightly worse too.  Wild.[233:

Fri Dec 22 02:12:51 2017 Well, committing this version anyway.  It's
easy enough to roll back to just suspendThread in the loops, and I'd
rather have an example of the more complicated arrangement in the
repo.  And all of this is going to change instantly and repeatedly as
development continues!  It's totally self-indulgent to be screwing
around optimizing this!  ("But I'm learning the affordances of this
new landscape!", I cry.  "Yeah except you learned all these
'affordances' two hours ago and yet Here You Remain!", I snarl back.)

:233]

:232]
:231]
:230]
[234:

Fri Dec 22 02:22:22 2017 (And ah, it was using 'resumeAgain' instead
of 'suspendThread' in the Linux runner that pushed us over 1.5Mbps:

[339881.507924] <pru1: c1 31 4e 45 3a 30 32 30 30 30 30 30 30 20 43 54  .1NE:02000000 CT
[339903.614115] <pru1: c1 31 57 54 3a 30 34 30 30 30 30 30 30 20 43 54  .1WT:04000000 CT<
[339903.622150] <pru1: c1 31 4e 57 3a 30 34 30 30 30 30 30 30 20 43 54  .1NW:04000000 CT
[339903.630099] <pru1: c1 31 4e 45 3a 30 34 30 30 30 30 30 30 20 43 54  .1NE:04000000 CT
[339903.638051] <pru0: c1 30 45 54 3a 30 34 30 30 30 30 30 30 20 43 54  .0ET:04000000 CT
[339903.645972] <pru0: c1 30 53 45 3a 30 34 30 30 30 30 30 30 20 43 54  .0SE:04000000 CT
[339903.653878] <pru0: c1 30 53 57 3a 30 34 30 30 30 30 30 30 20 43 54  .0SW:04000000 CT
[339925.760182] <pru1: c1 31 57 54 3a 30 36 30 30 30 30 30 30 20 43 54  .1WT:06000000 CT<
[339925.768165] <pru1: c1 31 4e 57 3a 30 36 30 30 30 30 30 30 20 43 54  .1NW:06000000 CT
perl -e 'printf("%f\n",(0x06000000-0x04000000)/(339925.760182 - 339903.614115))'

1515141.808250 -> 1.51Mbps / 151KBps x 6..

OK.  It's still just a start, but I feel better.)

:234][235:

Fri Dec 22 13:28:09 2017 OK well 'The Last Jedi' did have some
problems but overall it went okay enough, with recliners and popcorn.

So, more data:

[379946.540451] <pru0: c1 30 53 57 3a 30 34 30 30 30 30 30 30 20 43 54  .0SW:04000000 CT
[379967.975509] <pru1: c1 31 57 54 3a 30 36 30 30 30 30 30 30 20 43 54  .1WT:06000000 CT<
[379967.983491] <pru1: c1 31 4e 57 3a 30 36 30 30 30 30 30 30 20 43 54  .1NW:06000000 CT
[379967.991474] <pru1: c1 31 4e 45 3a 30 36 30 30 30 30 30 30 20 43 54  .1NE:06000000 CT
[379967.999433] <pru0: c1 30 45 54 3a 30 36 30 30 30 30 30 30 20 43 54  .0ET:06000000 CT
[379968.007353] <pru0: c1 30 53 45 3a 30 36 30 30 30 30 30 30 20 43 54  .0SE:06000000 CT
[379968.015261] <pru0: c1 30 53 57 3a 30 36 30 30 30 30 30 30 20 43 54  .0SW:06000000 CT
[379989.450391] <pru1: c1 31 57 54 3a 30 38 30 30 30 30 30 30 20 43 54  .1WT:08000000 CT<
[379989.458382] <pru1: c1 31 4e 57 3a 30 38 30 30 30 30 30 30 20 43 54  .1NW:08000000 CT

perl -e 'printf("%f\n",(0x08000000-0x06000000)/(379989.450391 - 379967.975509))'
1562496.687990 -> 1.56Mbps / 156KBps.

Once again that was by shaving instructions in the linux thread.
After moving the flag later today we'll figure out how to migrate the
main if-condition from processPackets into asm and save a bunch more
instructions that way.

:235][236:

Fri Dec 22 14:10:47 2017 Also tried pulling cables as an experiment.
Data is:

x 4
[380462.187524] <pru0: c1 30 53 45 3a 33 34 30 30 30 30 30 30 20 43 54  .0SE:34000000 CT
[380465.817597] <pru1: c1 31 4e 45 3a 33 32 30 30 30 30 30 30 20 43 54  .1NE:32000000 CT<
[380465.825678] <pru0: c1 30 53 57 3a 33 32 30 30 30 30 30 30 20 43 54  .0SW:32000000 CT
[380481.641091] <pru1: c1 31 4e 57 3a 33 36 30 30 30 30 30 30 20 43 54  .1NW:36000000 CT
[380481.649130] <pru0: c1 30 53 45 3a 33 36 30 30 30 30 30 30 20 43 54  .0SE:36000000 CT
[380485.279208] <pru1: c1 31 4e 45 3a 33 34 30 30 30 30 30 30 20 43 54  .1NE:34000000 CT<
[380485.287278] <pru0: c1 30 53 57 3a 33 34 30 30 30 30 30 30 20 43 54  .0SW:34000000 CT

perl -e 'printf("%f\n",(0x34000000-0x32000000)/(380485.279208 - 380465.817597))'
1724134.348384 -> 1.72Mbps / 172KBps

x 2
[382290.649347] <pru0: c1 30 53 45 3a 65 61 30 30 30 30 30 30 20 43 54  .0SE:ea000000 CT
[382309.004761] <pru1: c1 31 4e 57 3a 65 63 30 30 30 30 30 30 20 43 54  .1NW:ec000000 CT<
[382309.012822] <pru0: c1 30 53 45 3a 65 63 30 30 30 30 30 30 20 43 54  .0SE:ec000000 CT
[382326.453077] <pru1: c1 31 4e 57 3a 65 65 30 30 30 30 30 30 20 43 54  .1NW:ee000000 CT<
[382326.461111] <pru0: c1 30 53 45 3a 65 65 30 30 30 30 30 30 20 43 54  .0SE:ee000000 CT

perl -e 'printf("%f\n",(0xee000000-0xec000000)/(382326.453077 - 382309.004761))'
1923075.671028 -> 1.92Mbps / 192KBps

and of course we can't test odd numbers using cross-connections.

:236]
[237:

Sat Dec 23 02:22:21 2017 OK, let's try to speed up the linux thread a
bit more by doing the register checking stuff in asm, and then get
serious about trying to send a byte or something.
[238:

Sat Dec 23 04:19:58 2017 OK, new data:

[   61.083383] <pru0: c1 30 53 57 3a 30 32 30 30 30 30 30 30 20 43 54  .0SW:02000000 CT
[   74.130261] <pru1: c1 31 57 54 3a 30 34 30 30 30 30 30 30 20 43 54  .1WT:04000000 CT<
[   74.138170] <pru1: c1 31 4e 57 3a 30 34 30 30 30 30 30 30 20 43 54  .1NW:04000000 CT
[   74.146082] <pru1: c1 31 4e 45 3a 30 34 30 30 30 30 30 30 20 43 54  .1NE:04000000 CT
[   74.153954] <pru0: c1 30 45 54 3a 30 34 30 30 30 30 30 30 20 43 54  .0ET:04000000 CT
[   74.161804] <pru0: c1 30 53 45 3a 30 34 30 30 30 30 30 30 20 43 54  .0SE:04000000 CT
[   74.169643] <pru0: c1 30 53 57 3a 30 34 30 30 30 30 30 30 20 43 54  .0SW:04000000 CT
[   87.216514] <pru1: c1 31 57 54 3a 30 36 30 30 30 30 30 30 20 43 54  .1WT:06000000 CT<
[   87.224457] <pru1: c1 31 4e 57 3a 30 36 30 30 30 30 30 30 20 43 54  .1NW:06000000 CT

perl -e 'printf("%f\n",(0x06000000-0x04000000)/(87.216514 - 74.130261))'
2564097.759687 -> 2.56Mbps / 256KBps

Yowza.  Now we're getting closer to clock speeds we could stand to
degrade with some functionality!

[  461.053617] <pru1: c1 31 4e 45 3a 30 34 30 30 30 30 30 30 20 43 54  .1NE:04000000 CT
[  487.186766] <pru0: c1 30 45 54 3a 30 38 30 30 30 30 30 30 20 43 54  .0ET:08000000 CT<
[  487.194682] <pru0: c1 30 53 45 3a 30 38 30 30 30 30 30 30 20 43 54  .0SE:08000000 CT
[  487.202550] <pru0: c1 30 53 57 3a 30 38 30 30 30 30 30 30 20 43 54  .0SW:08000000 CT
[  487.210421] <pru1: c1 31 57 54 3a 30 38 30 30 30 30 30 30 20 43 54  .1WT:08000000 CT
[  487.218254] <pru1: c1 31 4e 57 3a 30 38 30 30 30 30 30 30 20 43 54  .1NW:08000000 CT
[  487.226076] <pru1: c1 31 4e 45 3a 30 38 30 30 30 30 30 30 20 43 54  .1NE:08000000 CT
[  513.359258] <pru0: c1 30 45 54 3a 30 63 30 30 30 30 30 30 20 43 54  .0ET:0c000000 CT<
[  513.367169] <pru0: c1 30 53 45 3a 30 63 30 30 30 30 30 30 20 43 54  .0SE:0c000000 CT

perl -e 'printf("%f\n",(0x0c000000-0x08000000)/(513.359258 - 487.186766))'
2564099.131256

..yep.

:238]
:237]
[239:

Sat Dec 23 04:31:03 2017 If we get a clock-live flag bit going, could
we save any time on clock-dead threads?  Unless we change the thread
linking on dead/live, it's hard to see how -- given an unchanging
clock input, the existing loop is 'jmp to resumeNextThread'.

How hard would changing the thread iteration be?  It would be a pain
at our current level of understanding and code maturity, for an at
best uncertain win -- especially given that we'd have to check back in
on dead threads reasonably regularly to see if they'd awakened.

Hey what if we brought forward all the input bit changes we were
waiting for -- across all the threads -- and did some parallel xor-ish
op on r31 and then did left-most bit detect on the result?  That ought
to allow us to skip even resuming threads that will still just be
waiting anyway.

We could have a mask of (up to) the three RXRDY bits, and a register
of the current values of each of those bits as last seen by the
thread.  Each thread sets its mask bit and prior value when beginning
to wait on an input change, and then we do like

l1: and r1, r31, watchedbits
    xor r0, r1, priorvalues
    lmbd r0, r0, 1
    qbeq l1, r0, 32
    ..something happened..

which gets us idle checks across the threads every 20ns, which is
faster than even a single context-switch.

And if the fucking host interrupt was actually reliable, then the
linux thread could go in there too.

Or we could do it like this:

l1: loop l2, 256
    and r1, r31, watchedbits
    xor r0, r1, priorvalues
    lmbd r0, r0, 1
    qbne l3, r0, 32  ; jmp if something happened
l2: ;; here on loop done
    ;; check cycle counter, any other time-based crap
    jmp l1   ; and reenter wait loop

l3: ..deal with stuff..
    jmp l1

which is also four cycles around the loop, but unlike the first
approach this lets us time out of the loop and do other stuff.

I'm concerned by the hard-to-eliminate anisotropy of lmbd, but we
ought to be able to ameliorate that somehow outside the main loop.
[240:

Sat Dec 23 05:19:55 2017 Anyway, that would take a bunch of work but I
think it could be made to work.. but let's not do it now.  Let's
figure a way to send a fogging bit, now.
[241:

Sat Dec 23 05:37:56 2017 OK, a bitstuffing plan.  'Normal' bitstuffing
happens after 5 one-bits, but that's at least in part to facilitate
clock recovery on a single line, and we don't need that.  If we
increase the 'stuff count' we can reduce the overhead, but increase
the size of the escape codes..  So maybe not worth it, if we want to
keep one byte packet delimiters.

Our thought was to stuff 1s rather than 0s, and have packet start
require the leftmost bit to be set.  Let's say stuff after the seventh
0, and if we see eight or more 0s, that's a packet delimiter and we
reestablish byte-sync and start a packet on the next 1 bit.

[242:

Sat Dec 23 05:54:47 2017 Now, how is all this going to interact with
the PRU0/1 MATCH/MISMATCH asymmetry?  We'd like, if we could, to make
sending and receiving be completely independent, so they can be in
different places within their bytes or protocols.

So the basic idea is that when the other side has a rising edge, that
means their TXDAT is also valid and we should process that before
raising our own TXDAT.

  (1) Wait for PRU_COND (TXRDY match (pru0) or mismatch (pru1))
  (2) Capture their TXDAT
  (3) Toggle our TXRDY
  (4) Wait for PRU_COND (TXRDY match (pru0) or mismatch (pru1))
  (5) Prepare our TXDAT
  (6) Toggle our TXRDY
  (7) Go to (1)

or is it

  (1) Wait for PRU_COND (TXRDY match (pru0) or mismatch (pru1))
  (2) Capture their TXDAT
  (3) Prepare our TXDAT
  (4) Toggle our TXRDY
  (5) Go to (1)

which I think means one side does all its work on rising edges and the
other does it all on falling edges?

Tired.[243:

Sat Dec 23 10:47:00 2017 Slept.  Can we express it in terms of high
and low?

  (0) Init: Clear receive sync, prepare to send packet delimiter
  (2) Present next TXDAT
  (1) Set TXRDY=0
  (3) Wait for RXDAT_VALID (RXRDY low (pru0) or high (pru1))
  (5) Capture and process their RXDAT
  (4) Set TXRDY=1
  (3) Wait for RXDAT_VALID (RXRDY high (pru0) or low (pru1))
  (6) Go to (1)

[244:

Sat Dec 23 16:22:54 2017 Back from Santa work.  This is still very
confusing.  Is it maybe easier to think that we have two phases, a
match phase and a mismatch phase, that both side goes through -- but
pru0 is trying to match on high and pru1 is trying to match on low?

Fog it let's write a perl script to demo our current interclocking
behavior, and then add data to that.  Straight to asm first we don't
need. [245:

Sun Dec 24 03:14:51 2017 Well, so 'interclockdemo10.pl' sent a byte in
both directions without a whole lot of trouble, other than one extra
zero that needs to be discarded at the beginning.  For each pru,
output format is:

 0 0 0 [1010101010][]
  \ \ \      \      \--prux input buffer
   \ \ \      \--------prux output buffer
    \ \ \--------------prux txdat
     \ \---------------prux txrdy
      \----------------prux 'state'

where the 'state' was to distinguish the txrdy low loop from the txrdy
high loop, and thus appears to actually be identical to txrdy..

    root@beaglebone:/home/t2/T2-12# ./pru/itcio/notes/interclockdemo10.pl
    0 0 0 [1010101010][]  1 1 0 [1110001100][0]
    1 1 0 [1010101010][0] 1 1 0 [1110001100][0]
    1 1 0 [1010101010][0] 0 0 1 [110001100][0]
    0 0 1 [010101010][0]  0 0 1 [110001100][0]
    0 0 1 [010101010][0]  1 1 1 [110001100][01]
    1 1 1 [010101010][01] 1 1 1 [110001100][01]
    1 1 1 [010101010][01] 0 0 1 [10001100][01]
    0 0 0 [10101010][01]  0 0 1 [10001100][01]
    0 0 0 [10101010][01]  1 1 1 [10001100][010]
    1 1 0 [10101010][011] 1 1 1 [10001100][010]
    1 1 0 [10101010][011] 0 0 1 [0001100][010]
    0 0 1 [0101010][011]  0 0 1 [0001100][010]
    0 0 1 [0101010][011]  1 1 1 [0001100][0101]
    1 1 1 [0101010][0111] 1 1 1 [0001100][0101]
    1 1 1 [0101010][0111] 0 0 0 [001100][0101]
    0 0 0 [101010][0111]  0 0 0 [001100][0101]
    0 0 0 [101010][0111]  1 1 0 [001100][01010]
    1 1 0 [101010][01110] 1 1 0 [001100][01010]
    1 1 0 [101010][01110] 0 0 0 [01100][01010]
    0 0 1 [01010][01110]  0 0 0 [01100][01010]
    0 0 1 [01010][01110]  1 1 0 [01100][010101]
    1 1 1 [01010][011100] 1 1 0 [01100][010101]
    1 1 1 [01010][011100] 0 0 0 [1100][010101]
    0 0 0 [1010][011100]  0 0 0 [1100][010101]
    0 0 0 [1010][011100]  1 1 0 [1100][0101010]
    1 1 0 [1010][0111000] 1 1 0 [1100][0101010]
    1 1 0 [1010][0111000] 0 0 1 [100][0101010]
    0 0 1 [010][0111000]  0 0 1 [100][0101010]
    0 0 1 [010][0111000]  1 1 1 [100][01010101]
    1 1 1 [010][01110001] 1 1 1 [100][01010101]
    1 1 1 [010][01110001] 0 0 1 [00][01010101]
    0 0 0 [10][01110001]  0 0 1 [00][01010101]
    0 0 0 [10][01110001]  1 1 1 [00][010101010]
    1 1 0 [10][011100011] 1 1 1 [00][010101010]
    1 1 0 [10][011100011] 0 0 0 [0][010101010]
    0 0 1 [0][011100011]  0 0 0 [0][010101010]
    0 0 1 [0][011100011]  1 1 0 [0][0101010101]
    1 1 1 [0][0111000110] 1 1 0 [0][0101010101]
    1 1 1 [0][0111000110] 0 0 0 [][0101010101]
    0 0 0 [][0111000110]  0 0 0 [][0101010101]
    0 0 0 [][0111000110]  1 1 0 [][01010101010]
    1 1 0 [][01110001100] 1 1 0 [][01010101010]
    1 1 0 [][01110001100] 0 0 0 [][01010101010]
    0 0 0 [][01110001100]  0 0 0 [][01010101010]
    0 0 0 [][01110001100]  1 1 0 [][010101010100]
    1 1 0 [][011100011000] 1 1 0 [][010101010100]
    1 1 0 [][011100011000] 0 0 0 [][010101010100]
    0 0 0 [][011100011000]  0 0 0 [][010101010100]
    0 0 0 [][011100011000]  1 1 0 [][0101010101000]
    1 1 0 [][0111000110000] 1 1 0 [][0101010101000]
    1 1 0 [][0111000110000] 0 0 0 [][0101010101000]
    root@beaglebone:/home/t2/T2-12#

where at the end there the input buffers continue to grow after the
output buffers are empty because there's no byte-level operations in
this example..

So, could we translate this to an asm spike?  Nah we really need some
kind of byte-level logic first, I think.  So let's do ordinary
bitstuffing in this demo and then see where we are?[246:

Sun Dec 24 10:09:32 2017 OK, well we're getting there.  Modulo some
bugs yet to be diagnosed, we are sending and receiving packets now,
with packet delimiters and everything.  Extracts from the trace:

    root@beaglebone:/home/t2/T2-12# ./pru/itcio/notes/interclockdemo11.pl
      1 s0 r0 d0 o00000000@8 i00000000@8 [ h ooh][] s1 r1 d0 o00000000@8 i00000000@0 [ zo! norg][]
      2 s1 r1 d0 o00000000@8 i00000000@0 [ h ooh][] s1 r1 d0 o00000000@8 i00000000@0 [ zo! norg][]
      3 s1 r1 d0 o00000000@8 i00000000@0 [ h ooh][] s0 r0 d0 o01111110@1 i00000000@0 [zo! norg][]
      4 s0 r0 d0 o01111110@1 i00000000@0 [h ooh][] s0 r0 d0 o01111110@1 i00000000@0 [zo! norg][]
      5 s0 r0 d0 o01111110@1 i00000000@0 [h ooh][] s1 r1 d0 o01111110@1 i00000000@1 [zo! norg][]
      6 s1 r1 d0 o01111110@1 i00000000@1 [h ooh][] s1 r1 d0 o01111110@1 i00000000@1 [zo! norg][]
 ..
     31 s1 r1 d1 o01111110@7 i00111110@6 [h ooh][] s0 r0 d0 o01111110@8 i00111110@6 [zo! norg][]
     32 s0 r0 d0 o01111110@8 i00111110@6 [h ooh][] s0 r0 d0 o01111110@8 i00111110@6 [zo! norg][]
    pru1: ACHIEVED PACKET SYNC
     33 s0 r0 d0 o01111110@8 i00111110@6 [h ooh][] s1 r1 d0 o01111110@8 i00000000@0 [zo! norg][]
    pru0: ACHIEVED PACKET SYNC
     34 s1 r1 d0 o01111110@8 i00000000@0 [h ooh][] s1 r1 d0 o01111110@8 i00000000@0 [zo! norg][]
     35 s1 r1 d0 o01111110@8 i00000000@0 [h ooh][] s0 r0 d1 o11111111@1 i00000000@0 [zo! norg][]
     36 s0 r0 d0 o01101000@1 i00000000@0 [ ooh][] s0 r0 d1 o11111111@1 i00000000@0 [zo! norg][]
 ..
     95 s1 r1 d1 o01111110@7 i00111010@6 [ooh][] s0 r0 d1 o01111010@7 i00111110@6 [o! norg][h]
     96 s0 r0 d0 o01111110@8 i00111010@6 [ooh][] s0 r0 d1 o01111010@7 i00111110@6 [o! norg][h]
    pru1: RECEIVED PACKET 'h'
     97 s0 r0 d0 o01111110@8 i00111010@6 [ooh][] s1 r1 d1 o01111010@7 i00000000@0 [o! norg][]
     98 s1 r1 d0 o01111110@8 i01111010@7 [ooh][] s1 r1 d1 o01111010@7 i00000000@0 [o! norg][]
     99 s1 r1 d0 o01111110@8 i01111010@7 [ooh][] s0 r0 d0 o01111010@8 i00000000@0 [o! norg][]
    100 s0 r0 d1 o01101111@1 i01111010@7 [oh][] s0 r0 d0 o01111010@8 i00000000@0 [o! norg][]
 ..
    192 s0 r0 d0 o01101000@8 i00011111@5 [][zo!] s0 r0 d1 o01111110@7 i01101000@7 [norg][oo]
    193 s0 r0 d0 o01101000@8 i00011111@5 [][zo!] s1 r1 d1 o01111110@7 i00000000@0 [norg][ooh]
    pru0: HANDLE PACKET FRAMING ERROR
    194 s1 r1 d0 o01101000@8 i00011111@5 [][zo!] s1 r1 d1 o01111110@7 i00000000@0 [norg][ooh]
    195 s1 r1 d0 o01101000@8 i00011111@5 [][zo!] s0 r0 d0 o01111110@8 i00000000@0 [norg][ooh]
    196 s0 r0 d0 o01111110@1 i00011111@5 [][zo!] s0 r0 d0 o01111110@8 i00000000@0 [norg][ooh]
    197 s0 r0 d0 o01111110@1 i00011111@5 [][zo!] s1 r1 d0 o01111110@8 i00000000@1 [norg][ooh]
    pru0: HANDLE PACKET FRAMING ERROR
    198 s1 r1 d0 o01111110@1 i00011111@5 [][zo!] s1 r1 d0 o01111110@8 i00000000@1 [norg][ooh]
    199 s1 r1 d0 o01111110@1 i00011111@5 [][zo!] s0 r0 d0 o01101110@1 i00000000@1 [org][ooh]
    200 s0 r0 d1 o01111110@2 i00011111@5 [][zo!] s0 r0 d0 o01101110@1 i00000000@1 [org][ooh]
 ..
    221 s0 r0 d1 o01111110@7 i00011111@5 [][zo!] s1 r1 d1 o01101110@6 i00111110@6 [org][ooh]
    pru0: HANDLE PACKET FRAMING ERROR
    222 s1 r1 d1 o01111110@7 i00011111@5 [][zo!] s1 r1 d1 o01101110@6 i00111110@6 [org][ooh]
    223 s1 r1 d1 o01111110@7 i00011111@5 [][zo!] s0 r0 d1 o01101110@7 i00111110@6 [org][ooh]
    224 s0 r0 d0 o01111110@8 i00011111@5 [][zo!] s0 r0 d1 o01101110@7 i00111110@6 [org][ooh]
    pru1: RECEIVED PACKET 'ooh'
    225 s0 r0 d0 o01111110@8 i00011111@5 [][zo!] s1 r1 d1 o01101110@7 i00000000@0 [org][]
    pru0: HANDLE PACKET FRAMING ERROR
    226 s1 r1 d0 o01111110@8 i00011111@5 [][zo!] s1 r1 d1 o01101110@7 i00000000@0 [org][]
    227 s1 r1 d0 o01111110@8 i00011111@5 [][zo!] s0 r0 d0 o01101110@8 i00000000@0 [org][]
 ..
    252 s0 r0 d1 o01111110@7 i00011111@5 [][zo!] s0 r0 d1 o01101111@6 i00111110@6 [rg][]
    253 s0 r0 d1 o01111110@7 i00011111@5 [][zo!] s1 r1 d1 o01101111@6 i00111110@6 [rg][]
    pru0: HANDLE PACKET FRAMING ERROR
    254 s1 r1 d1 o01111110@7 i00011111@5 [][zo!] s1 r1 d1 o01101111@6 i00111110@6 [rg][]
    255 s1 r1 d1 o01111110@7 i00011111@5 [][zo!] s0 r0 d1 o01101111@7 i00111110@6 [rg][]
    256 s0 r0 d0 o01111110@8 i00011111@5 [][zo!] s0 r0 d1 o01101111@7 i00111110@6 [rg][]
    pru1: RECEIVED PACKET ''
    257 s0 r0 d0 o01111110@8 i00011111@5 [][zo!] s1 r1 d1 o01101111@7 i00000000@0 [rg][]
    pru0: HANDLE PACKET FRAMING ERROR
    258 s1 r1 d0 o01111110@8 i00011111@5 [][zo!] s1 r1 d1 o01101111@7 i00000000@0 [rg][]
    259 s1 r1 d0 o01111110@8 i00011111@5 [][zo!] s0 r0 d0 o01101111@8 i00000000@0 [rg][]
 ..
    287 s1 r1 d1 o01111110@7 i00011111@5 [][zo!] s0 r0 d1 o01110010@7 i00111110@6 [g][]
    288 s0 r0 d0 o01111110@8 i00011111@5 [][zo!] s0 r0 d1 o01110010@7 i00111110@6 [g][]
    pru1: RECEIVED PACKET ''
    289 s0 r0 d0 o01111110@8 i00011111@5 [][zo!] s1 r1 d1 o01110010@7 i00000000@0 [g][]
    pru0: HANDLE PACKET FRAMING ERROR
    290 s1 r1 d0 o01111110@8 i00011111@5 [][zo!] s1 r1 d1 o01110010@7 i00000000@0 [g][]
    291 s1 r1 d0 o01111110@8 i00011111@5 [][zo!] s0 r0 d0 o01110010@8 i00000000@0 [g][]
    292 s0 r0 d0 o01111110@1 i00011111@5 [][zo!] s0 r0 d0 o01110010@8 i00000000@0 [g][]
    293 s0 r0 d0 o01111110@1 i00011111@5 [][zo!] s1 r1 d0 o01110010@8 i00000000@1 [g][]
    pru0: HANDLE PACKET FRAMING ERROR
    294 s1 r1 d0 o01111110@1 i00011111@5 [][zo!] s1 r1 d0 o01110010@8 i00000000@1 [g][]
    295 s1 r1 d0 o01111110@1 i00011111@5 [][zo!] s0 r0 d1 o01100111@1 i00000000@1 [][]
 ..
    319 s1 r1 d1 o01111110@7 i00011111@5 [][zo!] s0 r0 d1 o01100111@7 i00111110@6 [][]
    320 s0 r0 d0 o01111110@8 i00011111@5 [][zo!] s0 r0 d1 o01100111@7 i00111110@6 [][]
    pru1: RECEIVED PACKET ''
    321 s0 r0 d0 o01111110@8 i00011111@5 [][zo!] s1 r1 d1 o01100111@7 i00000000@0 [][]
    pru0: HANDLE PACKET FRAMING ERROR
    322 s1 r1 d0 o01111110@8 i00011111@5 [][zo!] s1 r1 d1 o01100111@7 i00000000@0 [][]
    323 s1 r1 d0 o01111110@8 i00011111@5 [][zo!] s0 r0 d0 o01100111@8 i00000000@0 [][]
 ..
    351 s1 r1 d1 o01111110@7 i00011111@5 [][zo!] s0 r0 d1 o01111110@7 i00111110@6 [][]
    352 s0 r0 d0 o01111110@8 i00011111@5 [][zo!] s0 r0 d1 o01111110@7 i00111110@6 [][]
    pru1: RECEIVED PACKET ''
    353 s0 r0 d0 o01111110@8 i00011111@5 [][zo!] s1 r1 d1 o01111110@7 i00000000@0 [][]
    pru0: HANDLE PACKET FRAMING ERROR
    354 s1 r1 d0 o01111110@8 i00011111@5 [][zo!] s1 r1 d1 o01111110@7 i00000000@0 [][]
    355 s1 r1 d0 o01111110@8 i00011111@5 [][zo!] s0 r0 d0 o01111110@8 i00000000@0 [][]
 ..
    383 s1 r1 d1 o01111110@7 i00011111@5 [][zo!] s0 r0 d1 o01111110@7 i00111110@6 [][]
    384 s0 r0 d0 o01111110@8 i00011111@5 [][zo!] s0 r0 d1 o01111110@7 i00111110@6 [][]
    pru1: RECEIVED PACKET ''
    385 s0 r0 d0 o01111110@8 i00011111@5 [][zo!] s1 r1 d1 o01111110@7 i00000000@0 [][]
    pru0: HANDLE PACKET FRAMING ERROR
    386 s1 r1 d0 o01111110@8 i00011111@5 [][zo!] s1 r1 d1 o01111110@7 i00000000@0 [][]
    387 s1 r1 d0 o01111110@8 i00011111@5 [][zo!] s0 r0 d0 o01111110@8 i00000000@0 [][]
 ..
    495 s1 r1 d1 o01111110@3 i00011111@5 [][zo!] s0 r0 d1 o01111110@3 i00000110@3 [][]
    root@beaglebone:/home/t2/T2-12#
[247:

Sun Dec 24 11:18:58 2017 OK, got that fixed and now things are looking
plausible.  Annotated extracts from our second generation perl demo
script, showing packet sync, bitstuffing at various points within a
byte, bitstuffing across bytes, transmitting the packet delimiter as
data, and empty packet dropping:

    ./pru/itcio/notes/interclockdemo11.pl
      1 s0 r0 d0 o00000000@8[ h ??] i00000000@8[] s1 r1 d0 o00000000@8[ z!  ~norg] i00000000@0[]

PRU0->PRU1: packet 'h', then packet '\374??'.
PRU1->PRU0: packet'\377z!', then empty packet, then packet '~norg'.
(Note that '~' is 0x7e, which, if sent unstuffed, is the packet delimiter.)
(Note also that using a null byte on input to represent end-of-packet
is just for this demo.  In the real thing we have genuinely OoB packet
framing provided.)

      2 s1 r1 d0 o00000000@8[ h ??] i00000000@0[] s1 r1 d0 o00000000@8[ z!  ~norg] i00000000@0[]
      3 s1 r1 d0 o00000000@8[ h ??] i00000000@0[] s0 r0 d0 o01111110@1[z!  ~norg] i00000000@0[]
      4 s0 r0 d0 o01111110@1[h ??] i00000000@0[] s0 r0 d0 o01111110@1[z!  ~norg] i00000000@0[]
 ..
     31 s1 r1 d1 o01111110@7[h ??] i00111110@6[] s0 r0 d0 o01111110@8[z!  ~norg] i00111110@6[]
     32 s0 r0 d0 o01111110@8[h ??] i00111110@6[] s0 r0 d0 o01111110@8[z!  ~norg] i00111110@6[]
    pru1: ACHIEVED PACKET SYNC
     33 s0 r0 d0 o01111110@8[h ??] i00111110@6[] s1 r1 d0 o01111110@8[z!  ~norg] i00000000@0[]
    pru0: ACHIEVED PACKET SYNC
     34 s1 r1 d0 o01111110@8[h ??] i00000000@0[] s1 r1 d0 o01111110@8[z!  ~norg] i00000000@0[]
     35 s1 r1 d0 o01111110@8[h ??] i00000000@0[] s0 r0 d1 o11111111@1[z!  ~norg] i00000000@0[]
     36 s0 r0 d0 o01101000@1[ ??] i00000000@0[] s0 r0 d1 o11111111@1[z!  ~norg] i00000000@0[]
 ..
     64 s0 r0 d0 o01101000@8[ ??] i00111111@6[] s0 r0 d1 o11111111@7[z!  ~norg] i01101000@7[]
     65 s0 r0 d0 o01101000@8[ ??] i00111111@6[] s1 r1 d1 o11111111@7[z!  ~norg] i00000000@0[h]
                                                                                                  ^^^
PRU1 accepts the 'h'

     66 s1 r1 d0 o01101000@8[ ??] i01111111@7[] s1 r1 d1 o11111111@7[z!  ~norg] i00000000@0[h]
     67 s1 r1 d0 o01101000@8[ ??] i01111111@7[] s0 r0 d1 o11111111@8[z!  ~norg] i00000000@0[h]
     68 s0 r0 d0 o01111110@1[??] i01111111@7[] s0 r0 d1 o11111111@8[z!  ~norg] i00000000@0[h]
                 ^^^^^^^^^^^
PRU0 has set up to send the packet delimiter

     69 s0 r0 d0 o01111110@1[??] i01111111@7[] s1 r1 d1 o11111111@8[z!  ~norg] i00000000@1[h]
     70 s1 r1 d0 o01111110@1[??] i00000000@0[] s1 r1 d1 o11111111@8[z!  ~norg] i00000000@1[h]
     71 s1 r1 d0 o01111110@1[??] i00000000@0[] s0 r0 d0 o01111010@1[!  ~norg] i00000000@1[h]
     72 s0 r0 d1 o01111110@2[??] i00000000@0[] s0 r0 d0 o01111010@1[!  ~norg] i00000000@1[h]
     73 s0 r0 d1 o01111110@2[??] i00000000@0[] s1 r1 d0 o01111010@1[!  ~norg] i00000010@2[h]
     74 s1 r1 d1 o01111110@2[??] i00000000@1[] s1 r1 d0 o01111010@1[!  ~norg] i00000010@2[h]
     75 s1 r1 d1 o01111110@2[??] i00000000@1[] s0 r0 d1 o01111010@2[!  ~norg] i00000010@2[h]
     76 s0 r0 d1 o01111110@3[??] i00000000@1[] s0 r0 d1 o01111010@2[!  ~norg] i00000010@2[h]
     77 s0 r0 d1 o01111110@3[??] i00000000@1[] s1 r1 d1 o01111010@2[!  ~norg] i00000110@3[h]
     78 s1 r1 d1 o01111110@3[??] i00000010@2[] s1 r1 d1 o01111010@2[!  ~norg] i00000110@3[h]
     79 s1 r1 d1 o01111110@3[??] i00000010@2[] s0 r0 d0 o01111010@3[!  ~norg] i00000110@3[h]
     80 s0 r0 d1 o01111110@4[??] i00000010@2[] s0 r0 d0 o01111010@3[!  ~norg] i00000110@3[h]
     81 s0 r0 d1 o01111110@4[??] i00000010@2[] s1 r1 d0 o01111010@3[!  ~norg] i00001110@4[h]
     82 s1 r1 d1 o01111110@4[??] i00000010@3[] s1 r1 d0 o01111010@3[!  ~norg] i00001110@4[h]
     83 s1 r1 d1 o01111110@4[??] i00000010@3[] s0 r0 d1 o01111010@4[!  ~norg] i00001110@4[h]
     84 s0 r0 d1 o01111110@5[??] i00000010@3[] s0 r0 d1 o01111010@4[!  ~norg] i00001110@4[h]
     85 s0 r0 d1 o01111110@5[??] i00000010@3[] s1 r1 d1 o01111010@4[!  ~norg] i00011110@5[h]
     86 s1 r1 d1 o01111110@5[??] i00001010@4[] s1 r1 d1 o01111010@4[!  ~norg] i00011110@5[h]
     87 s1 r1 d1 o01111110@5[??] i00001010@4[] s0 r0 d1 o01111010@5[!  ~norg] i00011110@5[h]
     88 s0 r0 d1 o01111110@6[??] i00001010@4[] s0 r0 d1 o01111010@5[!  ~norg] i00011110@5[h]
     89 s0 r0 d1 o01111110@6[??] i00001010@4[] s1 r1 d1 o01111010@5[!  ~norg] i00111110@6[h]
     90 s1 r1 d1 o01111110@6[??] i00011010@5[] s1 r1 d1 o01111010@5[!  ~norg] i00111110@6[h]
     91 s1 r1 d1 o01111110@6[??] i00011010@5[] s0 r0 d1 o01111010@6[!  ~norg] i00111110@6[h]
     92 s0 r0 d1 o01111110@7[??] i00011010@5[] s0 r0 d1 o01111010@6[!  ~norg] i00111110@6[h]
     93 s0 r0 d1 o01111110@7[??] i00011010@5[] s1 r1 d1 o01111010@6[!  ~norg] i00111110@6[h]
     94 s1 r1 d1 o01111110@7[??] i00111010@6[] s1 r1 d1 o01111010@6[!  ~norg] i00111110@6[h]
     95 s1 r1 d1 o01111110@7[??] i00111010@6[] s0 r0 d1 o01111010@7[!  ~norg] i00111110@6[h]
              ^^
PRU0 has sent the six 1s without stuffing.

     96 s0 r0 d0 o01111110@8[??] i00111010@6[] s0 r0 d1 o01111010@7[!  ~norg] i00111110@6[h]
    pru1: RECEIVED PACKET 'h'
    ^^^^^^^^^^^^^^^^^^^^^^^^^
And the delimiter has been processed on PRU1.

     97 s0 r0 d0 o01111110@8[??] i00111010@6[] s1 r1 d1 o01111010@7[!  ~norg] i00000000@0[]
     98 s1 r1 d0 o01111110@8[??] i01111010@7[] s1 r1 d1 o01111010@7[!  ~norg] i00000000@0[]
     99 s1 r1 d0 o01111110@8[??] i01111010@7[] s0 r0 d0 o01111010@8[!  ~norg] i00000000@0[]
    100 s0 r0 d0 o11111100@1[??] i01111010@7[] s0 r0 d0 o01111010@8[!  ~norg] i00000000@0[]
    101 s0 r0 d0 o11111100@1[??] i01111010@7[] s1 r1 d0 o01111010@8[!  ~norg] i00000000@1[]
    102 s1 r1 d0 o11111100@1[??] i00000000@0[z] s1 r1 d0 o01111010@8[!  ~norg] i00000000@1[]
    103 s1 r1 d0 o11111100@1[??] i00000000@0[z] s0 r0 d1 o00100001@1[  ~norg] i00000000@1[]
 ..
    126 s1 r1 d1 o11111100@7[??] i00100001@6[z] s1 r1 d1 o00100001@6[  ~norg] i01111100@7[]
    127 s1 r1 d1 o11111100@7[??] i00100001@6[z] s0 r0 d0 o00100001@7[  ~norg] i01111100@7[]
    128 s0 r0 d0 o11111100@7[??] i00100001@6[z] s0 r0 d0 o00100001@7[  ~norg] i01111100@7[]
    129 s0 r0 d0 o11111100@7[??] i00100001@6[z] s1 r1 d0 o00100001@7[  ~norg] i01111100@7[]
    130 s1 r1 d0 o11111100@7[??] i00100001@7[z] s1 r1 d0 o00100001@7[  ~norg] i01111100@7[]
    131 s1 r1 d0 o11111100@7[??] i00100001@7[z] s0 r0 d0 o00100001@8[  ~norg] i01111100@7[]
              ^^
PRU0 bitstuffs near end of byte

    132 s0 r0 d1 o11111100@8[??] i00100001@7[z] s0 r0 d0 o00100001@8[  ~norg] i01111100@7[]
    133 s0 r0 d1 o11111100@8[??] i00100001@7[z] s1 r1 d0 o00100001@8[  ~norg] i00000000@0[]
                                                                                               ^^^^^^
PRU1 receives byte okay

    134 s1 r1 d1 o11111100@8[??] i00000000@0[z!] s1 r1 d0 o00100001@8[  ~norg] i00000000@0[]
    135 s1 r1 d1 o11111100@8[??] i00000000@0[z!] s0 r0 d0 o01111110@1[ ~norg] i00000000@0[]
                                                              ^^^^^^^^^^^
PRU1 sets up packet delimiter

    136 s0 r0 d1 o00111111@1[?] i00000000@0[z!] s0 r0 d0 o01111110@1[ ~norg] i00000000@0[]
    137 s0 r0 d1 o00111111@1[?] i00000000@0[z!] s1 r1 d0 o01111110@1[ ~norg] i00000001@1[]
    138 s1 r1 d1 o00111111@1[?] i00000000@1[z!] s1 r1 d0 o01111110@1[ ~norg] i00000001@1[]
 ..
    162 s1 r1 d1 o00111111@6[?] i00111110@6[z!] s1 r1 d1 o01111110@7[ ~norg] i00111111@6[]
    163 s1 r1 d1 o00111111@6[?] i00111110@6[z!] s0 r0 d0 o01111110@8[ ~norg] i00111111@6[]
    164 s0 r0 d0 o00111111@7[?] i00111110@6[z!] s0 r0 d0 o01111110@8[ ~norg] i00111111@6[]
    165 s0 r0 d0 o00111111@7[?] i00111110@6[z!] s1 r1 d0 o01111110@8[ ~norg] i00111111@7[]
    pru0: RECEIVED PACKET 'z!'
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
PRU0 recognizes full packet

    166 s1 r1 d0 o00111111@7[?] i00000000@0[] s1 r1 d0 o01111110@8[ ~norg] i00111111@7[]
    167 s1 r1 d0 o00111111@7[?] i00000000@0[] s0 r0 d0 o01111110@1[~norg] i00111111@7[]
                                                       ^^^^^^^^^^^
PRU1 has set up the packet delimiter again -- an empty packet..

    168 s0 r0 d0 o00111111@8[?] i00000000@0[] s0 r0 d0 o01111110@1[~norg] i00111111@7[]
    169 s0 r0 d0 o00111111@8[?] i00000000@0[] s1 r1 d0 o01111110@1[~norg] i00000000@0[?]
    170 s1 r1 d0 o00111111@8[?] i00000000@1[] s1 r1 d0 o01111110@1[~norg] i00000000@0[?]
    171 s1 r1 d0 o00111111@8[?] i00000000@1[] s0 r0 d1 o01111110@2[~norg] i00000000@0[?]
    172 s0 r0 d1 o00111111@1[] i00000000@1[] s0 r0 d1 o01111110@2[~norg] i00000000@0[?]
 ..
    194 s1 r1 d0 o00111111@5[] i00111110@6[] s1 r1 d1 o01111110@7[~norg] i00011111@5[?]
    195 s1 r1 d0 o00111111@5[] i00111110@6[] s0 r0 d0 o01111110@8[~norg] i00011111@5[?]
    196 s0 r0 d1 o00111111@6[] i00111110@6[] s0 r0 d0 o01111110@8[~norg] i00011111@5[?]
    197 s0 r0 d1 o00111111@6[] i00111110@6[] s1 r1 d0 o01111110@8[~norg] i00111111@6[?]
    pru0: DISCARDING EMPTY PACKET
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..which PRU0 duly tosses.

    198 s1 r1 d1 o00111111@6[] i00000000@0[] s1 r1 d0 o01111110@8[~norg] i00111111@6[?]
    199 s1 r1 d1 o00111111@6[] i00000000@0[] s0 r0 d0 o01111110@1[norg] i00111111@6[?]
                                                      ^^^^^^^^^^^
Now, it _looks like_ PRU1 has set up the packet delimiter yet again,
but NO!  This time it's merely data..

    200 s0 r0 d0 o00111111@7[] i00000000@0[] s0 r0 d0 o01111110@1[norg] i00111111@6[?]
    201 s0 r0 d0 o00111111@7[] i00000000@0[] s1 r1 d0 o01111110@1[norg] i00111111@7[?]
    202 s1 r1 d0 o00111111@7[] i00000000@1[] s1 r1 d0 o01111110@1[norg] i00111111@7[?]
    203 s1 r1 d0 o00111111@7[] i00000000@1[] s0 r0 d1 o01111110@2[norg] i00111111@7[?]
 ..
    221 s0 r0 d1 o01111110@4[] i00011110@5[] s1 r1 d1 o01111110@6[norg] i00001110@4[??]
    222 s1 r1 d1 o01111110@4[] i00111110@6[] s1 r1 d1 o01111110@6[norg] i00001110@4[??]
    223 s1 r1 d1 o01111110@4[] i00111110@6[] s0 r0 d0 o01111110@6[norg] i00001110@4[??]
                                                   ^^
..which gets bitstuffed appropriately..

    224 s0 r0 d1 o01111110@5[] i00111110@6[] s0 r0 d0 o01111110@6[norg] i00001110@4[??]
    225 s0 r0 d1 o01111110@5[] i00111110@6[] s1 r1 d0 o01111110@6[norg] i00011110@5[??]
    226 s1 r1 d1 o01111110@5[] i00111110@6[] s1 r1 d0 o01111110@6[norg] i00011110@5[??]
    227 s1 r1 d1 o01111110@5[] i00111110@6[] s0 r0 d1 o01111110@7[norg] i00011110@5[??]
    228 s0 r0 d1 o01111110@6[] i00111110@6[] s0 r0 d1 o01111110@7[norg] i00011110@5[??]
    229 s0 r0 d1 o01111110@6[] i00111110@6[] s1 r1 d1 o01111110@7[norg] i00111110@6[??]
    230 s1 r1 d1 o01111110@6[] i01111110@7[] s1 r1 d1 o01111110@7[norg] i00111110@6[??]
    231 s1 r1 d1 o01111110@6[] i01111110@7[] s0 r0 d0 o01111110@8[norg] i00111110@6[??]
    232 s0 r0 d1 o01111110@7[] i01111110@7[] s0 r0 d0 o01111110@8[norg] i00111110@6[??]
    233 s0 r0 d1 o01111110@7[] i01111110@7[] s1 r1 d0 o01111110@8[norg] i00111110@6[??]
    234 s1 r1 d1 o01111110@7[] i00000000@0[~] s1 r1 d0 o01111110@8[norg] i00111110@6[??]
                                          ^^^
..and received by PRU0 literally.

    235 s1 r1 d1 o01111110@7[] i00000000@0[~] s0 r0 d0 o01101110@1[org] i00111110@6[??]
    236 s0 r0 d0 o01111110@8[] i00000000@0[~] s0 r0 d0 o01101110@1[org] i00111110@6[??]
    pru1: RECEIVED PACKET '??'
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Meanwhile, PRU0->PRU1 transmission has been operating completely
independently, above the level of the shared clock.

    237 s0 r0 d0 o01111110@8[] i00000000@0[~] s1 r1 d0 o01101110@1[org] i00000000@0[]
    238 s1 r1 d0 o01111110@8[] i00000000@1[~] s1 r1 d0 o01101110@1[org] i00000000@0[]
    239 s1 r1 d0 o01111110@8[] i00000000@1[~] s0 r0 d1 o01101110@2[org] i00000000@0[]
    240 s0 r0 d0 o01111110@1[] i00000000@1[~] s0 r0 d1 o01101110@2[org] i00000000@0[]
                 ^^^^^^^^^^^
But now PRU0 has nothing more to send, and so has set up the packet
delimiter again.

    241 s0 r0 d0 o01111110@1[] i00000000@1[~] s1 r1 d1 o01101110@2[org] i00000000@1[]
    242 s1 r1 d0 o01111110@1[] i00000010@2[~] s1 r1 d1 o01101110@2[org] i00000000@1[]
 ..
    267 s1 r1 d1 o01111110@7[] i00000000@0[~n] s0 r0 d1 o01101111@1[rg] i00111110@6[]
    268 s0 r0 d0 o01111110@8[] i00000000@0[~n] s0 r0 d1 o01101111@1[rg] i00111110@6[]
    pru1: DISCARDING EMPTY PACKET
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Which PRU1 tosses.

    269 s0 r0 d0 o01111110@8[] i00000000@0[~n] s1 r1 d1 o01101111@1[rg] i00000000@0[]
    270 s1 r1 d0 o01111110@8[] i00000001@1[~n] s1 r1 d1 o01101111@1[rg] i00000000@0[]
 ..
    299 s1 r1 d1 o01111110@7[] i00000000@0[~no] s0 r0 d0 o01110010@1[g] i00111110@6[]
    300 s0 r0 d0 o01111110@8[] i00000000@0[~no] s0 r0 d0 o01110010@1[g] i00111110@6[]
    pru1: DISCARDING EMPTY PACKET
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Regularly.

    301 s0 r0 d0 o01111110@8[] i00000000@0[~no] s1 r1 d0 o01110010@1[g] i00000000@0[]
    302 s1 r1 d0 o01111110@8[] i00000000@1[~no] s1 r1 d0 o01110010@1[g] i00000000@0[]
 ..
    392 s0 r0 d1 o01111110@7[] i00111110@6[~norg] s0 r0 d0 o01111110@8[] i00111110@6[]
    393 s0 r0 d1 o01111110@7[] i00111110@6[~norg] s1 r1 d0 o01111110@8[] i00111110@6[]
    pru0: RECEIVED PACKET '~norg'
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
PRU0 recognizes a big old five byte packet.

    394 s1 r1 d1 o01111110@7[] i00000000@0[] s1 r1 d0 o01111110@8[] i00111110@6[]
    395 s1 r1 d1 o01111110@7[] i00000000@0[] s0 r0 d0 o01111110@1[] i00111110@6[]
    396 s0 r0 d0 o01111110@8[] i00000000@0[] s0 r0 d0 o01111110@1[] i00111110@6[]
    pru1: DISCARDING EMPTY PACKET
    397 s0 r0 d0 o01111110@8[] i00000000@0[] s1 r1 d0 o01111110@1[] i00000000@0[]
    398 s1 r1 d0 o01111110@8[] i00000000@1[] s1 r1 d0 o01111110@1[] i00000000@0[]
                 ^^^^^^^^^^^                          ^^^^^^^^^^^
Now both sides have become idle

    399 s1 r1 d0 o01111110@8[] i00000000@1[] s0 r0 d1 o01111110@2[] i00000000@0[]
    400 s0 r0 d0 o01111110@1[] i00000000@1[] s0 r0 d1 o01111110@2[] i00000000@0[]
 ..
    488 s0 r0 d1 o01111110@7[] i00111110@6[] s0 r0 d0 o01111110@8[] i00111110@6[]
    489 s0 r0 d1 o01111110@7[] i00111110@6[] s1 r1 d0 o01111110@8[] i00111110@6[]
    pru0: DISCARDING EMPTY PACKET
    490 s1 r1 d1 o01111110@7[] i00000000@0[] s1 r1 d0 o01111110@8[] i00111110@6[]
    491 s1 r1 d1 o01111110@7[] i00000000@0[] s0 r0 d0 o01111110@1[] i00111110@6[]
    492 s0 r0 d0 o01111110@8[] i00000000@0[] s0 r0 d0 o01111110@1[] i00111110@6[]
    pru1: DISCARDING EMPTY PACKET
    493 s0 r0 d0 o01111110@8[] i00000000@0[] s1 r1 d0 o01111110@1[] i00000000@0[]
    494 s1 r1 d0 o01111110@8[] i00000000@1[] s1 r1 d0 o01111110@1[] i00000000@0[]
    root@beaglebone:/home/t2/T2-12#

And they both discarded empty packets happily ever after.

:247]
:246]

:245]

:244]
:243]

:242]

:241]
:240]
:239]
[248:

Sun Dec 24 11:58:18 2017 OK, so one more thing I want out of our perl
spikes is to show it byte aligns correctly when it sees the frame
delimiter at an arbitrary position.  If we do not have packet sync,
the frame delimiter should be accepted in any position, and we reset
our byte boundary based on that.  If we do have packet sync, the frame
delimiter must be aligned to our existing byte boundaries, else we
should blow the current packet, drop packet sync, and declare an
error.[249:

Sun Dec 24 12:10:33 2017 Well, made interclockdemo12.pl for this, but
the first part -- aligning when we don't have packet sync -- appears
to 'just work' already.  It's going to take a bit more work to make
the code cause a sync alignment error..
[250:

Sun Dec 24 12:32:34 2017 OK, well we seem to have that working.
Heavily edited trace:

     ./pru/itcio/notes/interclockdemo12.pl
      1 s0 r0 d0 o00000000@8[ Q DM NG hi] i00000000@2[] s1 r1 d0 o00000000@8[ z! ~norg] i00000000@1[]
0->1: "Q", "DAM" but with a bit missing in the A, "NG", "hi"
1->0: "\377z!", "~norg"
 ..  32 s0 r0 d0 o01111110@8[Q DM NG hi] i00000001@1[] s0 r0 d0 o01111110@8[z! ~norg] i01111100@7[]
    pru1: ACHIEVED PACKET SYNC
     33 s0 r0 d0 o01111110@8[Q DM NG hi] i00000001@1[] s1 r1 d0 o01111110@8[z! ~norg] i00000000@0[]
    pru0: ACHIEVED PACKET SYNC
     34 s1 r1 d0 o01111110@8[Q DM NG hi] i00000000@0[] s1 r1 d0 o01111110@8[z! ~norg] i00000000@0[]
 ..  96 s0 r0 d0 o01111110@8[DM NG hi] i00111010@6[] s0 r0 d1 o01111010@7[! ~norg] i00111110@6[Q]
    pru1: RECEIVED PACKET 'Q'
     97 s0 r0 d0 o01111110@8[DM NG hi] i00111010@6[] s1 r1 d1 o01111010@7[! ~norg] i00000000@0[]
 .. 128 s0 r0 d0 o01000100@8[M NG hi] i00100001@6[z] s0 r0 d0 o00100001@7[ ~norg] i01000100@7[]
    129 s0 r0 d0 o01000100@8[M NG hi] i00100001@6[z] s1 r1 d0 o00100001@7[ ~norg] i00000000@0[D]
First byte of 'DAM' recognized..
 .. 160 s0 r0 d1 o01001101@1[ NG hi] i00111110@6[z!] s0 r0 d1 o01111110@7[~norg] i00100000@7[D]
    161 s0 r0 d1 o01001101@1[ NG hi] i00111110@6[z!] s1 r1 d1 o01111110@7[~norg] i00000000@0[D]
Second byte corrupted by loss of bit, but nothing detected yet..
 .. 192 s0 r0 d0 o01111110@1[NG hi] i00111110@6[] s0 r0 d0 o01111110@6[norg] i00100110@7[D]
    193 s0 r0 d0 o01111110@1[NG hi] i00111110@6[] s1 r1 d0 o01111110@6[norg] i00000000@0[D&]
Third byte also corrupted..
 .. 219 s1 r1 d1 o01111110@7[NG hi] i00001110@4[~] s0 r0 d0 o01101110@5[org] i00011111@5[D&]
    220 s0 r0 d0 o01111110@8[NG hi] i00001110@4[~] s0 r0 d0 o01101110@5[org] i00011111@5[D&]
    pru1: FRAMING ERROR; DROPPING PACKET & SYNC
Finally an unaligned frame delimiter is detected and an error declared.
 .. 251 s1 r1 d1 o01001110@7[G hi] i00001111@4[~n] s0 r0 d0 o01101111@5[rg] i01001110@7[]
    252 s0 r0 d0 o01001110@8[G hi] i00001111@4[~n] s0 r0 d0 o01101111@5[rg] i01001110@7[]
    253 s0 r0 d0 o01001110@8[G hi] i00001111@4[~n] s1 r1 d0 o01101111@5[rg] i00000000@0[]
The received 'N' is discarded because PRU1 doesn't have sync.
 .. 283 s1 r1 d1 o01000111@7[ hi] i00000010@4[~no] s0 r0 d1 o01110010@5[g] i01000111@7[]
    284 s0 r0 d0 o01000111@8[ hi] i00000010@4[~no] s0 r0 d1 o01110010@5[g] i01000111@7[]
    285 s0 r0 d0 o01000111@8[ hi] i00000010@4[~no] s1 r1 d1 o01110010@5[g] i00000000@0[]
The received 'G' also..
 .. 286 s1 r1 d0 o01000111@8[ hi] i00010010@5[~no] s1 r1 d1 o01110010@5[g] i00000000@0[]
    287 s1 r1 d0 o01000111@8[ hi] i00010010@5[~no] s0 r0 d1 o01110010@6[g] i00000000@0[]
    288 s0 r0 d0 o01111110@1[hi] i00010010@5[~no] s0 r0 d1 o01110010@6[g] i00000000@0[]
PRU0 sets up the frame delimiter ending "NG".
 .. 316 s0 r0 d0 o01111110@8[hi] i00000111@4[~nor] s0 r0 d0 o01100111@5[] i00111110@6[]
    pru1: ACHIEVED PACKET SYNC
But PRU1 just uses it to resync.
 .. 361 s0 r0 d0 o01101001@3[] i00111110@6[~norg] s1 r1 d0 o01111110@8[] i00000001@3[h]
    pru0: RECEIVED PACKET '~norg'
Now it is kind of weird that one direction can lose sync while the
other direction soldiers on fine, but that's what we're looking at,
for the moment anyway, with these oh-so-nearly independent channels.
 .. 412 s0 r0 d0 o01111110@8[] i00001110@4[] s0 r0 d1 o01111110@5[] i00111110@6[hi]
    pru1: RECEIVED PACKET 'hi'
And packets are now flowing again..
 .. 510 s1 r1 d0 o01111110@8[] i00011110@5[] s1 r1 d1 o01111110@5[] i00000000@0[]
    root@beaglebone:/home/t2/T2-12#

:250]
:249]

:248]
[251:

Sun Dec 24 12:53:24 2017 So okay, I think we've gotten to where we
need some spiking for translating this in asm..[252:

Sun Dec 24 13:05:58 2017 Actually, there's another error path that we
haven't tested, right -- getting a 7th 1 in a row.  We need to blow
sync then too.[253:

Sun Dec 24 13:40:57 2017 OK, now have that too:

     ./pru/itcio/notes/interclockdemo12.pl
  ..219 s1 r1 d1 o01111110@7[NG hi] i00011111@5[L] s0 r0 d1 o11111111@6[$ ^ ~norg] i00011111@5[D&]
    220 s0 r0 d0 o01111110@8[NG hi] i00011111@5[L] s0 r0 d1 o11111111@6[$ ^ ~norg] i00011111@5[D&]
    pru1: FRAME ALIGNMENT ERROR; DROPPING PACKET & SYNC
Here PRU1 saw a frame delimiter not on a byte boundary
 .. 224 s0 r0 d0 o01001110@1[G hi] i00011111@5[L] s0 r0 d1 o11111111@7[$ ^ ~norg] i00000000@0[]
    225 s0 r0 d0 o01001110@1[G hi] i00011111@5[L] s1 r1 d1 o11111111@7[$ ^ ~norg] i00000000@1[]
    pru0: BIT SEQUENCE ERROR; DROPPING PACKET & SYNC
While here PRU0 saw a seventh one in a row.
 .. 296 s0 r0 d1 o01111110@3[hi] i00000000@0[] s0 r0 d0 o01111110@8[^ ~norg] i00000010@2[]
    297 s0 r0 d1 o01111110@3[hi] i00000000@0[] s1 r1 d0 o01111110@8[^ ~norg] i00000110@3[]
    pru0: ACHIEVED PACKET SYNC
PRU1 died first but PRU0 resyncs first because the bit sequence error
was detected during a packet, so resync occurred on that packet's delimiter.
 .. 315 s1 r1 d1 o01111110@7[hi] i00001110@4[] s0 r0 d1 o01011110@5[ ~norg] i00111110@6[]
    316 s0 r0 d0 o01111110@8[hi] i00001110@4[] s0 r0 d1 o01011110@5[ ~norg] i00111110@6[]
    pru1: ACHIEVED PACKET SYNC
But PRU1 gets there too.
 .. 361 s0 r0 d0 o01101001@3[] i00111110@6[^] s1 r1 d0 o01111110@8[~norg] i00000001@3[h]
    pru0: RECEIVED PACKET '^'
    362 s1 r1 d0 o01101001@3[] i00000000@0[] s1 r1 d0 o01111110@8[~norg] i00000001@3[h]
And packets again flow
 .. 412 s0 r0 d0 o01111110@8[] i00000110@3[~] s0 r0 d1 o01101110@4[org] i00111110@6[hi]
    pru1: RECEIVED PACKET 'hi'
both ways.
 .. root@beaglebone:/home/t2/T2-12#

:253]

:252]

:251]
[254:

Sun Dec 24 13:46:36 2017 OK, back to translation-to-asm spiking.

[270: DONE Mon Dec 25 04:51:21 2017   :270](5.1.13) Decide on buffer space for incoming and outgoing packets.  We
were thinking 128 256byte max packet size -- but is there maybe room
to go 256?

(5.1.14) Make a special packet -- call it 'P'? -- that queries the
state of the packet engine in a given direction.  Pack up pretty much
all everything we could want to know.

(5.1.15) Make a packet sync flag and try sending the packet delimiter
all the time and achieving packet sync.  Observe the arrival of sync
using the 'P' packet.

:254][255:

Sun Dec 24 13:53:11 2017 OK, how do we find out how much local RAM we
have available given our current code?  [256:

Sun Dec 24 14:03:18 2017 Well hoodafognose.  But let's just think what
we might want.  If we talk 256 byte packets that's 1.5KB for three in
and three out per PRU.  Right now we're reserving 512 bytes in each
pru without apparent ill effect.  Suppose we just up that to, say, 1KB
and see if things still seem to run.[257:

Sun Dec 24 14:29:44 2017 Seems okay..  Got sidetracked cleaning up the
linking commands in firmware/Makefile, which weren't depending on the
linker script.  Actually let's commit that.

:257]

:256]

:255]
[258:

Sun Dec 24 14:33:40 2017 OK, so it seems we have 1KB reserved okay.

I've been thinking: What about a ring buffer for outbound packets,
plus a single fixed buffer for inbound, both per prudir?  We're going
to ship our completed inbound packets immediately, right?  Because
we're relying on rpmsg framing to tell linux were a packet ends, so
it's not like we could buffer up a bunch of inbound packets and send
them all at once.

But we could buffer on the outbound side, which might help us deal
with our current inability to handle vring buffers competently without
completely trashing our communications with linux.  So suppose we took
like 512B outbound + 256B inbound = 768 per prudir, or 2.3KB total.
Could we do that?  And the point would be that the 512B would be in a
ring buffer within which we'd only consume actual packet sizes rather
than 256 per.

[259:

Sun Dec 24 14:43:16 2017 Another / additional approach would be to
have the prudir threads be able to 'kick' the linux thread by setting
some flag when they're unable to buffer an outbound packet.  That
would a third way to get the linux thread to check for packets:
(1) Kick from ARM
(2) Timeout
(3) Kick from prudir thread

A prudir thread could set that bit when it sees the next packet from
linux is destined for it, but it hasn't got ring buffer space for it,
so it just leaves it in the rpmsg queue.  Now, doing that will block
further outbound packet buffering for _all_ the prudirs, not just the
one that's gone full, but if it's a rare, brief situation it might be
tolerable, and if not, it will cause the error condition to propagate
up naturally, when the LKM starts seeing rpmsg buffer exhaustion.

I guess really the linux thread would be setting that bit, because
that's what'll be running when we discover we can't dump an outbound
packet in a prudir's queue.  If we blow packet sync on a thread we'll
need to dump its whole outbound queue too.. or no?  I think probably
yes..  Because if we don't have packet sync we certainly don't want to
be adding outbound packets to its queue..  We want to return an error
message to linux asap, telling it we dumped this packet due to lack of
sync and WTF did you send it down to us.

I guess we will also want local standard packets to announce packet
sync gained and lost, so linux can know, modulo timing, who the prus
are currently talking with.  So linux could mostly avoid sending stuff
to unsynced destinations.

Anyway, so could we do this?  Could we reserve say 2.5KB for packet
buffers and get away with it?[260:

Sun Dec 24 15:06:09 2017 Well it dint asplode right away, anyway.
[261:

Sun Dec 24 15:08:10 2017 Can we figure out how to place a C struct
into that space, like we did back in IXM-land with BODYRAM and so
forth? [262:

Sun Dec 24 15:15:02 2017 spruhv7b 5.9.5 pg 82 seems to say the way is:

    #pragma DATA_SECTION(bufferB, "my_sect")
    char bufferA[512];
    char bufferB[512];

Now how do we declare my_sect in the linker script..[263:

Sun Dec 24 16:06:10 2017 First a memory region:

        ASMBUF (RW) : org = 0x00000000 len = ASMBUFSIZ  /* ASMBUFSIZ memory range for packet buffers */

then a section:

        .asmbuf         >  ASMBUF, PAGE 1

[264:

Then a pragma, I guess..

:264]

:263]

:262]

:261]
:260]

:259]

:258]
[265:

Sun Dec 24 17:06:34 2017 OK well I took a little side track, because I
was seeing really large (I thought) values for the STALL register --
with it running at like 5%+ of the CYCLE register, which seems totally
awful.  Numbers like this:

    CYCLE     := 0x0bfd7f50
    STALL     := 0x00ec1dc7

and these:

    CYCLE     := 0x0c76cb47
    STALL     := 0x00f57260


where STALL was basically running one hex digit behind CYCLE..

I now currently suspect that maybe I was reading the CYCLE register
wrong, but in any case I ditched that and I'm now counting 16 bits
worth LinuxThreadRunner resume counts and forcing packet processing
whenever the count turns over.

And now I'm seeing numbers like these:

    CYCLE     := 0x0e0ebed5
    STALL     := 0x00000047

and these

    CYCLE     := 0xf8607b66
    STALL     := 0x0000004a

and even these

    CYCLE     := 0xffffffff
    STALL     := 0x00000048

because it seems 65K LinuxThreadRunner resumes takes rather longer
than 21.47ish seconds.  I'd rather do it like every few seconds, but
anything but testing for wrapping to 0 seems to cost at least an
instruction..  If we start losing ARM kicks when the system gets more
loaded, we'll need to be polling a lot more frequently than that..

But anyway, just saying, this reorg did speed things up a bit.  New
data:

[132122.551187] <pru1: c1 31 4e 45 61 30 38 30 30 30 30 30 30 20 43 54  .1NEa08000000 CT
[132146.670633] <pru0: c1 30 45 54 61 30 63 30 30 30 30 30 30 20 43 54  .0ETa0c000000 CT<
[132146.678617] <pru0: c1 30 53 45 61 30 63 30 30 30 30 30 30 20 43 54  .0SEa0c000000 CT
[132146.686607] <pru0: c1 30 53 57 61 30 63 30 30 30 30 30 30 20 43 54  .0SWa0c000000 CT
[132146.694563] <pru1: c1 31 57 54 61 30 63 30 30 30 30 30 30 20 43 54  .1WTa0c000000 CT
[132146.702483] <pru1: c1 31 4e 57 61 30 63 30 30 30 30 30 30 20 43 54  .1NWa0c000000 CT
[132146.710389] <pru1: c1 31 4e 45 61 30 63 30 30 30 30 30 30 20 43 54  .1NEa0c000000 CT
[132170.829838] <pru0: c1 30 45 54 61 31 30 30 30 30 30 30 30 20 43 54  .0ETa10000000 CT<
[132170.837845] <pru0: c1 30 53 45 61 31 30 30 30 30 30 30 30 20 43 54  .0SEa10000000 CT
perl -e 'printf("%f\n",(0x10000000-0x0c000000)/(132170.829838 - 132146.670633))'
2777776.172684 -> 2.77Mbps / 277KBps

which is an 8.3% speedup over our 2564097 sample back in :238:

So that's nice.  2.77Mbps x 6 isn't so embarrassing against UARTs.
[266:

Sun Dec 24 17:39:08 2017 Except, well that was a little too good to be
true.  I was using resumeNextThread for linuxThreadRunner, so my
incrementing counter wasn't getting saved.  Oops.  That's why the
CYCLE count was getting so large.  So now, forcing packet processing
every 65K resumes is showing numbers like:

    CYCLE     := 0x0023037f
    STALL     := 0x0000004a

and

    CYCLE     := 0x000c861f
    STALL     := 0x0000004a

and

    CYCLE     := 0x001d7368
    STALL     := 0x00000047

and our bitrate is off a bit:

[134261.133058] <pru1: c1 31 4e 45 61 30 34 30 30 30 30 30 30 20 43 54  .1NEa04000000 CT
[134286.597908] <pru0: c1 30 45 54 61 30 38 30 30 30 30 30 30 20 43 54  .0ETa08000000 CT<
[134286.605922] <pru0: c1 30 53 45 61 30 38 30 30 30 30 30 30 20 43 54  .0SEa08000000 CT
[134286.613875] <pru0: c1 30 53 57 61 30 38 30 30 30 30 30 30 20 43 54  .0SWa08000000 CT
[134286.621843] <pru1: c1 31 57 54 61 30 38 30 30 30 30 30 30 20 43 54  .1WTa08000000 CT
[134286.629796] <pru1: c1 31 4e 57 61 30 38 30 30 30 30 30 30 20 43 54  .1NWa08000000 CT
[134286.637707] <pru1: c1 31 4e 45 61 30 38 30 30 30 30 30 30 20 43 54  .1NEa08000000 CT
[134312.102612] <pru0: c1 30 45 54 61 30 63 30 30 30 30 30 30 20 43 54  .0ETa0c000000 CT<
[134312.110647] <pru0: c1 30 53 45 61 30 63 30 30 30 30 30 30 20 43 54  .0SEa0c000000 CT
perl -e 'printf("%f\n",(0x0c000000-0x08000000)/(134312.102612 - 134286.597908))'
2631234.771438

But still.

I wonder if this is an example of the 'write posting' win?  When we
clear the CYCLE register that's just a rare write being issued, and it
posts and then we continue, but when we read it we (have to) block
until the data is available.

But I didn't think we would have to hit the busy city streets just to
read a hardware counter..  Anyway.[267:

Sun Dec 24 17:53:07 2017 Time to take a break for Christmas Eve
cocktails or something.  [272: Mon Dec 25 14:29:57 2017 DONE  :272]One resume point for whenever is: Try to
refer to pruDirData somehow from prux_sbst3.inc.

:267]

:266]
:265]
[268:

Mon Dec 25 04:34:59 2017 OK, well we finally have this:

[173982.134450] <pru1: c1 31 57 54 67 36 34 30 30 30 30 30 30 20 43 54  .1WTg64000000 CT
[174003.298921] <pru0: c1 30 53 45 68 37 34 30 30 30 30 30 30 20 43 54  .0SEh74000000 CT
[174003.306964] <pru1: c1 31 4e 57 68 37 34 30 30 30 30 30 30 20 43 54  .1NWh74000000 CT
[174003.548942] <pru1: c1 31 4e 45 68 37 34 30 30 30 30 30 30 20 43 54  .1NEh74000000 CT
[174003.557016] <pru0: c1 30 53 57 68 37 34 30 30 30 30 30 30 20 43 54  .0SWh74000000 CT
[174007.631081] <pru0: c1 30 45 54 67 36 38 30 30 30 30 30 30 20 43 54  .0ETg68000000 CT
[174007.639191] <pru1: c1 31 57 54 67 36 38 30 30 30 30 30 30 20 43 54  .1WTg68000000 CT
[174028.803636] <pru0: c1 30 53 45 68 37 38 30 30 30 30 30 30 20 43 54  .0SEh78000000 CT
                                                                            ^
where the marked byte, appearing after the direction, depends on this C code:

  buf[len++] = 'a' + pruDirData.pruDirBuffers[prudir].in.written; /* read something written by asm in asmbuf */

with the second operand the + having been written by this asm code:

	ldi r28, $sizeof(PruDirBuffers)   ; First operand to multiply
	mov r29, CT.sTH.bID               ; Second operand to multiply
        ldi r1, pruDirData + PruDirBuffers.in + InboundPacketBuffer.written ; Set up base address in multiply delay slot
        xin 0, &r26, 4                    ; Read 32 bit multiplication result
        add r0,r1,r26                     ; Add to base address
        lsr r1, CT.rRunCount.r, 28        ; Get left four bits of count
        sbbo &r1, r0, 0, 1                ; Stash in pruDirData.pruDirBuffers[prudir].in.written

and I deliberately unplugged the ET-WT cable for awhile to throw its
count behind the diagonals.[269:

Mon Dec 25 04:50:45 2017 So.  Claiming 5.1.13, at least
provisionally.  And I'd claim the C<->ASM buffer sharing from :267:,
but I didn't give it a number..

And I learned how to use the multiplier.. which isn't that easy to
figure out just googling around for it.  The key is in spruhf8a Figure
11 page 32 and surrounding: r28 and r29 are AUTOMATICALLY SAMPLED
every cycle, and their product can be read by an 'XIN 0' on r26 (low
32 bits) and/or r27 (high 32 bits) after a one cycle delay.

[271:

Mon Dec 25 05:12:51 2017 Committing.

:271]
:269]

:268]
[273:

Mon Dec 25 14:31:12 2017 We continue building infrastructure all
around the wire protocol:

(5.1.16) Make slow-but-correct C routines to add a packet to the
OutboundRingBuffer.

(5.1.17) Make C code to check headers and route an outbound packet to
the correct OutboundRingBuffer.  Or is that all done linux side?

(5.1.18) Make a C special command that takes one packet outbound to
some specified direction and moves it to become the inbound packet
from some specified direction.

(5.1.19) Make some outboundPacketDone() C function, callable from C
and asm, that takes the outbound data and ships it to linux.

(5.1.20) Glue all those pieces together and demonstrate round-trip
'internal loopback' packet routing from userspace to userspace.

(5.1.21) Make spikes for translating the perl wire protocol to asm.

:273]
[274:

Mon Dec 25 16:19:14 2017 OK now we have a lame-o cringe-before-kfifo
ring buffer demo in bufferdemo10.pl.  Rotating into mostly cooking
dinner here but will make a start at conversion-to-C.

[275:

Mon Dec 25 18:22:47 2017 Did a rough-cut conversion.  Next step is try
calling some of these routines.  orbAddPacket, first, I guess, from
processPackets.. [276:

Mon Dec 25 22:25:22 2017 OK, we're making processOutboundITCPacket and
we need to know the first byte of packet rules so we know where to
which OutboundRingBuffer to put the packet in.  We did some recent
design on this, right?
[277:

Mon Dec 25 23:28:24 2017 Yeah, umm, and it really shouldn't have taken
this long to find, because it's in this file, you fogging norg, at
:162: above.  For which the relevant part, at the moment, is this:

 - In a 'routed standard' packet, by definition, (type&0xc0)==0x80.
   The structure of a routed standard packet type is this:

      7   6   5   4    3   2   1   0
    +---+---+---+---++---+---+---+---+
    | 1 | 0 |RSV|OVR||ERR|SD2|SD1|SD0|
    +---+---+---+---++---+---+---+---+

     RSV - Reserved: Should be 0 on output, should be ignored on input
     OVR - Overrun: Packet data was lost due to exhausted buffer space
     ERR - Error: Some packet data corruption or other problem was detected
     SD[2..0] - Three bit source/destination direction code.

and

 - The interpretation of SD[2..0] varies with context:
   = Linux->PRU: Packet destination direction
   = PRU->Linux: Packet source direction
   = PRU->PRU (in-flight intertile): Packet source direction

and I believe, somewhere below that, we concluded that we should use
the 8-way compass rose.[278: Mon Dec 25 23:44:54 2017 Yes, in :81:, we
declared we're following src/core/include/Dirs.h, so we'll have the
following allocations:

DIRECTION  CODE  PRU  PRUDIR        PRU PRUDIR  DIRECTION CODE
   NT       0     x      -           0    0        ET      2
   NE       1     1      2           0    1        SE      3
   ET       2     0      0           0    2        SW      5
   SE       3     0      1     or    1    0        WT      6
   ST       4     x      -           1    1        NW      7
   SW       5     0      2           1    2        NE      1
   WT       6     1      0
   NW       7     1      1

[279:

Mon Dec 25 23:57:56 2017 So, we're expecting that itc_pkt.ko will have
sent each routed standard packet to the appropriate PRU, so

:279]

:278]

:277]
:276]


  :275]



:274]
[280:

Tue Dec 26 01:00:45 2017 Well, we seem to be putting routed standard
packets onto outbound ring buffers, but we're not yet taking them off
it, so they just clog up there.  Unsatisfying place to break, but,
tired, so committing for the night.

:280]
[281:

Tue Dec 26 08:27:46 2017 Well, actually did make some asm code, last
night, that took packets off the appropriate orb and reported how long
they were, but didn't get to putting anything in the inbound packet
buffer.  Did get to think that if I'm definitely going to call C
anyway, I might as well do it early and let C do as much work as
possible.  Like, how about asm passes its prudir and lets C convert
that to orb*, instead of the random ugly code with multiplication and
stuff we're now doing to derive the orb* in asm?[282:

Tue Dec 26 08:55:58 2017 OK did that.

So.

Let's start translating interclockdemo12.pl into asm, shall we?

Well let's checkpoint where we are first.[283:

Tue Dec 26 14:50:43 2017 Well, attempting a straight convert of
interclockdemo12.pl into assembler is getting rather more ugly and
bugly than my comfort level allows.  Thinking we need to save this
off, make some kind of finer-grained interspikes, and restart from
last commit..

A couple things already surfaced:

 - What's the deal with r3.w2 inside threadrunner code?  Do we really
   need to save it or not?  Is the point that we can go one level of
   function call deep for free, but not two?  Because threadrunner is
   never going to return, it doesn't need r3.w2, so it can trash it by
   calling a function.. but that function can't call any other
   function on r3.w2.

 - It seems like it would be better for the bytesininputpacket field
   to be in the IOThread context, rather than in the
   InboundPacketBuffer.  We can take a reserved byte for it.  It does
   mean that all ipb-related routines will have to be told what the
   current length is, but I think that's not too terrible.



:283]

:282]

:281]
[284:

Tue Dec 26 15:02:47 2017 Minispikes (nails?) ahead of retrying the
wire protocol translation:

(5.1.22) Clean up use of r3.w2 inside thread code.  Goal is to not
have to save/restore it as much as possible, while still being
reasonably robust against trashing execution flow during development.

[288: DONE Tue Dec 26 17:18:39 2017   :288](5.1.23) Draft a thread context byte for bytesInInboundPacket.

[289: DONE Tue Dec 26 17:18:43 2017   :289](5.1.24) Drop 'written' from InboundPacketBuffer and modify ipb
interface functions accordingly.

[290: DONE Tue Dec 26 17:35:39 2017   :290](5.1.25) Split regsave and restore macros from entryfunc and exitfunc,
so we can, if necessary, do that without returning from the function.
Certain low-level debugging macros like sendVal will use that so they
can be called from anywhere.

[286: DONE Tue Dec 26 16:15:46 2017 :286](5.1.26) Break LinuxIO.[hc] out of main_prux.inc so there's an .h file
for Buffers.[hc] to use without mucking in main_pru0 etc.

:284]
[285:

Tue Dec 26 16:14:41 2017 Well, redid the Makefile workflow
considerably, and ditched main_prux.inc entirely.  More could be done
but this is a nice start, and everything still seems to be working.
Claiming 5.1.26 and committing.[287:

Tue Dec 26 16:43:54 2017 OK, standardized the asm side as well, so we
have no remaining '.inc' files on either side.  Committing again.

:287]

:285]
