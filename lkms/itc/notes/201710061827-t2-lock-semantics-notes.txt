{60}  -*- text -*-
[0:

Fri Oct  6 18:28:08 2017 We have four gpios involved in each pairwise
connection between two T2 tiles, two inputs and two outputs, that are
cross-coupled between tiles in the obvious way:

 xx_IRQLK:  Input Request LocK from direction xx
 xx_IGRLK:  Input Grant LocK from direction xx
 xx_ORQLK:  Output Request LocK in direction xx
 xx_OGRLK:  Output Grant LocK in direction xx


We will express input or output states as a binary pair with Request
first and Grant second:

00  IRQLK == 0, IGRLK == 0
01  IRQLK == 0, IGRLK == 1
10  IRQLK == 1, IGRLK == 0
11  IRQLK == 0, IGRLK == 0

[2: Sat Oct  7 02:36:20 2017

We can prefix such states with an 'i' to mean 'input' or an 'o' to
mean 'output':

'i01'   is a predicate meaning:  ((IRQLK == 0) && (IGRLK == 1))
'o10'   is an action meaning:    ORQLK = 1; OGRLK = 0;

and we can combine them to express a transition rule:

'i10>o01' meaning:  if ((IRQLK == 1) && (IGRLK == 0)) { ORQLK = 0; OGRLK = 1; }

We express internal state with an 's' followed by a state name:

sIDLE     Lock is open and no requests pending
sTAKE     We are attempting to take the lock
sTAKEN    We are successfully holding the lock
sGIVE     We are attempting to give the lock
sGIVEN    They are successfully holding the lock
sRESET    Lock system is reset
sSYNC     We are attempting to synchronize with our lock partner

o11 is not legal in the normal protocol, and it is the only such
state, so we use it to be the 'reset' state or ground state.  (So
IRQLK and IGRLK should have pullups enabled?)

When we read 11 we should reset our state (thus beginning to
output 11 as well), i.e., 'i11>s11' and 's11>o11'

When we enter the reset state our lock state becomes invalid and users
of the lock system should see that somehow.

  :2][1:

Sat Oct  7 03:07:15 2017

MACHINE TRANSITIONS

sRESETi11>sSYNC     # matching i11o11 -> SYNC
sRESET>sRESET       # anything else, stay in reset

sSYNCi11>sSYNC01    # matching i11o11 (again, on timer) -> SYNC01
sSYNC>sRESET        # anything else, return to reset

sSYNC01i11>sSYNC01  # waiting on i11o01 to i01o01 transition -> SYNC01
sSYNC01i01>sSYNC00  # matching i01o01 -> SYNC00
sSYNC01>sRESET      # anything else, reset (again)

sSYNC00i10>sSYNC00  # waiting on i10o00 to i00o00 transition -> SYNC00
sSYNC00i00>sIDLE    # matching i00o00 -> sIDLE
sSYNC00>sRESET      # anything else, reset

sIDLEi00>sIDLE      # everybody's still idle
sIDLEi10>sGIVE      # they're asking for the lock
sIDLEuTRY>sTRY      # we're trying for the lock

sGIVEi10>sGIVE      # they're still holding the lock
sGIVEi00>sIDLE      # they released the lock
sGIVE>sRESET        # anything else, resync

sTRYi00>sTRY        # they haven't responded yet
sTRYi01>sTAKEN      # we got it
sTRYi10>sIDLE       # they wanted it too.  probabilistically give up..
sTRYi10>sTRY ++contested # ..or keep trying and hope they give up?
sTRY>sRESET         # anything else, resync

sTAKENi01>sTAKEN    # keep holding the lock
sTAKEN>sFAILED      # something went wrong while we had the lock
sTAKENuFREE>sIDLE   # release the lock

sFAILED->sRESET     # after bookkeeping

MACHINE OUTPUTS

sRESET:  o11 uRESET
sSYNC:   o11 uRESET
sSYNC01: o01 uRESET
sSYNC00: o00 uRESET
sIDLE:   o00 uOPEN
sGIVE:   o01 uBUSY
sTRY:    o10 uPENDING
sTAKEN:  o10 uACQUIRED
sFAILED: o11 uFAILED

  :1]

  :0]
[3:

Sat Oct  7 05:37:57 2017 Well, that can't be all right, and it ought
to be more symmetric I'd think, but it's plausibleish enough for a
start anyway.  And it leaves us wanting to shape up the execution
framework for it all, in terms of interrupts and timers.

[4:

Sun Oct  8 12:35:36 2017 Well, now we have T2-12/lkms/itc.ko working
far enough that about an hour ago, a T2-12 tile handled its first
interrupt from another tile and printk'd about it.  And it triggered
on both rising and falling edges, as desired.  So that was all pretty
good.

And that LKM also is running a kernel thread so that we can do
timeouts and stuff.  Right now the thread is only waking every ten
seconds or something, but it is waking repeatedly.

And so I'm back here trying to figure out what is the next step.  And
the suspicion would be the reset sequence, I guess.  With no requests
coming down from above (mfmt2 level), we should see no edges at all,
and should arrange for the thread to time out.

Suppose we try to do just that first.  Have the interrupt handler
record last active time, and have the thread run every few jiffies
and check if the last active time is too far in the past.[5:

Sun Oct  8 15:15:30 2017 OK, have that.  Looks like HZ=250 on the BBG,
so each jiffy is 4ms.  We do want the timeout stuff to be a backstop
for robustness, and the bulk of the time do work using the
edge-triggered interrupt.

We also want our state machine to be self-stabilizing, or idempotent,
or stimulus-response, or something like that, so that -- except for
timeouts -- our state won't change unless the input changes, and we
can therefore run the transition function any time or multiple times
without harm.

Could the interrupt routine be unique per pin?  And it would just read
that one and only pin, compare it to the stored value for that pin,
and trigger the transition function (with timeout == false) if it
changed?  And the transition function doesn't actually read any pins
at all, it just uses the stored values??

[6:

Sun Oct 8 15:25:30 2017 Let's see if we can make unique interrupt
handlers for each pin.  More YY XX magic; see if it works.[7:

Sun Oct  8 16:54:21 2017 Looks like that worked.  We now have separate
minimal interrupt handlers for each pin, that dish to a common handler
that successfully reading the value of the pin whose edge triggered
the interrupt.

Now, if we store the old value of the pin -- or read everything on
timeout -- we might be able to detect (single) lost interrupts and
trigger a reset.  But do we want to do that, rather than just wait a
while?  We might.

  :7]

  :6]

  :5]

  :4]
  :3]
[8:

Mon Oct  9 01:38:26 2017 OK, for the last few hours we have had one
tile taking interrupts, and a second tile at his SE running a bash
loop that generates 100 edges on ORQ and OGR every nine seconds.  The
hero tile is remembering the state of each input, and counts a 'missed
edge' whenever an interrupt appears _not_ to cause the associated
input to change.

So far, the hero tile has taken about 264K interrupts, and detected
nine missed edges.

We'll just pause to let that sink in.  264,000 to 9.

[9:

Mon Oct  9 01:51:32 2017 Missed another one; 10 so far, with about
270K interrupts taken.

Note the hero tile also been running mfms at generally >49AER this
whole time.

So here it is: In this test, our edge triggered interrupt handler is
catching well over 99.99% of the edges.  But it's also definitely
catching less than 100% of the edges.

So what do we do?

We want to go as fast as possible when taking an uncontested lock --
when we are in sIDLE and see a rising edge on IRQLK, we want to enter
sGIVE (and assert OGRLK) as quickly as possible.

On the other side, when we're in sTRY and see a rising edge on IGRLK,
we want to enter sTAKEN as quickly as possible, so we can report
uACQUIRED to the user (i.e., mfmt2).

We haven't done it yet, but if we do make this LKM also be a character
device, like /dev/itcs or something, then mfmt2 could do a lock
request by doing a one-byte write with the locks it wants, and then do
a one-byte read to see which locks it has.  And the LKM could block
that read until all sTRYs are resolved one way or the other.

That could allow parallelizing the lock tries across the ITCs, which
would be nice.  And if the one byte meant 'I want exactly these
locks', then writing a null byte would free everything.  And even ho
ho, conceivably, one could be holding some lock(s) and write a
non-null byte to free those and acquire some others.

But that would risk a fairness issue if I could write say 001100 and
then 000100 -- like going from a corner lock event to an edge lock
event -- without ever freeing the edge involved in both..

It also makes me wonder if we couldn't be just trying for and freeing
locks all the time, at the LKM level, so that responding to a user
lock request could be 'atomic' -- you either are currently holding
those locks (plus perhaps more, who knows) or you're not.  If you are,
those locks are put into 'persist' mode until you release them, while
any other locks continue to be tried and taken or granted and freed.

But having to luck into two specific locks simultaneously seems like a
losing game for those poor corners, though.  So let's not think that
way right now.

Given a user request for a set of locks, we do this:

 - Check the user state of each requested lock.  If any of them are
   uOPEN, mark this set as unavailable.

 - If the set is marked unavailable, set it to all zeros (free all)

 - Iterate over the set in a background-randomized order.
   = If we don't want the lock,
     - If it's {sTRY, sTAKEN} goto sIDLE
     - If it's uRESET or uBUSY or uOPEN, do nothing
     - Otherwise fail (uncovered state?)
   = If we do want the lock,
     - If it's sIDLE goto sTRY
     - If it's {sTRY, sTAKEN}, do nothing

[10:

Mon Oct  9 17:39:00 2017 OK, now we have background-shuffled
indices.. but we're not doing anything with them..

How can we get another little step to try, here?  Let's try to do some
kind of reset->idle sequence, brute force with timers.  Our goal is to
have itc.ko running on two tiles, and have both tiles get to idle with
each other.

[11:

Mon Oct  9 18:02:40 2017 Start in state sRESET, broadcasting 11.
Forget about the interrupt handler for now.  On timer tick, call
updateState(itc) or something in a dir-shuffled order.

In updateState(itc), read the two input pins.  Do a switch statement
on our state x their pins.  Have the switch statement do nothing but
call setState, which sets our state and updates our pins.

Go on to the next guy.  When done, sleep for a couple jiffies and then
do it again.   Every ten seconds or so, printk all our states (maybe
in dir-shuffled order for fun).

That is all.  Do it.
[12:

Tue Oct 10 05:54:45 2017 OK well we did that, before we slept some,
and it's not working of course.  The current problem looks to be the
sRESET->sSYNC11 idea, or thereabouts: The idea was both parties get to
sRESET and o11, and then one guy can move on to sSYNC11 to start the
path towards sSYNC01 and sSYNC00 and then to sIDLE.  (And we did,
briefly, see sIDLE once, but then it went to sRESET.)

And before trying to understand that further, I'd say here what about
being heretical and making the two sides of the connection asymmetric
for reset sequence purposes?  Two points:

(1) Unlike the IXMs that offered rotational and mirror symmetries for
    interconnection, the T2 tiles really really try hard to ensure
    there's only a single interconnection pattern: Only a fred and a
    ginger can interconnect, and then only via ET-WT, NE-SW, or NW-SE.

(2) I _think_ we don't care if the reset sequence is asymmetric as
    long as the subsequent lock taking process is symmetric.  We can't
    use fred vs ginger to prioritize who wins a contested lock -- we
    want to use something randomized somehow -- but it would make the
    reset sequence liiiiike super-easy right?

Suppose we say ginger moves first on reset, because that seems
marginally less sexist though it's always in the eyes of the beholder.
That means fred@sRESET (call it FsRESET) can see i01 and have it be
okay, but ginger cannot.  So, some rules:

   FsRESETi01 -> sSYNC01     GsRESETi11 -> sSYNC01
   FsRESETi.. -> sRESET      GsRESETi.. -> sRESET

   FsSYNC01i00 -> sSYNC00    GsSYNC01i11 -> sSYNC01
   FsSYNC01i.. -> sRESET     GsSYNC01i01 -> sSYNC00

   FsSYNC00i00 -> sIDLE      GsSYNC00i00 -> sIDLE

Which is fine as far as it goes but leaves us with still a race
between entering sIDLE and leaving it again by trying to take the
first lock.

(This can also fail if FsRESET sees a i01 before ginger enters reset.
Let's try again.)

  FsFAILEDi11 -> sRESET      GsFAILEDi11 -> sRESET        # i11 is the only way to get
  FsFAILEDi.. -> sFAILED     GsFAILEDi.. -> sFAILED       # from sFAILED to sRESET

                             GsRESETi11  -> sSYNC01       # ginger moves first from sRESET
  FsRESETi11  -> sRESET                                   # fred waits for ginger in sRESET
  FsRESETi01  -> sSYNC01                                  # fred reacts to ginger's move
  FsRESETi..  -> sFAILED     GsRESETi..  -> sFAILED       # anything else, try again

                             GsSYNC01i11 -> sSYNC01       # ginger waits for fred in sSYNC01
  FsSYNC01i01 -> sSYNC01                                  # fred waits for ginger in sSYNC01
                             GsSYNC01i01 -> sIDLE         # ginger moves first from sSYNC01
  FsSYNC01i00 -> sIDLE                                    # fred reacts to ginger's move
  FsSYNC01i.. -> sFAILED     GsSYNC01i.. -> sFAILED

                sIDLEi01 -> sIDLE                         # ignore leftover grants (from reset or uFREE)
                sIDLEi00 -> sIDLE                         # we're both idle
                sIDLEi10 -> sGIVE                         # they took the lock
                sGIVEi10 -> sGIVE                         # they're still holding the lock
                sGIVEi00 -> sIDLE                         # they freed the lock
                sIDLEuTRY -> sTAKE                        # try for the lock
                sTAKEi00 -> sTAKE                         # we're still hoping for the lock
                sTAKEi01 -> sTAKEN                        # we got the lock
                sTAKENi01-> sTAKEN                        # we're holding the lock
                sTAKENuFREE -> sIDLE                      # free the lock

  :12]
  :11]

  :10]

  :9]

  :8]
[13:

Thu Oct 12 14:35:00 2017 OK, it's Thursday again which means it's time
to dig in and do the hard work.

Should we make a more flexible table-driven state transition
mechanism, so we can more easily implement and hack on things like
wildcard matches and stuff?

Like, an array[POSSIBLE_STATES] of pointers to
array[RULES_IN_THAT_PARTICULAR_STATE]

struct Rule {
  u8 bits;
  u8 mask;
  u8 newstate;
  u8 endmarker;
};

with bits like
 enum {
   BIT_PIN_IRQLK = 0x01,
   BIT_PIN_IGRLK = 0x02,
   BIT_ITC_ISFRED= 0x04,
   BIT_USR_TRY   = 0x08,
   BIT_USR_FREE  = 0x10,
   BIT_RSV_6     = 0x20,
   BIT_RSV_7     = 0x40,
   BIT_RSV_8     = 0x80
 };

and hacks like
  enum {
   INPUT_VALUE_i00 = 0,
   INPUT_VALUE_i01 = BIT_PIN_IGRLK,
   INPUT_VALUE_i10 = BIT_PIN_IRQLK,
   INPUT_VALUE_i11 = BIT_PIN_IRQLK|BIT_PIN_IGRLK,
   INPUT_VALUE_i_0 = 0,
   INPUT_VALUE_i_1 = BIT_PIN_IGRLK,
   INPUT_VALUE_i0_ = 0,
   INPUT_VALUE_i1_ = BIT_PIN_IRQLK,
   INPUT_VALUE_i__ = 0,
   INPUT_MASKV_i00 = BIT_PIN_IGRLK|BIT_PIN_IGRLK,
   INPUT_MASKV_i01 = BIT_PIN_IGRLK|BIT_PIN_IGRLK,
   INPUT_MASKV_i10 = BIT_PIN_IGRLK|BIT_PIN_IGRLK,
   INPUT_MASKV_i11 = BIT_PIN_IRQLK|BIT_PIN_IGRLK,
   INPUT_MASKV_i_0 = BIT_PIN_IGRLK,
   INPUT_MASKV_i_1 = BIT_PIN_IGRLK,
   INPUT_MASKV_i0_ = BIT_PIN_IRQLK,
   INPUT_MASKV_i1_ = BIT_PIN_IRQLK,
   INPUT_MASKV_i__ = 0

   ITCSD_VALUE_cF = BIT_ITC_ISFRED,
   ITCSD_VALUE_cG = 0,
   ITCSD_VALUE_c_ = 0,
   ITCSD_MASKV_cF = BIT_ITC_ISFRED,
   ITCSD_MASKV_cG = BIT_ITC_ISFRED,
   ITCSD_MASKV_c_ = 0,
 }

and macros like
#define R_INP(input,newstate)       R_ALL(_,u_,input,newstate,0)
#define R_USR(user,newstate)        R_ALL(_,user,i__,newstate,0)
#define R_ITC(side,input,newstate)  R_ALL(side,u_,input,newstate,0)
#define R_ALL(side,user,input,newst,endm) \
  { .bits = ((ITCSD_VALUE_c#side)|(USER_VALUE_#user)|(INPUT_VALUE_#input)), \
    .mask = ((ITCSD_MASKV_c#side)|(USER_MASKV_#user)|(INPUT_MASKV_#input)), \
    .newst = (newst) \
    .endmarker = (endm) \
  }
#define R_END(newstate) MAKE_FULL_RULE(_,u_,i__,newstate,1)

and declarations like

//In sFAILED:
  MAKE_SIMPLE_RULE(i11,sRESET),
  END_RULE(sFAILED)

//In sRESET
  MAKE_SIDE_RULE(G,i11,sSYNC01),
  MAKE_SIDE_RULE(F,i11,sRESET),
  MAKE_SIDE_RULE(F,i01,sSYNC01),
  END_RULE(sFAILED)

//In sSYNC01
  MAKE_SIDE_RULE(G,i11,sSYNC01),
  MAKE_SIDE_RULE(F,i01,sSYNC01),
  MAKE_SIDE_RULE(G,i01,sIDLE),
  MAKE_SIDE_RULE(F,i00,sIDLE),
  END_RULE(sFAILED)

[14:

Thu Oct 12 15:24:05 2017 Well, so that seems vaguely plausible, except
we need to understand how we set up the overall per-state dispatch
table.

I bet the LKM build system allows us to use ... in macros (unlike the
MFM build system)..  Maybe?  How does that work again?[15:

Thu Oct 12 15:46:06 2017


#define YY() \
  RS(sFAILED, R_INP(i11,sRESET), R_END(sFAILED)) \
  RS(sRESET, R_ITC(G,i11,sSYNC01), R_ITC(F,i11,sRESET), R_ITC(F,i01,sSYNC01), R_END(sFAILED))

/* Generate state constants */
#define RS(forState,...) forState,
enum State {
 YY()
 STATE_COUNT
};
#undef RS

/* Generate per-state rulesets */
#define RS(forState,...) const struct Rule ruleSet_#forState[] = { __VA_ARGS__ }
YY()
#undef RS

/* Generate state->ruleset dispatch table */
#define RS(forState,...) ruleSet_#forState,
const struct Rule ruleSetDispatchTable[STATE_COUNT][]) = {
  YY()
};
#undef RS

[16:

Thu Oct 12 16:04:18 2017 Well that's some good old fashioned hacros
there indeedy (with a little C99 flair, assuming it works).

Let's maybe give it a little try?  Actually, let's minimize the names
a bit first, get rid of the MAKE_SIDE_RULE and MAKE_FULL_RULE and all,
to save some viznoise and reduce width..

  :16]
  :15]

  :14]

  :13][17:

Sat Oct 14 04:52:51 2017 So, it seems like the ruleset hacros are
actually working, sufficient to discover the first actual bug in the
transition rules rather than in the framework.
[18:

Sat Oct 14 04:54:24 2017 Just for the record, here's the entire
current ruleset:

-----cut here-----
/* THIS IS THE MASTER FILE CONTAINING ALL STATE TRANSITION INFO */
/* NO #define/#ifndef macro guard here!  File is included multiple times! */

RS(sRESET,o11, /** Initial and ground state, entered on any error */
   R_ITC(G,i11,sSYNC01), /* ginger moves first from sRESET */
   R_ITC(F,i11,sRESET),  /* fred waits for ginger in sRESET */
   R_ITC(F,i01,sSYNC01), /* fred reacts to ginger's move */
   R_END(sFAILED))       /* else punt */

RS(sSYNC01,o01, /** Out of reset, looking for i01 */
   R_ITC(G,i11,sSYNC01), /* ginger waits while fred's in reset */
   R_ITC(F,i01,sSYNC01), /* fred waits for ginger to leave SYNC01 */
   R_ITC(G,i01,sIDLE),   /* ginger moves first from SYNC01 */
   R_ITC(F,i00,sIDLE),   /* fred reacts to ginger's move */
   R_END(sFAILED))       /* else punt */

RS(sIDLE,o00, /** In sync, waiting for a lock grab */
   R_INP(i01,sIDLE),     /* ignore leftover grants (from reset or uFREE) */
   R_INP(i00,sIDLE),     /* we're both idle */
   R_INP(i10,sGIVE),     /* they took the lock */
   R_USR(uTRY,sTAKE),    /* we're going for the lock */
   R_END(sFAILED))       /* they must have reset, die with them */

RS(sGIVE,o01,  /** They've got the lock */
   R_INP(i10,sGIVE),	 /* they're still holding the lock */
   R_INP(i00,sIDLE),	 /* they freed the lock */
   R_END(sFAILED))       /* else punt */

RS(sTAKE,o10,  /** We're going for lock */
   R_INP(i00,sTAKE),	 /* we're still hoping for the lock */
   R_INP(i01,sTAKEN),	 /* we got the lock */
   R_INP(i10,sRACE),     /* we both reached for the gun */
   R_END(sFAILED))       /* else punt */

RS(sRACE,o11,  /** A race has been detected */
   R_END(sFAILED))       /* for now just punt */

RS(sTAKEN,o10, /** We've got the lock */
   R_USR(uFREE,sIDLE),   /* we freed the lock */
   R_INP(i01,sTAKEN),    /* we still hold the lock */
   R_END(sFAILED))       /* uh-oh the lock broke under us */

RS(sFAILED,o11, /** Something went wrong, reset required  */
   R_INP(i11,sRESET),    /* i11, you bet: It's the only way to get */
   R_END(sFAILED))       /* off of FAILED onto RESET (burma shave)*/
-----cut here-----

So that's kind of cool.

  :18]

  :17]
[19:

Sat Oct 14 04:57:37 2017 Main issue we're dealing with now is which
'bottom half' technology do we want to use -- if any.  Here's what
we've kind of gleaned about the whole linux interrupt landscape:

 - the so-called 'top half' of an interrupt handler is what I would
   have just called 'the interrupt handler' -- the part that runs at
   interrupt level, with at least interrupts of its own sort disabled.

 - the 'bottom half' has some specific historical meanings, but today
   basically just means 'any deferred work triggered by an interrupt'.

 - different deferred work mechanisms exist, with different tradeoffs
   of how long they defer work vs how much of a pain to use they are.

 - 'softirqs' are the fastest, running basically as soon as all 'real'
   (aka 'hard') interrupts have been handled, before returning to
   'process context'.  Softirqs can be interrupted but cannot sleep.

   = 'process context' is when you're executing either in a kernel
     thread, or on behalf of a user process (e.g. (or i.e.?) in a
     system call).  Among lots of other things, the signature feature
     of being in process context is that you can sleep.

 - 'tasklets' are built on softirqs but are easier to use for some
   reason I don't exactly recall (mostly because I didn't really
   figure out how to use softirqs.)

 - 'work queues' are data structures / functions you register on a
   (usually) preestablished kernel thread.

 - 'kernel threads' are just what they sound like.  Communication
   protocols between the (top half) interrupt handler and the thread
   is entirely up to you.

To manage shared data, you generally need some combination of
disabling interrupts and spinlocks (but the spinlock macros are empty
on a uniprocessor system).  There are also full-on mutexes of various
sorts but I didn't dig into them.

[22: Sat Oct 14 06:40:21 2017 (Except one of Derek Molloy's sample LKM
uses a mutex to provide exclusive access to a module -- and I think we
want to follow that so only mfmt2 will access the lock system, and the
lock system won't have to deal with reentrant syscalls.)  :22]

[20:

Sat Oct 14 05:43:27 2017 In my situation it's not completely clear I
need much of an explicit bottom half at all, except perhaps for
handling time-outs.  We're trying to design the state transition code
to be totally fast enough to run to completion in the top half, and
other than that..

Things we have to get done:

 - Respond to edges on IRQLK and IGRLK.  Note that in general, after
   there's an edge on either of them, there won't be any more edges
   (for a long time) until we make an edge on our ORQLK or OGRLK.  So
   that may help us avoid losing edge interrupts.

 - Reset if things get wedged for more than a few jiffies.

 - Decide whether to declare a neighbor offline or online based on
   their activity and/or getting to sIDLE with them.  (We might see
   spurious edges from time to time, and they shouldn't cause a
   neighbor to be declared 'up' if it wasn't recently.)

 - Respond to try and free lock requests from user space.

 - Respond to open and close requests from user space.

And the main sync issues seem to be between the user process context
and the interrupt level.  It seems we might only need a kernel thread
or some other kind of timer to handle time out if we lose an edge or
the neighbor disappears or whatever.  So let's ignore that for now and
say there's just two players -- user space system calling into my LKM
code, and the interrupt handler running on an external edge.

[21:

Sat Oct 14 06:23:26 2017 We 'already have' paired connections getting
to sIDLE with each other, and for the moment that would basically be a
'permanent' condition except that we are artificially failing the
connections every ten seconds or so in a background kernel thread, to
force them to resync.

And we have done a few manual tests where we grabbed the lock using
the /sys/class/gpio interface we export, and we got the expected
behavior.

We were thinking about making a char device for interacting with the
module, so you could open it once and then do blocking writes to make
requests and blocking reads to get replies.. But that does mean two
system calls where an ioctl could do it in one..  I didn't focus much
on how to set up an ioctl though.  They feel old and crufty and hard
to use from my experiences in user space.

Well let's read up on ioctl's a little bit here.[23:

Sat Oct 14 08:24:04 2017 Well, Robert Love apparently holds up ioctl
as the poster child for what a system call should _not_ be.. but then
people say 'don't write new system calls', and suggest writing device
nodes with read write and ioctl instead..  Thanks.  Thanks a lot.
[24:

Sat Oct 14 15:03:12 2017 Hey, why can't we return the lock results in
the blocking write return value?  0 means the request was done
completely as requested, anything else is status info about what went
wrong.  Then it's (relatively) natural, it's only one system call, and
it's not an ioctl.

If we could eventually support non-blocking I/O, we might even be able
to overlap making a lock request with speculative execution like
loading the event window.  But we'd want to interrupt that as soon as
the lock attempt failed, or else we'd end up further behind.

  :24]
  :23]

  :21]

  :20]

  :19]
[25:

Sun Oct 15 01:56:43 2017 OK, let's try again.  This time suppose we
start from the userspace point of view.

So this is /dev/itlocks and we (mfmt2) are going to open it like

  int lockfd = open("/dev/itlocks",O_RDWR);  // with suitable sudo or udev..
  if (lockfd < 0) FAIL(..)

(given that some prior mechanism already did '# insmod itc.ko')

(I don't really like '/dev/itlocks' as a name, because I'm not using
'it' anywhere else to mean 'intertile'.  But '/dev/itclocks' looks
like it's about clocks.  /dev/lockitc?  /dev/lockit??  I wanted to do
like /dev/itc/locks but it seems[26:

Sun Oct 15 02:26:58 2017 With internet + stack overflow FTW yet again
we now are on /dev/itc/locks, after this massive change:

-#define  DEVICE_NAME "itcdev"     ///< The device will appear at /dev/itcdev/
+#define  DEVICE_NAME "itc!locks"     ///< The device will appear at /dev/itc/locks/

Yes, of course, naturally, '!'.

And furthermore, from the Molloy example we started with, that device
is already hooked up:

(root@beaglebone:/home/t2/T2-12/lkms/itc# tail -f /var/log/messages&)

root@beaglebone:/home/t2/T2-12/lkms/itc# cat </dev/itc/locks
Oct 15 08:25:53 beaglebone kernel: [32182.704948] Itc: Device has been opened 1 time(s)
Oct 15 08:25:53 beaglebone kernel: [32182.737286] Itc: Sent 0 characters to the user
Oct 15 08:25:53 beaglebone kernel: [32182.758347] Itc: Device successfully closed
root@beaglebone:/home/t2/T2-12/lkms/itc#

  :26])

  :25][27:

Sun Oct 15 02:34:30 2017 So anyway.  Idea is we write ONE BYTE to try
for a set of locks, as a bitmask, and we get back 1 if we got the set
we wanted, or 0 if we didn't.  That's not the normal syscall return,
but it's sort of like the 'return the number of bytes written' that
write() is supposed to return.

For starters that will be a blocking write, and 'atomic' in that when
the call returns we will either have all the requested locks or none
of them.

And since a lock set only takes six bits, we have room for extra
control codes as well, like for resetting things, or explicitly
enabling and disabling locking in given directions.

Let's say the byte format is:

    0  1  2  3  4  5  6  7
  +--+--+--+--+--+--+--+--+
  | CMD |ET|SE|SW|WT|NW|NE|
  +--+--+--+--+--+--+--+--+

and

  CMD = 00 -> try for this set of locks (forsaking all others)
  CMD = 01 -> enable selected locks (leaving others alone)
  CMD = 10 -> disable selected locks (leaving others alone)
  CMD = 11 -> reset selected locks (leaving others alone)

So a null (0x00) means 'free all locks I hold', and a rubout (0xFF)
means 'reset all locks'.  And delete (0x7f) means 'enable all locks',
which seems unintuitive, but nobody is supposed to know what the ASCII
code of delete is anyway.

Guess I'm not sure if resetting should include disabling, enabling, or
neither..  Maybe we can say enabled is the default state, so resetting
should include enabling.  Because, really, when we say reset, here,
what we mean is resetting the locking state machine that has no
purpose when the channel is disabled.

(We'll need to extend the state machine with uENABLE, uDISABLE, and
sDISABLED, I think.) (But we still don't really know how user input is
going to interact with the state machine anyway.)

[28:

Sun Oct 15 03:03:17 2017 OK, so for now it's:

  CMD = 11 -> enable and reset selected locks (leaving others alone)

and I guess there's no way to reset a disabled lock.  Which
'obviously' 'nobody' 'would ever want to do'.

So our opening sequence becomes:

bool T2LockManager::Init() {
  m_lockfd = open("/dev/itc/locks",O_RDWR);  // with suitable sudo or udev..
  if (m_lockfd < 0) { Error(..); return false; }
//201710150352: WAS:  u8 cmd = 0xff;          // enable and reset all
  u8 cmd = 0x7f;          // enable and reset all
  int wrote = write(m_lockfd, &cmd, 1);
  if (wrote != 1) { Error(..); return false; }  // reset should work!
  return true;
}
[30: 

Sun Oct 15 03:49:04 2017 So, continuing..  In use:

inline bool T2LockManager::TryLockset(u8 lockset) {
  if (m_lockfd < 0) FAIL(ILLEGAL_STATE);     // open it first you norg
  return FastTryLockset(lockset);
}
inline void T2LockManager::FreeAllLocks() { TryLockset(0); }

inline bool T2LockManager::FastTryLockset(u8 lockset) {
  return 1 == write(m_lockfd, &lockset, 1);
}
inline void T2LockManager::FastFreeAllLocks() { FastTryLockset(0); }

[31: 

Sun Oct 15 04:00:27 2017 And that all seems vaguely plausible.  We
need to go back to the LKM side now, be thinking about the user<>FSM
interaction, and try to implement some minimal char device stuff.
             
Like we should be able to get to:

inline u8 T2LockManager::GetLocksHeld() { 
  u8 buf;
  if (m_lockfd < 0) FAIL(ILLEGAL_STATE);
  if (1 != read(m_lockfd, &buf, 1)) FAIL(..);
  return buf;
}

or something.  With the idea that a single read always starts with the
locks held?  And if someone reads multiple bytes they want additional
state?  Maybe it would be better to implement seeking.  Do char
devices normally do that?[32: 

Sun Oct 15 04:11:30 2017 Seems like they certainly can, even if they
often don't because in many cases doesn't make sense.  The position
seems to be that unless you so disk-like that you want to be
integrated into the buffer cache system and the virtual memory system
and so on, then you're a character device.  They note, for example,
that /dev/kmem is a character device, and it's emininently seekable..

So we're a char device.  We can support seek if we want.  We could
pretend we have a whole 'memory layout' of information that you could
seek to different parts of and read what you wanted.

But we're not going to do that now.  Right now you read one byte and
get a bitmask of the locks we hold.  Read two bytes and you get that
plus a bitmask of the locks somebody else holds.  Read three bytes and
you get that plus a bitmask of directions considered active based on
interaction history.  Try to read more and the return value stays 3.

[33: 

Sun Oct 15 07:40:21 2017 OK, starting to run down a bit now, but we
have a minimal sort of sample read working that returns some vaguely
plausible status info on the locks.

We note that at the moment we are doing nothing about disabling
interrupts or spinlocks or whatever while we're accessing the data.
It's totally possible for interrupts to hit while we're iterating over
the lock info.  

Due to my limited imagination at the moment, I'm having trouble seeing
why we should care even if it does.

This information is all advisory anyway, and stale even before it's
sent to userspace.  All our counters for events and jiffies are u32's
which I believe are atomically written.  So if a lock state changes
between asking if it's taken and asking if it's idle, is that so
horrible?

Well, maybe.  We don't really know what if anything mfmt2 will be
doing with this information, except possibly displaying it around the
border of the screen, in which case who gives a fuck if it's
inconsistent for a moment.

Almost surely, things will be different on the dev_write side of
things, where we will be promising best-effort all-or-none atomicity
in lockset allocation.

  :33]
  :32]

  :31]
  :30]
[29:

Sun Oct 15 03:20:31 2017 Although if CMD = 11 means 'enable and reset
selected locks', do we need 'CMD = 01 -> enable selected locks'?  How
much value is there in enabling a lock without resetting it?  If we
could get that code back we could have a lot more room to work with.

Something like

  CMD = 00 -> try for this set of locks (forsaking all others)
  CMD = 01 -> enable and reset selected locks (leaving others alone)
  CMD = 10 -> disable selected locks (leaving others alone)
  CMD = 11 -> special command, format

                    0  1  2  3  4  5  6  7
                  +--+--+--+--+--+--+--+--+
                  | 1| 1| SUBCMD | LK_IDX |
                  +--+--+--+--+--+--+--+--+

              where LK_IDX = 0..5 -> ET..NE,
                    LK_IDX = 6 -> reserved, illegal
                    LK_IDX = 7 -> all locks

           and the eight possible SUBCMDs could include things like
           setting long or short timeouts on a particular channel or
           whatever. 

           But really this is getting silly.  If we need that much
           configuration we should just fucking implement ioctl as
           well, and be done with it.  So let's just calm down here:

  CMD = 11 -> reserved, illegal


  :29]

  :28]

  :27]
[34: 

Fri Oct 27 16:36:53 2017 OK, well, we might have a day here tomorrow
to try to push this again.  Let's make some

TODO

 - Reread and determine where we are

 - Settle on a Minimum Viable Product to go for in the char device
   protocol land

 - Get that MVP framework working except for the actual locking step.
   Have the user context sleep pretending it's waiting for the locking
   to happen, and have the existing kernel thread wake it up after a
   while.  Maybe have the kthread randomly pretend we got or didn't
   get some locks.

 - See our test code asking for locks and getting them sometimes, and
   then releasing them, and sometimes not, and therefore have nothing
   to release.

  :34]
[35: 

Sun Oct 29 03:46:11 2017 OK.  Where we were was thinking about a R/W
protocol for a char device to get locks.

MVP for char device protocol:

    7  6  5  4  3  2  1  0
  +--+--+--+--+--+--+--+--+
  | CMD |ET|SE|SW|WT|NW|NE|
  +--+--+--+--+--+--+--+--+

CMD =def= 0 for MVP.  Meaning is: Attempt to acquire all locks
corresponding to set bits 0..6 and release all locks we hold
corresponding to clear bits 0..6.

 - WRITE of >0 bytes performs an s32 interpretCommandByte(u8) on each
   written byte in turn, incrementing a counter long as
   interpretCommandByte returns 0.  If interpretCommandByte ever
   returns negative, the write stops, and then there are two cases
   depending on whether the counter is zero or not.  If the counter is
   0, the write returns the negative value, otherwise, it returns the
   counter value.

   There is no non-blocking write in the MVP.

 - Errors from interpretCommandByte:
    [37: Sun Oct 29 04:46:15 2017 Already had this, with another case:
    -ENODEV if unimplemented code is encountered                      :37]
    -EINVAL if CMD != 0
    -EBUSY  if far side holds a requested lock
    -EIO    if far side apparently exists but negotiation timed out

 - READ of >0 bytes fills the requested space with the current lock
   status.

[36: 

Sun Oct 29 04:34:39 2017 Subplan 

TODO:

[38: Sun Oct 29 05:00:03 2017 DONE  :38] - Look at the goddamn code

[39: Sun Oct 29 05:11:22 2017 DONE, testing EINVAL and ENODEV  :39] - Get the write code working with a stub interpretCommandByte

[40: Sun Oct 29 05:11:43 2017 DONE, for a pretty lame idea 'working'  :40] - See that working

[41: Sun Oct 29 05:12:03 2017 HERE I AM  :41] - Come back here

  :36]
  :35]
[42: 

Sun Oct 29 05:12:09 2017 OK, so now what.  The code already had some
spinlock irqsave code in it, which I disabled for the 'lame stub'.  I
guess the real issue is who/how actually kicks off the scan of the cmd
and starts trying to drive the state machines.

In the existing code, we set up 'userLockset' and 'userRequestActive'
and then just returned.  Strategies:

 (1) Leave it to a timer thread: User context should set the variables
     under spinlock_irqsave, then wake the timer thread, then go to
     sleep waiting for the lock negotiation to proceed.  Eventually
     somebody wakes the user context, or it times out, and succeeds or
     fails appropriately.

 (2) Do it itself: While holding m_lock in spinlock_irqsave, user
     context should should set the variables and call updateState
     once, to get that state change 'noticed'.  User context then
     releases m_lock and starts sleeping, leaving all the rest to be
     done by the interrupt handler.  Eventually the interupt handler
     wakes the user context, or the latter times out (if an edge was
     missed, or a tile disconnection occurs), and succeeds or fails
     appropriately.


[43: 

Sun Oct 29 05:45:18 2017 (2) seems like the more official, or at the
least-unjustified-hair, way to go.  So let's try for that and go for
some subplan:

TODO

[46: Sun Oct 29 06:47:05 2017 DONE, except now we what to loop around
it instead of inside it..  :46] - Reenable the commented-out spinlock stuff

 - Call updateState inside the user context critical region[45: Sun
   Oct 29 05:52:44 2017 Actually it would need to be updateStates(),
   currently being called from the kthread.  But I'm afraid that would
   take too long.  Can we just do one at a time, and spinlock around
   each, to let interrupts in in-between?  If the interrupt response
   is as fast as we're fantasizing it could maybe be, conceivably
   negotiations on early lock grabs would begin while we're still
   setting up for the later ones.  (And that would be an extra good
   reason for the shuffled indices.)  :45]

 - Figure out how to sleep user context.[47: 

Sun Oct 29 07:41:55 2017 Actually, let's just focus on this for now.

[48: Sun Oct 29 08:31:01 2017 DONE, perhaps.  A first cut anyway  :48] - Sleep the user context until the kthread runs and wakes us up.
   Let's see about just that.

  :47]

[50: Mon Oct 30 04:16:04 2017 DONE, and tweaked various ways from there  :50] - Have it sleep for up to say 10ms.  Fucking negotiations should be
   way done by then.

[51: Mon Oct 30 04:16:17 2017 DONE  :51] - Watch it time out because our negotiation stuff isn't ready for
   this yet.

[52: Mon Oct 30 04:16:24 2017 DONE  :52] - Have our testing tile be connected only to itself for now, so we
   can see all sides of the negotiations.

[44: Sun Oct 29 05:49:31 2017 Then a little further out, perhaps:

[53: Mon Oct 30 04:16:34 2017 DONE  :53] - Figure out if the userLockset stuff is even used

[54: Mon Oct 30 04:16:38 2017 DONE  :54] - Use it

  :44]

  :43]
  :42]
[49: 

Sun Oct 29 11:21:38 2017 Some little progress.

TODO

 - Make a userspace script that displays gpio states in an
   'ITC-friendly fashion', based on /sys/class/gpio

[55: Mon Oct 30 04:16:47 2017 DONE  :55] - Make dev_read return however much state internals you ask for,
   based on byte count.

READ RETURN:

 Note all data is advisory and possibly contradictory - no locking is
 performed during data acquisition.

 0 - Locks we currently hold (in state sTAKEN)
 1 - Locks unsettled         (in state sTAKE, sRACE, sSYNC01)
 2 - Locks held against us   (in state sGIVE)
 3 - Locks open              (in state sIDLE)
 4 - Locks failed            (in state sFAILED)
 5 - Locks reset             (in state sRESET)

 6+ - reserved, returns 0

  :49]
[56: 

Mon Oct 30 04:16:54 2017 So, a pretty productive weekend, finally, on
the /dev/itc/locks front.  Need to switch to school and other crap for
a while, but before we go, some more

TODO

 - Next main design question is how do we know when a lockset
   negotiation is done?  Right now we're just timing out from the
   kthread and that's when the write returns.  We've cut that timeout
   down to like 10msecs which appears based on logging to usually, but
   not always, be plenty of time.  

 - Consider whether we can have a per-lock 'unsettled bit' that can be
   cleared somehow -- perhaps by some new kind of explicit rule, or by
   entering some set of states.

 - We need the interrupt routine to wake the user context when all
   'unsettled' bits are clear.  The kthread should only be doing that
   in error conditions like missed edges.

 - Determine if my M/F extender cable can be used to loopback an ITC
   powertab.  We need some such functionality so we can loopback all
   six edges, instead of the max four we can do now.

 - Get some actual loopback lock-grab timing data, once the interrupt
   can wake user context and we can loop all edges.

 - Get some actual intertile timing and robustness data using two
   interlooped tiles.

  :56][57: 

Fri Nov 10 13:15:55 2017 OK so lost a lot of time on .. stuff.  Of
which only a little was directly T2-12 related, unfortunately.  (Did
do a redo of the T2-12 case latching base, which now takes a _lot_
more space on the build platform, but now pulls the posts towards the
board, rather than tending to spread them, and provides greater and
more 'artistic' protection and support for the board.)

Anyway, so we have run across a RULES.h issue that we want to address
as a priority here: Sometimes gingers get solid i11 from unconnected
faces, and they do an aggravating sRESET->sSYNC->sFAILED->sRESET loop
at high speed.  It's only the gingers since they move first out of
sRESET, but still.

So we're thinking we need to have a FAILED mechanism that cannot be
escaped quickly except by seeing _some_ kind of edge.  The problem is
like all the edges are potentially busy meaning other things in other
contexts. 

How about this?  Have two failure/reset stages, one where fred has to
go first, and one where ginger has to go first.  So we'll hang, or
long timeout anyway, in one or the other of those states, if nobody is
actually changing.



On 'original' failure, go to sFAILED,o11

In sFAILED,i11, freds go to sPRESET,o01
In sFAILED,i11, gingers stay in sFAILED
In sFAILED,i01, gingers go to sPRESET,o01

In sPRESET,i11, freds stay in sPRESET
In sPRESET,i01, freds go to sRESET,o11
In sPRESET,i01, freds go to sRESET,o11

[58: 

Fri Nov 10 14:22:18 2017 Or suppose when ginger times out of sSYNC01,
instead of going to sFAILED goes to sWAIT, which has a magically
increasing timeout every time we enter sWAIT without having reached
sIDLE.  So this now extended loop --
sRESET->sSYNC->sWAIT->sFAILED->sRESET -- keeps happening, just slower
and slower, as the ginger increasingly despairs of finding a fred.

Let's try for that..[59: 

Fri Nov 10 14:31:29 2017 Why am I coding this on my laptop??
Committing to get this crap over to the tiles..

  :59]


  :58]

  :57]
